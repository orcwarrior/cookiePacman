/**********************************
 *  TO DO LIST:
 * * Finish rescaling/repositioning when changing resolution.
 * * Credits
 * * Kiling player, respawn after killing + hurt textures
 * * Kiling MOB (by another mob, or player bomb) + hurt/dead textures
 * * Database for high scores downloading hight scores
 * uploading player scores to database.
 * * Create gameTips class + graphics and all needed objects of it.
 * * Create rest of maps
 * * Let game difficult, level numbers affect gameplay
 * * Don't let entering illegal chars for filename when setting profile name.
 * * GameMap: From list of rendered objects to 2D arrays of [x,y] grid
 * * Obj Class: adding Layer property so At the end, objects of 0 layer are rendered first, then Layer 1 ...etc
 * 
 * ERRORS:
 * ERROR: Exception caught when attempting to load file ../data/Textures/GAME/GUI/SKILL_REFRESHING_100.dds. (FIXED)
 * 
 * BUGS:
 * Bug occur when exiting to main menu from game when time slow was active an music was turned down to low volume
 * on exiting to menu, add some check if timeSlow is active and then set music volume to one saved at profile file
 * *********************************/
using System;
using System.Drawing;
using System.Collections.Generic;
using System.Reflection;

using OpenTK;
using OpenTK.Input;
using OpenTK.Platform;
using OpenTK.Graphics;
using CookieMonster.CookieMonster_Objects;
using System.Threading;
using TextureLoaders;

namespace EngineApp
{
    class Game : GameWindow
    {
        static public Game self; // Game is singleton
        [Flags]
        public enum game_state { Undef = 0,Menu = 2, Game = 4 };//ingame menu = Menu|Game
        public game_state gameState = game_state.Undef;
        public Viewport gameViewport{get; private set;}
        public Viewport menuViewport { get; private set; }

        public Viewport activeViewport
        {
            get
            {
                if ((gameState & game_state.Menu) == game_state.Menu)
                    return menuViewport;
                else if ((gameState & game_state.Game) == game_state.Game)
                    return gameViewport;
                else
                    return null;
            }
        }
        public Viewport activeViewportOrAny
        {
            get
            {
                Viewport a = activeViewport;
                if (a != null) return a;
                else if (gameViewport != null) return gameViewport;
                else if (menuViewport != null) return menuViewport;
                else return null;
            }
        }
        private IntPtr _winhdl;
        public IntPtr windowHandle { get { return _winhdl; } }
        Timers_Manager timeMgr = new Timers_Manager();
        public Menu_Manager menuManager { get; private set; }
        SoundManager sndMgr; public SoundManager SoundMan { get { return sndMgr; } }
        public TextManager textMenager { get; private set; }
        GameManager gameMgr; public GameManager gameManager{ get{return gameMgr;}}
        Camera gameCam; public Camera gameCamera{get{return gameCam;}}
        Debug debugger;
        public VideoPlayer videoPlayer { get; private set; }
        public lightingEngine lightEngine { get; private set; }

        // Those values need to be stored at the begining
        // Used for proper rescale of menu items etc. "GUI" type Obj's
        // Now theese values are straight from configuration class

        
        //SimpleEngine stuff:
        Engine.Core core  = new Engine.Core();
        Engine.GuiManager gmgr = new Engine.GuiManager();
        Engine.GuiTheme theme = new Engine.GuiTheme();
        double time;
        int frames;



        public Game(int w, int h)
            : base(w, h)
        {
            self = this;
            menuViewport = new Viewport(w, h, true);
            gameViewport = new Viewport(w, h, true);
            Mouse.ButtonDown += new EventHandler<MouseButtonEventArgs>(Mouse_ButtonDown);
            Mouse.ButtonUp += new EventHandler<MouseButtonEventArgs>(Mouse_ButtonUp);
            Keyboard.KeyDown += new EventHandler<KeyboardKeyEventArgs>(Keyboard_KeyDown);
            Keyboard.KeyUp += new EventHandler<KeyboardKeyEventArgs>(Keyboard_KeyUp);
            KeyPress += new EventHandler<KeyPressEventArgs>(Keyboard_KeyPress);
            Keyboard.KeyUp += new EventHandler<KeyboardKeyEventArgs>(Profile.Profile_KeyStroke);
        }

        public void Keyboard_KeyPress(object sender, KeyPressEventArgs p)
        {
            InputManager.KeyPress(sender, p);
        }
        public void Mouse_ButtonDown(object sender, MouseButtonEventArgs e)
        {
            if(menuManager!=null)
            menuManager.setButtonState(e.Button, true);
        }
        public void Mouse_ButtonUp(object sender, MouseButtonEventArgs e)
        {
            if (menuManager != null)
            menuManager.setButtonState(e.Button, false);
        }
        public void Keyboard_KeyDown(object sender, KeyboardKeyEventArgs k)
        {
            if(gameMgr!=null)
               gameMgr.KeyboardEvt(sender,k);
            InputManager.KeyDown(sender, k);

            //skip playing videos:
            videoPlayer.keyDown(sender, k);

            if (k.Key == Key.S)
                gameCamera.Move(0, -50);
            if (k.Key == Key.W)
                gameCamera.Move(0, 50);
            if (k.Key == Key.A)
                gameCamera.Move(-50,0);
            if (k.Key == Key.D)
                gameCamera.Move(50,0);
                    
        }
        public void Keyboard_KeyUp(object sender, KeyboardKeyEventArgs k)
        {
            InputManager.KeyUp(sender, k);

        }
        public int fps { get { return (int)RenderFrequency; } }
        protected override void OnLoad(EventArgs e)
        {

            //Set proper resolution + full-screen mode:
            OpenTK.DisplayResolution filmResolution = OpenTK.DisplayDevice.Default.SelectResolution(1280, 800, 32, 0);
            OpenTK.DisplayDevice.Default.ChangeResolution(filmResolution);
            //check is current runing system is winXP:
           if(Environment.OSVersion.Platform == PlatformID.Win32NT && Environment.OSVersion.Version.Major == 5)
                EngineApp.Game.self.WindowState = OpenTK.WindowState.Fullscreen; //BUGFIX: Set now to fullscreen only on winXP
            
            core.Init();
            textMenager = new TextManager();
            menuViewport = new Viewport(1280, 800, true);
            gameViewport = new Viewport(1280, 800, true);
            gameState = game_state.Menu;//tmp for renderLoadingCaption
            Profile.Initialize();
            lightEngine = new lightingEngine();
            renderLoadingCaption();//needs profile &txtManager
            menuManager = new Menu_Manager();
            new Menu("forStaticInitiation", null);
            gameState = game_state.Undef;

            //Select language:
            new Lang(Lang.language.PL);

            initTextureLoaderParameters();
            videoPlayer = new VideoPlayer();
            GL.Disable(EnableCap.DepthTest);

            debugger = new Debug();//debug system uses text manager
            KeyPress += new EventHandler<KeyPressEventArgs>(menuManager.KeyPress);
            sndMgr = new SoundManager();
            new DebugMsg(this, "fps", DebugLVL.info);
            gameCam = new Camera(Camera.eType.STATIC);


            //get window handle:
            IWindowInfo ii = ((OpenTK.NativeWindow)this).WindowInfo;
            object inf = ((OpenTK.NativeWindow)this).WindowInfo;
            PropertyInfo pi = (inf.GetType()).GetProperty("WindowHandle");
            _winhdl = ((IntPtr)pi.GetValue(ii, null));
            

            Sound.setSndMgr(sndMgr);

            // Play birds sound:
            Sound bg_birds = new Sound(Sound.eSndType.MUSIC, "../data/Sounds/MENU_BIRDS_BG.ogg", true, false);
            bg_birds.fadeIn(0.15f, 10 * 1000);
            bg_birds.Play();

            //hide cursor:
            System.Windows.Forms.Cursor.Hide();

            //play logo video:
            videoPlayer.playVideo("../data/Videos/logo.bik");

            gameState = game_state.Undef;
            //Open menu
            menuManager.current_menu = new Menu("MENU_PROFILE", Menu_Instances.Menu_Profile_Open, Menu_Manager.cursor);

         }

        private static void initTextureLoaderParameters()
        {
            TextureLoaderParameters.MagnificationFilter = TextureMagFilter.Linear;
            TextureLoaderParameters.MinificationFilter = TextureMinFilter.LinearMipmapLinear;
            TextureLoaderParameters.WrapModeS = TextureWrapMode.ClampToBorder;
            TextureLoaderParameters.WrapModeT = TextureWrapMode.ClampToBorder;
            TextureLoaderParameters.EnvMode = TextureEnvMode.Modulate;
            
        }

        protected override void OnUnload(EventArgs e)
        {
            Viewport.scaleLog.Close();
            Debug.debugLog.Close();
            gmgr.Free();
        }

        protected override void OnResize(EventArgs e)
        {
            core.Resize(Width, Height);
        }
        protected override void OnUpdateFrame(FrameEventArgs e)
        {
           // if (videoPlayer.someVideoIsPlaying)
           //     return; //don't update Game stuff when video is playing 

            SoundMan.Update();
            timeMgr.Update();
            if (gameCam != null)//before viewports 'n stuff
                gameCam.Update();
            menuManager.onUpdate();
            if (((gameState & game_state.Menu) == game_state.Menu) || (menuViewport.isFading))
                menuViewport.Update();
            if (((gameState & game_state.Game) == game_state.Game) || (gameViewport.isFading))
                gameViewport.Update();
            if (gameMgr != null)
                gameMgr.Update();

            if (Keyboard[Key.Escape] && Keyboard[Key.ShiftLeft]) Exit();
             
            if ((time += e.Time) >= 1.0)
            {
                time = 0;                
                frames = 0;
            }
            if (debugger != null) debugger.Update();


        }
        protected override void OnRenderFrame(FrameEventArgs e)
        {
            frames++;
            //Video playback stuff:
            if (videoPlayer.renderVideoLoop())
                return; //video processed, so there is nothing to process of game mechanics etc.
            core.Clear();
            lightEngine.renderStaticLightmaps();
            //SwapBuffers(); return;
            GL.Hint(HintTarget.TextureCompressionHint, HintMode.Fastest);
            GL.Hint(HintTarget.LineSmoothHint, HintMode.Fastest);
            GL.Hint(HintTarget.GenerateMipmapHint, HintMode.Fastest);
            GL.Hint(HintTarget.PerspectiveCorrectionHint, HintMode.Fastest);
            GL.Hint(HintTarget.PolygonSmoothHint, HintMode.Fastest);
            GL.Hint(HintTarget.FogHint, HintMode.Fastest);
            GL.Hint(HintTarget.FragmentShaderDerivativeHint, HintMode.Fastest);
            GL.Disable(EnableCap.DepthTest);
            GL.Disable(EnableCap.CullFace);
            GL.Disable(EnableCap.Lighting);
            GL.Disable(EnableCap.Dither);
            GL.Disable(EnableCap.Fog);
            GL.Disable(EnableCap.LineSmooth);
            GL.Disable(EnableCap.Multisample);
            GL.Disable(EnableCap.PointSmooth);
            GL.DepthMask(false);
            
            //render viewports:

            if (((gameState & game_state.Game) == game_state.Game)||(gameViewport.isFading))
                gameViewport.Render();

            //MENU Always overlay GAME layer!
            if (((gameState & game_state.Menu) == game_state.Menu) || (menuViewport.isFading))
                menuViewport.Render();
            menuManager.onRender();//render menu stuff overlaying viewport(bg, etc.)

            if (debugger != null) debugger.Render();
            
            // Lightning Engine will now render light overlaying everything else:
            // NOTE: If lights was rendered during GameManager.Render() method
            // this call will do nothing.
                lightEngine.Render();

            SwapBuffers();
        }

        // mine' methods:
        public void setScreenMode(bool fullscreen)
        {
         if(fullscreen)   
            base.WindowState = WindowState.Fullscreen;
         else
            base.WindowState = WindowState.Normal;
        }
        public int getFrame()
        {
            return frames;
        }
        public void InitGameManager()
        {
            gameState = game_state.Game;
            gameMgr = new GameManager();            
        }
        public void InitCamera()
        {
            gameCam = new Camera();
        }
        /// <summary>
        /// Occurs when closing gameMgr session fe:
        /// Ending game / Quiting to main menu
        /// </summary>
        public void closeGameManagerSession()
        {
            //TODO: remove all ingame ObjAni, Timers (Obj)[TODO]
            gameMgr.Free();
            gameMgr = null;
            gameState = gameState & ~game_state.Game;
        }
        [STAThread]
        static void Main()
        {
            using (Game game = new Game(1280, 800))
            {
                game.VSync = VSyncMode.Adaptive;
                game.Title = "CookieMonster Pacman";
                game.Run(60);
            }
        }
        /// <summary>
        /// Initiation of sounds that will be called before calling of
        /// Game manager initation (when new game buttons been hit)
        /// </summary>
        private void initGamePreGameManager()
        {
            SoundMan.getSoundByFilename("../data/Sounds/MENU_THEME.ogg").Free();
            SoundMan.getSoundByFilename("../data/Sounds/MENU_BIRDS_BG.ogg").Free();
            lightEngine.clearAllLights();
        }
        /// <summary>
        /// Func. called after initiation of gameManager
        /// </summary>
        private void initGamePostGameManager()
        {
            gameState = game_state.Game;
            menuViewport.Clear();
        }
        /// <summary>
        /// Loads gameManager from passed
        /// savegame
        /// </summary>
        /// <param name="savegame"></param>
        internal void loadGame(Savegame savegame)
        {
            initGamePreGameManager();
            gameMgr = new GameManager(savegame);
            initGamePostGameManager();
        }
        /// <summary>
        /// Just normally starts (New)GameManager
        /// plays intro video additionally
        /// </summary>
        internal void startGame()
        {
            initGamePreGameManager();
            videoPlayer.playVideo("../data/Videos/intro.bik");
            
        }
        public void afterIntroVideo()
        {
            gameMgr = new GameManager();
            initGamePostGameManager();
        }
        internal void afterLogoVideo()
        {   
            //set game state to menu:
            gameState = game_state.Menu;
            //Show "loading..." caption:

            renderLoadingCaption();

            //check is current runing system is >winXP:
            //if (Environment.OSVersion.Platform == PlatformID.Win32NT && Environment.OSVersion.Version.Major > 5)
            //    EngineApp.Game.self.WindowState = OpenTK.WindowState.Fullscreen; //BUGFIX: Set now to fullscreen only on winXP

            //Show menu:
            //menuManager.current_menu = new Menu("MENU_PROFILE", Menu_Instances.Menu_Profile_Open, Menu_Manager.cursor);
        }

        public static void renderLoadingCaption()
        {
            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);//Clear buffer

            String msg = "Loading...";
            float xCenter = (float)Game.self.activeViewportOrAny.width/ 2f;
            float yCenter = (float)Profile.currentProfile.config.options.graphics.resolution.Height/ 2f;
            float xMinus = TextManager.font_default_20.Measure(msg).Width / 2;
            Text loading = Game.self.textMenager.produceText(TextManager.font_default_20, msg, xCenter - xMinus, yCenter, QuickFont.QFontAlignment.Left);

            loading.Print();
            Game.self.SwapBuffers(); //Render buffer
        }
    }
}

using System;
using System.Collections.Generic;

using System.Text;
using EngineApp;

namespace CookieMonster.CookieMonster_Objects
{
    class Camera
    {
        public enum eType { STATIC, FOLLOWS_PLAYER }
        public eType type = eType.FOLLOWS_PLAYER;

        int _camOffsetX = 0; public int camOffsetX { get { return _camOffsetX; } }
        int _camOffsetY = 0; public int camOffsetY { get { return _camOffsetY; } }
        int toleranceField = (4 * GameManager.gridSize) / 2;
        int heroLocationBooster;
        public Camera(eType t)
        {
            type = t;
        }
        public Camera()
        {
            type = eType.FOLLOWS_PLAYER;
            centrize();
        }
        public void Update()
        {
            if (type == eType.FOLLOWS_PLAYER)
            {
                //TODO: change pos by steps? less moving in time
                //cause it makes game lag teribly...
                //return;
                int UnChanged = 0;
                const int MOVE_STEP = 2;
                GameManager GM = Game.self.gameManager;
                Viewport VP = Game.self.activeViewport;
                int oldX = _camOffsetX, oldY = _camOffsetY;
                if (GM == null) return; //no game - no camera centering
                if (GM.PC == null) return; //no hero - no camera centering

                if (_camOffsetX + toleranceField < (VP.width / 2 - GM.PC.pX + GameManager.gridSize))
                {
                    int a = _camOffsetX + VP.width;
                    int b = (GM.Map.mapWidth - 1) * GameManager.gridSize;
                    if (_camOffsetX < GameManager.gridSize)//hero moving left
                        _camOffsetX += MOVE_STEP + heroLocationBooster * 10;
                    else UnChanged += 1;
                }
                else if (_camOffsetX - toleranceField > (VP.width / 2 - Game.self.gameManager.PC.pX - GameManager.gridSize))
                {
                    int rMapEdge = _camOffsetX + (GM.Map.mapWidth + 1) * GameManager.gridSize;
                    if (rMapEdge >= VP.width)
                        _camOffsetX -= MOVE_STEP + heroLocationBooster * 10;//move right camera
                    else UnChanged += 1;
                }
                else UnChanged += 1;

                if (_camOffsetY + toleranceField + Game.self.gameManager.PC.pY < VP.height / 2)
                {
                    if (_camOffsetY < -GameManager.gridSize)
                    {
                        _camOffsetY += MOVE_STEP + heroLocationBooster * 10; // move UP(?)
                    }
                    else UnChanged += 1;
                }
                else if (_camOffsetY - toleranceField + Game.self.gameManager.PC.pY > VP.height / 2)
                {
                    int rMapEdge = _camOffsetY + (GM.Map.mapHeight + 1) * GameManager.gridSize;
                    if (rMapEdge >= VP.height)
                        _camOffsetY -= MOVE_STEP + heroLocationBooster * 10; // move DOWN(?)
                    else UnChanged += 1;
                }
                else UnChanged += 1;

                if (UnChanged == 2) heroLocationBooster = 0;

                //move Lights:
                EngineApp.Game.self.lightEngine.moveLights(new OpenTK.Vector2(_camOffsetX-oldX,_camOffsetY-oldY));
            }
        }
        private void centrize()
        {
            Viewport v = Game.self.activeViewport;
            GameMap m = Game.self.gameManager.Map;
            int oldX = _camOffsetX, oldY = _camOffsetY;
            _camOffsetX = (v.width - m.mapWidth * GameManager.gridSize) / 2;
            _camOffsetY = (v.height - m.mapHeight * GameManager.gridSize) / 2;
            heroLocationBooster = 1;
            //move Lights:
            EngineApp.Game.self.lightEngine.moveLights(new OpenTK.Vector2(_camOffsetX-oldX,_camOffsetY-oldY));
        }
        public void correctForNewLevel()
        {
            centrize();
        }

        internal void resetPos()
        {
            _camOffsetX = 0;
            _camOffsetY = 0;
        }
        public void Move(int x, int y)
        {
            _camOffsetX += x;
            _camOffsetY += y;
        }
        public void SetPos(int x, int y)
        {
            _camOffsetX = x;
            _camOffsetY = y;
        }
    }
}using System;
using System.Collections.Generic;

using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    public class gameplay
    {
        public enum eDifficultyLevel { EASY, NORMAL, HARD, HARDCORE }
        public eDifficultyLevel level { get; set; }
        public int maps { get; set; }
    }
    public class options
    {
        public graphics graphics { get; private set; }
        public sound sound {get; private set;}
        public options()
        {
            graphics = new graphics();
            sound = new sound();
        }
    }
    public class graphics
    {
        /// <summary>
        /// current resolution
        /// </summary>
        public int resIdx;
        /// <summary>
        /// resolution that will be set when user hits "Apply" in menu
        /// </summary>
        public int newResolutionIdx;
        public OpenTK.DisplayResolution resolution;
        /// <summary>
        /// previous used resolution -> for rescaling of objects after new resolution applying
        /// </summary>
        public OpenTK.DisplayResolution oldResolution;
        public bool renderPaths;
    }
    public class sound
    {
        public double sfxVol = 0.8;
        public double musicVol = 1.0;
    }

    class Configuration
    {
        public static string boolToString(bool b)
        {
            if(b)
                return "Tak";
            else
                return "Nie";
        }
        public gameplay gameplay { get; private set; }
        public options options { get; private set; }
        public static void nextDouble(ref double dob)
        {
            dob += 0.05; if (dob > 1.0) dob = 1.0;
        }
        public static void prevDouble(ref double dob)
        {
            dob -= 0.05; if (dob < 0.0) dob = 0.0;
        }
        public Configuration()
        {
            //Load default:
            gameplay = new gameplay();
            gameplay.level = gameplay.eDifficultyLevel.NORMAL;
            gameplay.maps = 40;
            options = new options();
            
            options.graphics.resolution = OpenTK.DisplayDevice.Default.SelectResolution(1280, 800, 32, 0f);
            options.graphics.oldResolution = options.graphics.resolution;
            options.graphics.resIdx = OpenTK.DisplayDevice.Default.AvailableResolutions.IndexOf(options.graphics.resolution);
            options.graphics.newResolutionIdx = options.graphics.resIdx;
            options.graphics.renderPaths = true;
        }
        public void applyResolution()
        {
            options.graphics.oldResolution = options.graphics.resolution;
            options.graphics.resolution = OpenTK.DisplayDevice.Default.AvailableResolutions[options.graphics.newResolutionIdx];
            OpenTK.DisplayDevice.Default.ChangeResolution(options.graphics.resolution);
            options.graphics.resIdx = options.graphics.newResolutionIdx;
            Viewport.scaleLog.WriteLine("");
            Viewport.scaleLog.WriteLine("New resolution: " + options.graphics.resolution.Width.ToString() + "x" + options.graphics.resolution.Height.ToString());
            EngineApp.Game.self.activeViewport.adaptToNewResolution();

        }
        public void restoreResolutionValue()
        {
            options.graphics.newResolutionIdx = options.graphics.resIdx;
        }
        public void getNextResolution()
        {
            int lastResIdx = options.graphics.newResolutionIdx;
            options.graphics.newResolutionIdx = (options.graphics.newResolutionIdx + 1) % OpenTK.DisplayDevice.Default.AvailableResolutions.Count;
            while (OpenTK.DisplayDevice.Default.AvailableResolutions[options.graphics.newResolutionIdx].Width < OpenTK.DisplayDevice.Default.AvailableResolutions[options.graphics.newResolutionIdx].Height
                || OpenTK.DisplayDevice.Default.AvailableResolutions[options.graphics.newResolutionIdx].Width < 1024//never less than 800px in width
                || OpenTK.DisplayDevice.Default.AvailableResolutions[options.graphics.newResolutionIdx].BitsPerPixel != 32//only 32bpp
                || OpenTK.DisplayDevice.Default.AvailableResolutions[options.graphics.newResolutionIdx].RefreshRate > 100f//no more than 100Hz
                //Confront with last resolution:
                || resolutionsAreTheSame(lastResIdx,options.graphics.newResolutionIdx))
                   
                options.graphics.newResolutionIdx = (options.graphics.newResolutionIdx + 1) % OpenTK.DisplayDevice.Default.AvailableResolutions.Count; //only landscape-proportion resolutions count
        }
        public bool resolutionsAreTheSame(int idx1, int idx2)
        {
            return (OpenTK.DisplayDevice.Default.AvailableResolutions[idx1].Width == OpenTK.DisplayDevice.Default.AvailableResolutions[idx2].Width
                   && OpenTK.DisplayDevice.Default.AvailableResolutions[idx1].Height == OpenTK.DisplayDevice.Default.AvailableResolutions[idx2].Height
                   && OpenTK.DisplayDevice.Default.AvailableResolutions[idx1].RefreshRate == OpenTK.DisplayDevice.Default.AvailableResolutions[idx2].RefreshRate
                   && OpenTK.DisplayDevice.Default.AvailableResolutions[idx1].BitsPerPixel == OpenTK.DisplayDevice.Default.AvailableResolutions[idx2].BitsPerPixel
                   );
        }
        public string getResolutionString()
        {
            OpenTK.DisplayResolution hlp = OpenTK.DisplayDevice.Default.AvailableResolutions[options.graphics.newResolutionIdx];
            return hlp.Width + "x" + hlp.Height + "x" + hlp.BitsPerPixel + " " + hlp.RefreshRate + "Hz";
        }
        public string encrypt()
        {
            // those infos are stored in savegame playerData
            // so we simply don't give a fuck
            //Int32 cGameplay = 0;
            //cGameplay = 1 << 30;
            //cGameplay += (int)(gameplay.level);//max is 3 so 16(4bits) should be ok anyway
            //cGameplay += gameplay.maps << 4;
            string buffer = "";// cGameplay.ToString("X");
            const string sep = "x";

            Int32 cOptG = 1 << 31;
            cOptG += options.graphics.resIdx;
            cOptG += ((options.graphics.renderPaths==true)? 1 : 0) << 10;//spare 1024 for resIdx
            buffer += cOptG.ToString("X");
            buffer += sep;

            Int32 cOptS = 0;// 1 << 29;//0x2..
            cOptS += (int)(options.sound.sfxVol/0.05);//max val 20 so 32 (5)shift
            cOptS += (int)(options.sound.musicVol/0.05)<<5;// ----,,----
            buffer += cOptS.ToString("X");
            return buffer;
        }

        internal void decrypt(string conf)
        {
            string hlp = conf.Substring(0,conf.IndexOf("x"));
            int x = Convert.ToInt32(hlp, 16);
            //graphics:
            int resIdx = x & 0x3FF;//1023(1024)
            int renderPaths = (x >> 10) & 1;
            options.graphics.resIdx = resIdx;
            options.graphics.renderPaths = renderPaths == 1;
            //sound:
            hlp = conf.Substring(conf.IndexOf("x") + 1);
            x = Convert.ToInt32(hlp, 16);
            int sfx = x & 0x1F;//5bits
            int music = (x >> 5) & 0x1F;
            options.sound.sfxVol = sfx * 0.05;
            options.sound.musicVol = music * 0.05;
        }
    }
}using System;
using System.Collections.Generic;

using System.Text;
using System.Runtime.Remoting;
using System.Drawing;
using QuickFont;

namespace CookieMonster.CookieMonster_Objects
{
    enum DebugLVL
    {
        info,fault,warn,error
    }
    class DebugMsg
    {
        public static Debug debugSys;
        string _msg = ""; public string msg { get { return _msg; } }
        DebugLVL _lvl; public DebugLVL lvl { get { return _lvl; } }
        object objRef; public object referencedObj { get { return objRef; } }//only with static debug msg's
        string fieldName;

        /// <summary>
        /// Will be displayed as info
        /// </summary>
        /// <param name="msg"></param>
        /// <param name="l"></param>
        unsafe public DebugMsg(string msg) : this(msg,DebugLVL.info){}
        unsafe public DebugMsg(object watchedObj, string fname) : this(watchedObj, fname,DebugLVL.info) { }
        /// <summary>
        /// Static message constructor
        /// </summary>
        /// <param name="msg">prefix of watched field value</param>
        /// <param name="watchedField">pointer to field which value has to be displayed</param>
        /// <param name="l">debug msg level of priority</param>
        unsafe public DebugMsg(string msg, DebugLVL l)
        {
            System.DateTime now = System.DateTime.Now;
            _msg = "["+(now.Minute%10).ToString() +":"+ (now.Second % 60).ToString() + "]" + msg;
                _lvl = l;
            if(debugSys!=null)
                debugSys.addDebugMsg(this);


            //write to debugfile:
            Debug.debugLog.WriteLine(_msg);
        }
        unsafe public DebugMsg(object watchedObj,string fname, DebugLVL l)
        {
                _lvl = l;
                objRef = watchedObj;
                fieldName = fname;
                if (debugSys != null)
                debugSys.addDebugMsg(this);
        }        
                
        /// <summary>
        /// Build a debug message to be displayed
        /// </summary>
        /// <returns>string containing msg to display</returns>
        public string getMsg()
        {
            unsafe
            {
                if (objRef != null)
                {
                _msg = "";
                Type t = objRef.GetType();
                _msg += t.Name+"."+fieldName+"=";
                var pp = t.GetProperty(fieldName);
                var fi = t.GetField(fieldName); 
                if (pp == null)
                {
                    pp = t.BaseType.GetProperty(fieldName);
                    if (pp == null)
                    {
                        
                        if (fi != null) fi.GetValue(objRef);
                    }
                        
                }
                    if(pp!=null)
                        _msg += pp.GetValue(objRef, null);
                    else
                        _msg += fi.GetValue(objRef);
                }
            }
            return _msg;
        }
    }
    class Debug
    {
        //logfile:
        static public System.IO.StreamWriter debugLog = new System.IO.StreamWriter("debugLog.txt", false);
        //consts
        static QFont debug_font = TextManager.newQFont("MonoSpatial.ttf", 12,true);
        static Point dynamicStart = new Point(50, 700);
        const int dynamicMsgMax = 10;
        const QFontAlignment dynamicAlign = QFontAlignment.Left;
        static Point staticStart = new Point(1200, 700);
        const int staticMsgMax = 10;
        const QFontAlignment staticAlign = QFontAlignment.Right;
        const int debugMsgLineHeight = 25;//px
        int dynamicMsgDuration = 500;
        List<DebugMsg> dynamicMessages;
        List<DebugMsg> dynamicMessagesQuery;
        Timer dynMsgRemainingTime;

        List<DebugMsg> staticMessages;
        Timer staticRefreshTimer;//too smooth means no ability to read
        const int staticRefreshRate = 100;

        //reference to textManager
        TextManager txtMgr;
        public Debug()
        {
            DebugMsg.debugSys = this;//DebugMsg class need reference to current Debug instance
            
            dynamicMessages = new List<DebugMsg>();
            dynamicMessagesQuery = new List<DebugMsg>();
            staticMessages = new List<DebugMsg>();
            staticRefreshTimer = new Timer(Timer.eUnits.MSEC, staticRefreshRate, 0, true, false);
            // them simply can be generated onrun of Render method
            //dynamicTxts = new List<Text>();
            //staticTxts = new List<Text>();
            txtMgr = EngineApp.Game.self.textMenager;
        }
        public void addDebugMsg(DebugMsg d)
        {
            if (d.referencedObj == null)//it's dynamic message
            {
                if ((dynamicMessagesQuery.Count > 0) || (dynamicMessages.Count >= dynamicMsgMax))
                    dynamicMessagesQuery.Add(d);//adds msg to query
                else
                    dynamicMessages.Add(d);
                //start timer:
                if (dynMsgRemainingTime != null) return;
                dynMsgRemainingTime = new Timer(Timer.eUnits.MSEC, dynamicMsgDuration, 0, true, false);
                dynMsgRemainingTime.start();

            }
            else
            {

                staticMessages.Add(d);
                if (staticMessages.Count >= staticMsgMax)
                {
                    staticMessages.RemoveAt(0);//remove first message, just proceed by one ;)
                }
            }
        }
        public void Update()
        {
            // dynamic: if timer is disabled it means it's time to go 
            // further, remove oldes msg and add new from query
            if ((dynMsgRemainingTime!=null)&&(dynMsgRemainingTime.enabled == false))
            {
                dynMsgRemainingTime.Dispose();
                dynamicMsgDuration = (dynamicMsgMax - dynamicMessages.Count) * 250 + dynamicMsgDuration - (dynamicMessagesQuery.Count * 250);
                dynMsgRemainingTime = new Timer(Timer.eUnits.MSEC, dynamicMsgDuration);
                dynMsgRemainingTime.start();
                if (dynamicMessages.Count > 0)
                {
                    dynamicMessages.RemoveAt(0);
                    if(dynamicMessagesQuery.Count>0)
                    {
                        dynamicMessages.Add(dynamicMessagesQuery[0]);
                        dynamicMessagesQuery.RemoveAt(0);
                    }
                }   
            }
            //static: do nothing, messages are generated in render process
        }
        public void Render()
        {
            //dynamic:
            for (int i = 0; i < dynamicMessages.Count; i++)
                txtMgr.produceText(debug_font, dynamicMessages[i].getMsg(), dynamicStart.X, dynamicStart.Y - (debugMsgLineHeight * i), dynamicAlign).Print();

            //static:    
            if (staticRefreshTimer.enabled)//print last generated msg:
                for (int i = 0; i < staticMessages.Count; i++)
                    txtMgr.produceText(debug_font, staticMessages[i].msg, staticStart.X, staticStart.Y - (debugMsgLineHeight * i), staticAlign).Print();

            else
            {
                staticRefreshTimer.start();//refresh msg value:
                for (int i = 0; i < staticMessages.Count; i++)
                    txtMgr.produceText(debug_font, staticMessages[i].getMsg(), staticStart.X, staticStart.Y - (debugMsgLineHeight * i), staticAlign).Print();
            }
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;
using System.Diagnostics;

namespace CookieMonster.CookieMonster_Objects
{
    class Bomb : MOB
    {
        static Obj bombVisual = new Obj("../data/textures/game/sob/Bomb_Explosion_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
        Stopwatch tickTock;
        const int frameMSTime = 100;
        Timer lastFrameTimer;

        public Bomb(int x,int y) : base(x,y,0)
        {
            GameMan.addBomb(this);
            base.setStateVisual(bombVisual, "DEFAULT");
            base.currentVisual.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
            base.currentVisual.x = x;
            base.currentVisual.y = y;

            tickTock = new Stopwatch();
            tickTock.Start();
            currentVisual.setTexAniControlledExternal();

            Sound bomb = new Sound(Sound.eSndType.SFX, "../data/Sounds/BOMB.ogg", false, false);
            bomb.Play();
        }
        public void Update()
        {
            int frame = (int)(tickTock.ElapsedMilliseconds / frameMSTime);
            currentVisual.setTexAniFrame(frame);
            if ((frame == 51)&&(lastFrameTimer==null))
            {
                lastFrameTimer = new Timer(Timer.eUnits.MSEC, 300, 0);
                lastFrameTimer.start();
            }
            if(lastFrameTimer!=null)
                if (lastFrameTimer.enabled == false)
                {
                    lastFrameTimer.Dispose();
                    Explode();
                }
            
        }
        public void Render()
        {
            base.Render();
        }
        public void Explode()
        { //TODO: Implement rest (destructing near objects)
            GameMan.bombExplode(this);
            GameMan.removeBomb(this);
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    // static helper class for generating Cliff visuals
    // Whole class is based and very-alike class Paths
    class Cliffs
    {
        static Obj[] StraightCliff = new Obj[4];
        static Obj[] CornerCliff   = new Obj[4];
        static void Initialize()
        {
            //One Way:
            /*L*/
            StraightCliff[0] = new Obj("../data/textures/GAME/SOB/CLIFF_STRAIGHT_V0.dds", 0, 0, Obj.align.CENTER_BOTH);
            /*U*/
            StraightCliff[1] = new Obj("../data/Textures/GAME/SOB/CLIFF_STRAIGHT_V0.dds", 0, 0, Obj.align.CENTER_BOTH);
            StraightCliff[1].Rotate(90f);

            /*R*/
            StraightCliff[2] = new Obj("../data/Textures/GAME/SOB/CLIFF_STRAIGHT_V0.dds", 0, 0, Obj.align.CENTER_BOTH);
            StraightCliff[2].Rotate(180f);

            /*D*/
            StraightCliff[3] = new Obj("../data/Textures/GAME/SOB/CLIFF_STRAIGHT_V0.dds", 0, 0, Obj.align.CENTER_BOTH);
            StraightCliff[3].Rotate(270f);

            //CORNERS
            /*L*/
            CornerCliff[0] = new Obj("../data/Textures/GAME/SOB/CLIFF_CORNER_V0.dds", 0, 0, Obj.align.CENTER_BOTH);
            /*U*/
            CornerCliff[1] = new Obj("../data/Textures/GAME/SOB/CLIFF_CORNER_V0.dds", 0, 0, Obj.align.CENTER_BOTH);
            CornerCliff[1].Rotate(90f);

            /*R*/
            CornerCliff[2] = new Obj("../data/Textures/GAME/SOB/CLIFF_CORNER_V0.dds", 0, 0, Obj.align.CENTER_BOTH);
            CornerCliff[2].Rotate(180f);

            /*D*/
            CornerCliff[3] = new Obj("../data/Textures/GAME/SOB/CLIFF_CORNER_V0.dds", 0, 0, Obj.align.CENTER_BOTH);
            CornerCliff[3].Rotate(270f);
        }

        static public Obj getCliffVisual(neighborReport rep)
        {
            if (Cliffs.CornerCliff[0] == null) Cliffs.Initialize();
            Obj o = null;
            neighborReport dRep = new neighborReport(rep.x, rep.y,GameMap.objType.DARKNESS);

            // straight = always 3 neighbours marked as cliff (only in proper clifs with size min. 2 pixels
            int cliffsOnSides = 4 - rep.ways;//rep.ways keep non-cliffs neighbours
            cliffsOnSides += 4 - dRep.ways;
            if (cliffsOnSides == 3)//straight:
            {
                if ((rep.U == true)&&(dRep.U == true))//horizontonal
                {
                    o = StraightCliff[0];
                }
                else if ((rep.R == true)&&(dRep.R == true))
                {
                    o = StraightCliff[1];
                }
                else if ((rep.D == true)&&(dRep.D == true))
                {
                    o = StraightCliff[2];
                }
                else if ((rep.L == true)&&(dRep.L == true))//veritical
                {
                    o = StraightCliff[3];
                }
            }
            else if (cliffsOnSides != 1)//one cliff on sides means something went wrong
            {//it's got to be corner cliff
                int x = rep.x,y= rep.y;
                if (((neighborReport.map.getObjTypeFromPixel(x - 1, y) & GameMap.objType.CLIFF) == GameMap.objType.CLIFF)
                && ((neighborReport.map.getObjTypeFromPixel(x, y + 1) & GameMap.objType.CLIFF) == GameMap.objType.CLIFF))
                    o = CornerCliff[0];
                else if (((neighborReport.map.getObjTypeFromPixel(x, y - 1) & GameMap.objType.CLIFF) == GameMap.objType.CLIFF)
                     && ((neighborReport.map.getObjTypeFromPixel(x - 1, y) & GameMap.objType.CLIFF) == GameMap.objType.CLIFF))
                    o = CornerCliff[1];
                else if (((neighborReport.map.getObjTypeFromPixel(x, y - 1) & GameMap.objType.CLIFF) == GameMap.objType.CLIFF)
                     && ((neighborReport.map.getObjTypeFromPixel(x + 1, y) & GameMap.objType.CLIFF) == GameMap.objType.CLIFF))
                    o = CornerCliff[2];
                else if (((neighborReport.map.getObjTypeFromPixel(x, y + 1) & GameMap.objType.CLIFF) == GameMap.objType.CLIFF)
                     && ((neighborReport.map.getObjTypeFromPixel(x + 1, y) & GameMap.objType.CLIFF) == GameMap.objType.CLIFF))
                    o = CornerCliff[3];
            }
            return o;
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;
using System.Drawing;
using EngineApp;

namespace CookieMonster.CookieMonster_Objects
{
    //arguments of dynamic collision event:
    class collDynEventArgs : EventArgs
    {
        public Enemy enemy { get; private set; }
        private PowerUp _powerup; public PowerUp cdPowerUP { get { return _powerup; } }
        public Player player { get; private set; }
        public collDynEventArgs(Enemy m,PowerUp p,Player pc)
        { 
            this.enemy = m;
            this._powerup = p;
            this.player = pc;
        }
    }
    class CollisionReport
    {
        static public CollisionSystem collSystem;
        public CollisionReport(MOB m)
        {
            _collisionStatic = false;
            srcMob = m;
            collSystem.AddReport(this);
            this.lastType = GameMap.objType.OTHER;
        }
        public CollisionReport(Projectile p)
        {
            _collisionStatic = false;
            sourceProjectile = p;
            collSystem.AddReport(this);
            this.lastType = GameMap.objType.OTHER;
        }
        MOB srcMob; public MOB sourceMob { get { return srcMob; } }
        public Projectile sourceProjectile { get; private set; }
        bool _collisionStatic; public bool collisionStatic { get { return _collisionStatic; } }
        public bool collisionDynamicDisabled{get; private set;}
        public GameMap.objType lastType;

        public void setStaticCollision(bool v)
        {
            _collisionStatic = v;
        }
        //
        // dynamic collision (handled with event:)
        public delegate void CDEvtHandler(MOB src, collDynEventArgs fe);

        // dynamic collision event:
        public event CDEvtHandler cdEvent;

        public void triggerCDEvent(MOB src, collDynEventArgs fe)
        {
            if(cdEvent!=null)//only when mob has some thing of reaction methood to dynamic collision
                cdEvent(src,fe);
        }
        public void disableDynamicCollision()
        {
            collisionDynamicDisabled = true;
        }
        public int gridX { get { if (srcMob != null) { return srcMob.gridX; } else if (sourceProjectile != null) { return sourceProjectile.gridX; } else return 0; } }
        public int gridY { get { if (srcMob != null) { return srcMob.gridY; } else if (sourceProjectile != null) { return sourceProjectile.gridY; } else return 0; } }
        public int nextGridX { get { if (srcMob != null) { return srcMob.nextGridX; } else if (sourceProjectile != null) { return sourceProjectile.nextGridX; } else return 0; } }
        public int nextGridY { get { if (srcMob != null) { return srcMob.nextGridY; } else if (sourceProjectile != null) { return sourceProjectile.nextGridY; } else return 0; } }
        public int pX { get { if (srcMob != null) { return srcMob.pX; } else if (sourceProjectile != null) { return sourceProjectile.pX; } else return 0; } }
        public int pY { get { if (srcMob != null) { return srcMob.pY; } else if (sourceProjectile != null) { return sourceProjectile.pY; } else return 0; } }
        public Rectangle boundingBox { 
        get { 
            if (srcMob != null) { return srcMob.boundingBox; } 
            else if (sourceProjectile != null) {
                return sourceProjectile.boundingBox;
            } 
            else return new Rectangle(); 
            } 
        }

        public void Update()
        {
            GameManager gm = Game.self.gameManager;
            //Static collison:
            int xx = gridX;
            int yy = gridY;
            int px = nextGridX;
            int py = nextGridY;
            lastType = gm.Map.getObjTypeFromPixel(px, py);
            /*Obj gridPos = new Obj("../data/Textures/HLP_GRID.dds", px * 48, py * 48, Obj.align.LEFT);
            gridPos.setRenderOnce();
            gridPos.setCurrentTexAlpha(150);
            Obj gridPos2 = new Obj("../data/Textures/HLP_GRID2.dds", xx * 48, yy * 48, Obj.align.LEFT);
            gridPos2.setRenderOnce();
            gridPos2.setCurrentTexAlpha(100);
            */
            if ((lastType & GameMap.objType.COLLIDEABLE) == GameMap.objType.COLLIDEABLE)
            {
                setStaticCollision(true);
            }
            else
            {
                if ((sourceMob != null) && ((lastType & GameMap.objType.PORTAL) == GameMap.objType.PORTAL))
                {
                    const int tolerance = 12;
                    int grid = GameManager.gridSize;
                    GameMap map = gm.Map;
                    Portal p = map.getPortalByColor(gm.Map.getPXColor(px, py));
                    int posx = pX, posy = pY;


                    Point p1grid;
                    p1grid = new Point((p.portalObj1.x + p.portalObj1.width / 2) / grid,
                                             (p.portalObj1.y + p.portalObj1.height / 2) / grid);

                    Point p2grid;
                    p2grid = new Point((p.portalObj2.x + p.portalObj2.width / 2) / grid,
                                             (p.portalObj2.y + p.portalObj2.height / 2) / grid);

                    if (((p2grid.X == xx) || (p2grid.X == xx + 1)) && ((p2grid.Y == yy) || (p2grid.Y == yy + 1)))
                    {//mob is on portal 2:
                        if (((posx + tolerance >= xx * grid) && (posx - tolerance <= xx * grid))
                        && ((posy + tolerance >= yy * grid) && (posy - tolerance <= yy * grid)))
                        {// let's teleport!
                            sourceMob.Teleport(p.portalObj1);
                        }
                    }
                    else if (((p1grid.X == xx) || (p1grid.X == xx + 1)) && ((p1grid.Y == yy) || (p1grid.Y == yy + 1)))
                    {//mob is on portal 1
                        if (((posx + tolerance >= xx * grid) && (posx - tolerance <= xx * grid))
                        && ((posy + tolerance >= yy * grid) && (posy - tolerance <= yy * grid)))
                        {// let's teleport!
                            sourceMob.Teleport(p.portalObj2);
                        }
                    }
                }
                setStaticCollision(false);
            }

            // dynamic collision:
            if (!collisionDynamicDisabled)
            {
                //(PowerUPs)
                if (sourceMob != null)
                {
                    int max = gm.sortedPowerUpList.Count;
                    int min = 0;
                    int step = (max - min) / 2;
                    while (min < max)
                    {
                        if (min + step >= gm.sortedPowerUpList.Count)
                        {
                            max = min; break;
                        }//TODO: sometimes min+step gets > arraySize (min=count-1;step=1)
                        else if (gm.sortedPowerUpList[min + step].pY < pY)
                        {
                            min += step;
                        }
                        else
                        {
                            break;
                            max -= step;
                        }
                        step = (max - min) / 2; if (step < 1) step = 1;
                    }
                    if (min > 0) min--;
                    for (int j = min; (j < gm.sortedPowerUpList.Count); j++)
                    {
                        if (gm.sortedPowerUpList[j].gridY - 1 > gridY) break; //different y grid-break loop
                        if (gm.sortedPowerUpList[j].boundingBox.IntersectsWith(boundingBox))
                        {
                            triggerCDEvent(sourceMob, new collDynEventArgs(null, gm.sortedPowerUpList[j], null));
                        }
                    }
                }
                //dynamic Collision Enemies:
                for (int j = 0; j < gm.enemiesList.Count; j++)
                {
                    if (gm.enemiesList[j].boundingBox.IntersectsWith(boundingBox))
                    {
                        if (sourceProjectile != null)
                        {
                            triggerCDEvent(sourceProjectile, new collDynEventArgs(gm.enemiesList[j], null, null));
                        }
                        else if (sourceMob != null)
                        {
                            triggerCDEvent(sourceMob, new collDynEventArgs(gm.enemiesList[j], null, null));
                        }
                    }
                }
                //dynamic Collision with player:
                if (sourceMob == null || sourceMob.mobType != MOB.eMOBType.PLAYER)
                {
                    if (gm.PC.boundingBox.IntersectsWith(boundingBox))
                    {
                        if (sourceProjectile != null)
                        {
                            triggerCDEvent(sourceProjectile, new collDynEventArgs(null, null, gm.PC));
                        }
                        else if (sourceMob != null)
                        {
                            triggerCDEvent(sourceMob, new collDynEventArgs(null, null, gm.PC));
                        }
                    }
                }
            }

        }
       
    }
    class CollisionSystem
    {
        GameManager gm;
        List<CollisionReport> reportsList;

        /// <summary>
        /// Updates all CollisionReports on list
        /// </summary>
        public void Update()
        {
            for (int i = 0; i < reportsList.Count; i++)//go through list of all objects with collision report
            {
                reportsList[i].Update();
            }
        }
        public CollisionSystem(GameManager th)
        {
            reportsList = new List<CollisionReport>();
            gm = th;
        }
        public void AddReport(CollisionReport r)
        {
            reportsList.Add(r);
        }
        public void RemoveReport(Projectile p)
        {
            for(int i=0;i<reportsList.Count;i++)
                if (reportsList[i].sourceProjectile == p)
                {
                    reportsList.RemoveAt(i);
                    break;
                }
        }
        public void RemoveReport(MOB m)
        {
            for (int i = 0; i < reportsList.Count; i++)
                if (reportsList[i].sourceMob == m)
                {
                    reportsList.RemoveAt(i);
                    break;
                }
        }
    }
    
}
using System;
using System.Collections.Generic;

using System.Text;
using System.Drawing;

namespace CookieMonster.CookieMonster_Objects
{
    class Enemy : MOB
    {
        //Right now variations only work and are needed with default kind of enemy
        static int visualVariationizer = 0;
        private int visualsCount;
        private String texNameBase;
        //NOTE: Even if WIZARD is threaten as child class of Enemy it's type
        // still need to exist in here cause it needs to set proper visuals, etc.
        public enum enemyType { NORMAL, ASSASSIN, THIEF, SHOOPDAWOOP, WIZARD }
        public enum eEnemyState
        {
            NORMAL,     // chasing player
            FLEE,       // player eaten powerPill run for your life!
            WOUNDED,    // just eaten by hero runing quickly to the startpoint
            UNCONSCIOUS // x,X i need some rest, 10s should be ok ;)
        }
        private Timer woundedTimer;
        public enemyType type { get; private set; }
        private eEnemyState _enemyState;
        public eEnemyState enemyState
        {
            get { return _enemyState; }
            set
            {
                _enemyState = value;
            }
        }
        private eEnemyState oldstate;
        private double baseSpeed;

        Waypoint startpoint; // when enemy was "eated" by player enemy will set route to startpoint
        ShortestWay chaseRoute; // shortest route from currentWP to player.currentWP
        public string routeList { get { if (chaseRoute != null) return chaseRoute.ToString(); else return "NULL"; } }

        // for checking if enemy stucked, SAD but needed :( ...yeah, I suck ;(
        private Timer unstuckTimer = new Timer(Timer.eUnits.MSEC, 500, 0, true, false);
        private Point unstuckLastPt;
        public Enemy(enemyType typ, int posx, int posy, double spd)
            : base(posx, posy, spd)
        {
            type = typ;
            baseSpeed = spd;
            oldstate = _enemyState = eEnemyState.NORMAL;
            mobType = eMOBType.ENEMY;
            base.myCollision = new CollisionReport(this);
            if (typ != enemyType.THIEF) //thief needs collision for stealing cookies
                myCollision.disableDynamicCollision(); // disable collisions with cookies & mobs
            GameMan.enemiesList.Add(this);
            setVisuals();
            woundedTimer = new Timer(Timer.eUnits.MSEC, 15 * 1000, 0, true, false);

            //new DebugMsg(this, "enemyState", DebugLVL.info);
            //new DebugMsg(this, "lastWPid");
            //new DebugMsg(this, "nxtWPid"); 
            //new DebugMsg(this, "routeList", DebugLVL.info);
            mobType = eMOBType.ENEMY;
            unstuckTimer.start();
        }

        /// <summary>
        /// function sets or updates proper visuals for enemy type 
        /// (default type has some variations, see visualVariationizer)
        /// funcion updates visuals when enemy.eEnemyState was changed
        /// </summary>
        public virtual void setVisuals()
        {
            Obj vis; int widthMul = 1;
            if (texNameBase == null)
            {
                visualsCount = 3;
                texNameBase = "ghost_" + visualVariationizer.ToString();
                visualVariationizer = (visualVariationizer + 1) % visualsCount;

                // frozen:
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_frozen_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                setStateVisual(vis, "FROZEN");
            }
            else
            {//so we already have some visualDefault grab pos:
                if (mobMirrored == true)
                {
                    widthMul = -1;
                }
            }
            if (enemyState == eEnemyState.FLEE)
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_scared_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            else if (enemyState == eEnemyState.WOUNDED)
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_wounded_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            else
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_move_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            vis.width *= widthMul;
            setStateVisual(vis, "DEFAULT");
            //todo: idle, etc.
        }
        public virtual void Update()
        {
            // initialize startpoint:
            if (startpoint == null) startpoint = lastWP;

            updateState();

            base.Update();
            if (chaseRoute == null) recalculateShortestWay();
            Waypoint wp;
            wp = GameMan.Map.wayNetwork.getWPAt((uint)gridX, (uint)gridY);

            if ((enemyState == eEnemyState.FLEE) && isOnGrid && wp != null)
            {
                dirBuffer = direction = runawayDirection(wp);
            }
            else if ((enemyState == eEnemyState.WOUNDED) && wp != null && wp != startpoint)
            {
                if (isOnGrid && chaseRoute != null && (chaseRoute.route.dirList.Count != 0))
                    dirBuffer = direction = chaseRoute.Pop();
                if (chaseRoute == null || (chaseRoute.route.dirList.Count == 0))
                {
                    setRouteToStartpoint();
                }
            }
            else if (wp != null)
            {
                if (isOnFirstWPFromStack(wp))// || nextDirectionOnStackIsOpposite())
                {
                    if (chaseRoute.route.dirList.Count > 0)
                    {
                        dirBuffer = chaseRoute.Pop();
                    }
                    //new DebugMsg("POPed dir from chaseRoute!");
                }
            }

            //mob needs unstuck?
            if (unstuckTimer.enabled == false)
            {
                if (pX == unstuckLastPt.X && pY == unstuckLastPt.Y && state != eState.FROZEN && enemyState == eEnemyState.NORMAL)
                {
                    new DebugMsg("unstuck enemy!");
                    enemyState = eEnemyState.FLEE;
                }
                unstuckTimer.start();
                unstuckLastPt.X = pX; unstuckLastPt.Y = pY;
            }
            oldstate = enemyState;
        }

        public void Render()
        {
            base.Render();
        }
        private eDir runawayDirection(Waypoint curWP)
        {
            ShortestWay[] s = new ShortestWay[4];
            eDir[] sDir = new eDir[4];
            int i = 0;
            if (curWP.downWP != null)
            {
                sDir[i] = eDir.D;
                if (GameMan.PC.lastWPid != -1)
                    s[i] = ShortestWaysTable.getCopy(curWP.downWP._id, GameMan.PC.lastWPid);
                else if (GameMan.PC.nxtWPid != -1)
                    s[i] = ShortestWaysTable.getCopy(curWP.downWP._id, GameMan.PC.nxtWPid);
                if (s[i] != null) { s[i] = s[i].Copy(); i++; }
            }
            if (curWP.leftWP != null)
            {
                sDir[i] = eDir.L;
                if (GameMan.PC.lastWPid != -1)
                    s[i] = ShortestWaysTable.getCopy(curWP.leftWP._id, GameMan.PC.lastWPid);
                else if (GameMan.PC.nxtWPid != -1)
                    s[i] = ShortestWaysTable.getCopy(curWP.leftWP._id, GameMan.PC.nxtWPid);
                if (s[i] != null) { s[i] = s[i].Copy(); i++; }
            }
            if (curWP.rightWP != null)
            {
                sDir[i] = eDir.R; //TODO: idx out of range (lastWPid)
                if (GameMan.PC.lastWPid != -1)
                    s[i] = ShortestWaysTable.getCopy(curWP.rightWP._id, GameMan.PC.lastWPid);
                else if (GameMan.PC.nxtWPid != -1)
                    s[i] = ShortestWaysTable.getCopy(curWP.rightWP._id, GameMan.PC.nxtWPid);

                if (s[i] != null) { s[i] = s[i].Copy(); i++; }
            }
            if (curWP.upWP != null)
            {
                sDir[i] = eDir.U;
                if (GameMan.PC.lastWPid != -1)
                    s[i] = ShortestWaysTable.getCopy(curWP.upWP._id, GameMan.PC.lastWPid);
                else if (GameMan.PC.nxtWPid != -1)
                    s[i] = ShortestWaysTable.getCopy(curWP.upWP._id, GameMan.PC.nxtWPid);
                if (s[i] != null) { s[i] = s[i].Copy(); i++; }
            }
            int biggestWeight = 0; int biggestWeight_i = 0;
            for (i--; i >= 0; i--)
            {
                if (s[i].weight > biggestWeight)
                    biggestWeight_i = i;
            }
            return sDir[biggestWeight_i];
        }
        private bool wasFrozen;
        private void updateState()
        {
            // enemy frozen? -> set FLEE visuals:
            if ((isFrozen) && (enemyState == eEnemyState.NORMAL))
            {
                wasFrozen = true;
                enemyState = eEnemyState.FLEE;
            }
            if ((wasFrozen) && (!isFrozen) && (enemyState == eEnemyState.FLEE))
            {
                wasFrozen = false;
                if (GameMan.powerPillActive())
                    enemyState = eEnemyState.FLEE;
                else
                    enemyState = eEnemyState.NORMAL;
            }
            // new enemyState aplied
            if (enemyState != oldstate)
            {
                if (enemyState == eEnemyState.NORMAL)
                {
                    setVisuals();
                    speed = baseSpeed;
                    recalculateShortestWay();
                }
                else if (enemyState == eEnemyState.FLEE)
                {
                    setVisuals();//new visual need to be set
                    speed = GameManager.gridSize / 3;
                    direction = dirBuffer = inverseDirection(direction);//first, we need to comeback to lastWP
                }
                else if (enemyState == eEnemyState.WOUNDED)
                {
                    doActionsOnWounded();
                    setVisuals();//new visual need to be set
                    speed = GameManager.gridSize * 3;
                    setRouteToStartpoint();
                    woundedTimer.restart();
                }
                else if (enemyState == eEnemyState.UNCONSCIOUS)
                {
                    speed = 0;
                }
            }
            else if ((enemyState == eEnemyState.WOUNDED) && (woundedTimer.enabled == false))
            {
                //set normal enemyState
                enemyState = eEnemyState.NORMAL;
                setVisuals();
                speed = baseSpeed;
            }

        }

        private void doActionsOnWounded()
        {
            if (type == enemyType.THIEF)
            {
                ((Thief)this).giveBackCookies();
            }
        }


        private void setRouteToStartpoint()
        {

            if (nextWP != null)
                chaseRoute = ShortestWaysTable.getCopy(nextWP._id, startpoint._id);
            else if (lastWP != null)
            {
                chaseRoute = ShortestWaysTable.getCopy(lastWP._id, startpoint._id);
                Waypoint wp;
                wp = GameMan.Map.wayNetwork.getWPAt((uint)gridX, (uint)gridY);
                if (((wp != null) && (chaseRoute != null) && (chaseRoute.wpList.Count > 0) && (wp._id != chaseRoute.wpList[0]._id))
                        || wp == null)
                {
                    direction = inverseDirection(direction);//first, we need to comeback to lastWP
                    dirBuffer = direction;
                }
            }
        }

        private bool isOnFirstWPFromStack(Waypoint wp)
        {
            return ((wp != null) && isOnGrid && (chaseRoute != null) && (wp == chaseRoute.wpList[0]));
        }
        private bool nextDirectionOnStackIsOpposite()
        {
            if (isOnGrid) return false;
            if (chaseRoute == null) return false;
            else if (chaseRoute.route == null) return false;
            else if (chaseRoute.route.dirList.Count > 0)
            {
                // I LOL'D ;D
                return (((direction == eDir.R) && (chaseRoute.route.dirList[0] == eDir.L))
                || ((direction == eDir.L) && (chaseRoute.route.dirList[0] == eDir.R))
                || ((direction == eDir.D) && (chaseRoute.route.dirList[0] == eDir.U))
                || ((direction == eDir.U) && (chaseRoute.route.dirList[0] == eDir.D)));
            }
            else return false;
        }
        public void recalculateShortestWay()
        {
            if (!tryToSetRoute(nextWP))
                if (!tryToSetRoute(lastWP))
                    if (!tryToSetRoute(currentWP))
                        new DebugMsg("Updating chase Route went wrong!");

        }

        private bool tryToSetRoute(Waypoint WP)
        {
            if (WP != null)
            {
                ShortestWay s;
                int nxtWPRouteWeight = int.MaxValue, lastWPRouteWeight = int.MaxValue;
                if ((GameMan.PC.nextWP != null) && (WP._id != GameMan.PC.nextWP._id))
                { // at first enemy will try to go to next player WP
                    s = ShortestWaysTable.getCopy(WP._id, GameMan.PC.nextWP._id);
                    if (s != null)
                    {
                        chaseRoute = s;
                        //new DebugMsg("Enemy has new chase route (" + WP._id + "->" + GameMan.PC.nextWP._id + ")");
                        nxtWPRouteWeight = (int)s.weight;
                        return true;
                    }
                }
                else if ((GameMan.PC.lastWP != null) && (WP._id != GameMan.PC.lastWP._id))
                { //if there is no next WP at last try to go to the last hero WP
                    s = ShortestWaysTable.getCopy(WP._id, GameMan.PC.lastWP._id);
                    if (s != null)
                    {
                        lastWPRouteWeight = (int)s.weight;
                        if (lastWPRouteWeight < nxtWPRouteWeight)
                        {
                            chaseRoute = s;
                            //new DebugMsg("Enemy has new chase route (" + WP._id + "->" + GameMan.PC.lastWP._id + ")");
                        }
                        return true;
                    }
                }
                else
                    return false;
            }
            return false;
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    class enemyRanged : Enemy
    {
        public enemyRanged(Enemy.enemyType et, int posx, int posy, double spd)
            : base(et, posx, posy, spd)
        {

        }

        protected bool hasHeroInLineOfSight()
        {
            if (gridY == GameMan.PC.gridY)
            { // in line horizontaly (left right)
                if (direction == eDir.L && gridX >= GameMan.PC.gridX)
                {   // hero is in front of wizard, but we need to check if there is no obstacles between them.
                    for (int i = gridX - 1; i > GameMan.PC.gridX; i--)
                    {

                        if (((GameMan.Map.getObjTypeFromPixel(i, gridY) & GameMap.objType.COLLIDEABLE) == GameMap.objType.COLLIDEABLE))
                            return false; // obstacle on way, can't see player
                    }
                    return true;
                }
                else if (direction == eDir.R && gridX <= GameMan.PC.gridX)
                {
                    for (int i = gridX + 1; i < GameMan.PC.gridX; i++)
                    {
                        if (((GameMan.Map.getObjTypeFromPixel(i, gridY) & GameMap.objType.COLLIDEABLE) == GameMap.objType.COLLIDEABLE))
                            return false; // obstacle on way, can't see player
                    }
                    return true;
                }
            }
            else if (gridX == GameMan.PC.gridX)
            {// in line verticaly
                // in line horizontaly (left right)
                if (direction == eDir.U && gridY >= GameMan.PC.gridY)
                {   // hero is in front of wizard, but we need to check if there is no obstacles between them.
                    for (int i = gridY - 1; i > GameMan.PC.gridY; i--)
                    {
                        if ((GameMan.Map.getObjTypeFromPixel(gridX, i) & GameMap.objType.COLLIDEABLE) == GameMap.objType.COLLIDEABLE)
                            return false; // obstacle on way, can't see player
                    }
                    return true;
                }
                else if (direction == eDir.D && gridY <= GameMan.PC.gridY)
                {
                    for (int i = gridY + 1; i < GameMan.PC.gridX; i++)
                    {
                        if ((GameMan.Map.getObjTypeFromPixel(gridX, i) & GameMap.objType.COLLIDEABLE) == GameMap.objType.COLLIDEABLE)
                            return false; // obstacle on way, can't see player
                    }
                    return true;
                }

            }
            return false;
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    class Lazer : enemyRanged
    {
        private bool charginMyLazor,firinMyLazor;
        private Timer lazorCooldown = new Timer(Timer.eUnits.MSEC, 10 * 1000, 0, true, false);
        private Timer lazorHold = new Timer(Timer.eUnits.MSEC, 3 * 1000 + 400, 0, true, false);
        private Sound chargingSFX;
        private Projectile myLazor;
        public Lazer(int posx, int posy, double spd)
            : base(Enemy.enemyType.SHOOPDAWOOP, posx, posy, spd)
        {

        }
        
        public override void setVisuals()
        {
            Obj vis; int widthMul = 1;
            string texNameBase = "LAZER_0";
            if (currentVisual == null)
            {
                // attack:
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_attack_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                vis.width *= widthMul;
                vis.setTexAniFPS(12);
                vis.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
                setStateVisual(vis, "ATTACK");
                // frozen:
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_frozen_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                setStateVisual(vis, "FROZEN");
            }
            else
            {
                if (mobMirrored == true)
                {
                    widthMul = -1;
                }
            }
            // default:
            if (enemyState == eEnemyState.FLEE)
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_scared_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            else if (enemyState == eEnemyState.WOUNDED)
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_wounded_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            else/*enemy state DEFAULT/NORMAL*/
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_move_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            //Finnaly, set those visuals:
            vis.width *= widthMul;
            vis.setTexAniFPS(20);
            setStateVisual(vis, "DEFAULT");
        }

        public override void Update()
        {
            //BUGFIX: when wizard was casting spell when
            //suddenly changed state to wounded/flee => change state from attack then
            if (charginMyLazor && enemyState != eEnemyState.NORMAL)
            {
                stopLazor();
            }
            if (state != eState.ATTACK)//is casting spell
            {
                if (enemyState == eEnemyState.NORMAL)
                {
                    if (!charginMyLazor && !lazorCooldown.enabled && hasHeroInLineOfSight())
                    {
                        chargeLazor();
                    }
                    else
                        base.Update();
                }
                else
                {
                    base.Update();
                }
            }//IN attack state:
            else if (charginMyLazor == true && currentVisual.texAniFinished())//was casting spell when chargeTimer wen't
            {   // off, it means it's time to realease Projectile!
                fireDaLazor();
                //base.Update();
            }
            else if (firinMyLazor == true && lazorHold.enabled == false)
            {
                stopFirinDaLazor();
            }
            //When lazor is chargin shoop da whoop stands still
            //base.Update();
        }

        private void stopLazor()
        {
            charginMyLazor = false;
            lazorCooldown.start();
            state = eState.DEFAULT;
            chargingSFX.Stop();
        }

        private void chargeLazor()
        {
            //MOB state to attack
            //chargeTimer.start();
            charginMyLazor = true;
            state = eState.ATTACK;
            chargingSFX = new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_LAZER_PRE.ogg", false, true, 0.95);
        }

        private void fireDaLazor()
        {
            charginMyLazor = false;
            firinMyLazor = true;
            lazorHold.start();
            myLazor = new Projectile(Projectile.eProjType.Lazer, this, this.pX, this.pY, 0.0);
            //state = eState.DEFAULT;
        }
        private void stopFirinDaLazor()
        {
            state = eState.DEFAULT;
            firinMyLazor = false;
            lazorCooldown.start();
            myLazor.Destroy();
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    class Quickie : enemyRanged
    {

        private Timer delayTimer = new Timer(Timer.eUnits.MSEC, 6 * 1000, 0, true, false);
        private bool isThrowingKnife;
        public Quickie(int posx, int posy, double spd)
            : base(Enemy.enemyType.ASSASSIN, posx, posy, spd)
        {
        }
        
        public override void setVisuals()
        {
            Obj vis; int widthMul = 1;
            string texNameBase = "QUICKIE_0";
            if (currentVisual == null)
            {
                // attack:
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_attack_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                vis.width *= widthMul;
                vis.setTexAniFPS(25);
                vis.setTexAniLoopType(Obj_texAni.eLoopType.DEFAULT);
                setStateVisual(vis, "ATTACK");
                // frozen:
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_frozen_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                setStateVisual(vis, "FROZEN");
                 
            }
            else
            {
                if (mobMirrored == true)
                {
                    widthMul = -1;
                }
            }
            // default:
            if (enemyState == eEnemyState.FLEE)
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_scared_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            else if (enemyState == eEnemyState.WOUNDED)
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_wounded_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            else/*enemy state DEFAULT/NORMAL*/
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_MOVE_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            //Finnaly, set those visuals:
            vis.width *= widthMul;
            vis.setTexAniFPS(16);
            setStateVisual(vis, "DEFAULT");
        }


        public override void Update()
        {
            //BUGFIX: when wizard was casting spell when
            //suddenly changed state to wounded/flee => change state from attack then
            if (isThrowingKnife && enemyState != eEnemyState.NORMAL)
            {
                stopThrowing();
            }
            if (state != eState.ATTACK)//is casting spell
            {
                if (enemyState == eEnemyState.NORMAL)
                {
                    if (!isThrowingKnife && !delayTimer.enabled && hasHeroInLineOfSight())
                    {
                        doKnifeSwing();//put "ATTACK" state on, wait till it hit last frame
                    }
                    else
                        base.Update();
                }
                else
                {
                    base.Update();
                }
            }//IN attack state:
            else if (isThrowingKnife == true && currentVisual.texAniFinished())//was casting spell when chargeTimer wen't
            {   // off, it means it's time to realease Projectile!
                throwKnife();
                base.Update();
            }

            base.Update();//so when wizzard is casting spell it will be still moving, remove it if you don't want to
        }

        private void stopThrowing()
        {
            isThrowingKnife = false;
            delayTimer.start();
            state = eState.DEFAULT;
        }

        private void doKnifeSwing()
        {
            isThrowingKnife = true;
            state = eState.ATTACK;
            currentVisual.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
        }

        private void throwKnife()
        {
            isThrowingKnife = false;
            delayTimer.start();
            new Projectile(Projectile.eProjType.Knife, this, this.pX, this.pY, 70.0);
            currentVisual.setTexAniLoopType(Obj_texAni.eLoopType.DEFAULT);
            state = eState.DEFAULT;
        }

    }
}
using System;
using System.Collections.Generic;

using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    class Thief : Enemy
    {
        public uint stolenCookies { get; private set; }
        private PowerUp lastStolenCookie;
        public Thief(int posx, int posy, double spd) : base(Enemy.enemyType.THIEF ,posx,posy,spd)
        {
            myCollision.cdEvent += new CollisionReport.CDEvtHandler(thiefDynamicCollison);
        }
        public override void setVisuals()
        {
            Obj vis; int widthMul = 1;
            string texNameBase = "thief_0";
            if (currentVisual == null)
            {
                // attack:
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_STEAL_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                vis.width *= widthMul;
                vis.setTexAniFPS(20);
                vis.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
                setStateVisual(vis, "ATTACK");
                // frozen:
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_frozen_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                setStateVisual(vis, "FROZEN");
            }
            else
            {
                if (mobMirrored == true)
                {
                    widthMul = -1;
                }
            }
            // default:
            if (enemyState == eEnemyState.FLEE)
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_scared_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            else if (enemyState == eEnemyState.WOUNDED)
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_wounded_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            else/*enemy state DEFAULT/NORMAL*/
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_move_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            //Finnaly, set those visuals:
            vis.width *= widthMul;
            setStateVisual(vis, "DEFAULT");
        }
        private void thiefDynamicCollison(MOB src, collDynEventArgs fe)
        {
            Sound pickup = new Sound(Sound.eSndType.SFX, "../data/Sounds/PICKUP.ogg", false, false);
            pickup.volume = 0.8;

            if (fe.cdPowerUP != null)
            {
                if (fe.cdPowerUP.type == POWER_UP.COOKIE)
                {
                    stealCookie(fe);
                }
            }  
        }
        public override void Update()
        {
            if (state == eState.ATTACK && currentVisual.texAniFinished())
                stealCookieFinish();

            base.Update();
        }

        private void stealCookie(collDynEventArgs fe)
        {
            if (lastStolenCookie != null) return;
            if (state != eState.DEFAULT || enemyState != eEnemyState.NORMAL) return;
            state = eState.ATTACK;
            lastStolenCookie = fe.cdPowerUP;
        }
        private void stealCookieFinish()
        {
            if (lastStolenCookie == null) return;
            state = eState.DEFAULT;
            GameMan.removePowerUp(lastStolenCookie);
            stolenCookies++;
            lastStolenCookie = null;
        }

        internal void giveBackCookies()
        {
            GameMan.statistics.addEatenCookies(stolenCookies);
            stolenCookies = 0;
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    class Wizard : enemyRanged
    {
        private Timer delayTimer = new Timer(Timer.eUnits.MSEC, 9 * 1000, 0, true, false);
        private Sound chargingSFX;
        private bool isCastingSpell;
        public Wizard(int posx, int posy, double spd) : base(Enemy.enemyType.WIZARD,posx,posy,spd)
        {
        }
        public override void setVisuals()
        {
            Obj vis; int widthMul = 1;
            string texNameBase = "wizard_0";
            if (currentVisual == null)
            {
                // attack:
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_attack_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                vis.width *= widthMul;
                vis.setTexAniFPS(20);
                vis.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
                setStateVisual(vis, "ATTACK");
                // frozen:
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_frozen_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                setStateVisual(vis, "FROZEN");
            }
            else
            {
                if (mobMirrored == true)
                {
                    widthMul = -1;
                }
            }
            // default:
            if (enemyState == eEnemyState.FLEE)
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_scared_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            else if (enemyState == eEnemyState.WOUNDED)
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_wounded_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            else/*enemy state DEFAULT/NORMAL*/
                vis = new Obj("../data/Textures/GAME/MOB/" + texNameBase + "_move_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            //Finnaly, set those visuals:
            vis.width *= widthMul;
            setStateVisual(vis, "DEFAULT");
        }

        public override void Update()
        {
            //BUGFIX: when wizard was casting spell when
            //suddenly changed state to wounded/flee => change state from attack then
            if (isCastingSpell && enemyState != eEnemyState.NORMAL)
            {
                CancelSpell();
            }
            if (state != eState.ATTACK)//is casting spell
            {
                if (enemyState == eEnemyState.NORMAL)
                {
                    if (!isCastingSpell && !delayTimer.enabled && hasHeroInLineOfSight())
                    {
                        prepareSpell();
                    }
                    else
                        base.Update();
                }
                else
                {
                    base.Update();
                }
            }//IN attack state:
            else if (isCastingSpell == true && currentVisual.texAniFinished())//was casting spell when chargeTimer wen't
            {   // off, it means it's time to realease Projectile!
                castSpell();
                base.Update();
            }

            base.Update();//so when wizzard is casting spell it will be still moving, remove it if you don't want to
        }

        private void CancelSpell()
        {
            isCastingSpell = false;
            delayTimer.start();
            state = eState.DEFAULT;
            chargingSFX.Stop();
        }

        private void prepareSpell()
        {
            //MOB state to attack
            //chargeTimer.start();
            isCastingSpell = true;
            state = eState.ATTACK;
            chargingSFX = new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_WIZARD_CHARGING.ogg", false, true, 0.72);
            
        }

        private void castSpell()
        {
            isCastingSpell = false;
            delayTimer.start();
            new Projectile(Projectile.eProjType.IceBolt, this, this.pX, this.pY, 70.0);
            state = eState.DEFAULT;
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;
using System.Drawing;
using EngineApp;
using OpenTK.Graphics;

namespace CookieMonster.CookieMonster_Objects
{

    class GameManager
    {
        static public Random variantizer = new Random((int)DateTime.Now.Ticks & 0x0000FFFF);
        static private int _gridSize;

        public Player PC { get { return _pc; } }
        public List<Enemy> enemiesList { get; private set; }
        public List<Enemy> sortedEnemiesList { get; private set; }//recreated on every gameMgr update
        public Timer powerPillTimer { get; private set; }
        public statusScreen statusScr { get; private set;} 
        public int level { get; private set; }
        public bool gamePaused { get; private set; }private List<PowerUp> _sortedPowerUpList; public List<PowerUp> sortedPowerUpList { get { return _sortedPowerUpList; } }
        public Viewport activeView { get { return EngineApp.Game.self.activeViewport; } }
        public GameMap Map { get { return _Map; } }
        public  List<Projectile> projectilesList { get; private set; }
        public CollisionSystem collisionSystem { get { return collSys; } }
        public Timer gameDuration { get; private set; }
        public Timer levelDuration { get; private set; }

        private GameMap _Map;
        private CollisionSystem collSys; 
        private MusicPlayer mPlayer;
        private GUI gui;
        private Statistics stats; public Statistics statistics { get { return stats; } }
        private Player _pc;
        private List<Bomb> _plantedBombs;
        private Timer failureTimer = new Timer(Timer.eUnits.MSEC, 1 * 1000, 0, true, false);
        private Timer slowdownTimer = new Timer(Timer.eUnits.MSEC, 30 * 1000, 0, true, false);
        private bool slowdownActive;

        public static int gridSize
        {
            get { return _gridSize; }
        }
        //returns true when player can proceed to next level;
        public bool canStartNextLevel { get { return statistics.lvlPoints >= Map.cookiesCount * Statistics.ptsPerCookie; } }
        public GameManager()
        {

            initLoadScreen();
            updateLoadingInfos("..."+Lang.cur.Inicjuje_Game_Menagera+"...");
            //init other clases static fields:
            PowerUp.GameMan = this;
            MOB.GameMan = this;
            _gridSize = 48;//in pixels
            level = 1;
            enemiesList = new List<Enemy>();
            sortedEnemiesList = new List<Enemy>();
            _sortedPowerUpList = new List<PowerUp>();
            _plantedBombs = new List<Bomb>();
            projectilesList = new List<Projectile>();
            //collision system init:
            updateLoadingInfos("..."+Lang.cur.Inicjuje_system_kolizji+"...");
            collSys = new CollisionSystem(this);
            CollisionReport.collSystem = collSys;
            powerPillTimer = new Timer(Timer.eUnits.MSEC,1000*15,0,true,false);

            updateLoadingInfos("..."+Lang.cur.wczytuje_poziom+"...");
            //InitGameMap:
            initGameMap();

            //create gui:
            updateLoadingInfos("..."+Lang.cur.tworze_GUI+"...");
            gui = new GUI();
            //music player init
            statusScr = new statusScreen();
            updateLoadingInfos("..."+Lang.cur.inicjuje_odtwarzacz_muzyki+"...");
            mPlayer = new MusicPlayer();

            //create statistics:
            stats = new Statistics();

            updateLoadingInfos("..."+Lang.cur.inicjalizuje_obiekty_poziomu+"...");
            initializeMOBs();
            updateLoadingInfos("..."+Lang.cur.alokuje_pamiec_tekstur+"...");
            Projectile.projectilesVisualsInit();
            InitTeleportFX();
            startGameDurationTimer();
            startLvlDurationTimer();
        }

        private void startGameDurationTimer()
        {
            gameDuration = new Timer(Timer.eUnits.MSEC, -1);
            gameDuration.start();
        }
        private void pauseGameDurationTimer()
        {
            gameDuration.stop();
        }
        private void continueGameDurationTimer()
        {
            gameDuration.start();
        }
        private void startLvlDurationTimer()
        {
            levelDuration = new Timer(Timer.eUnits.MSEC, -1);
            levelDuration.start();
        }
        /// <summary>
        /// create game manager based on passed savegame
        /// </summary>
        /// <param name="sav"></param>

        public GameManager(Savegame sav)
        {
            initLoadScreen();
            updateLoadingInfos("..." + Lang.cur.Inicjuje_Game_Menagera + "...");
            //init other clases static fields:
            PowerUp.GameMan = this;
            MOB.GameMan = this;
            _gridSize = 48;//in pixels
            level = (int)sav.maps[sav.maps.Count-1].level+1;//we starting from next map from last-saved one
            enemiesList = new List<Enemy>();
            sortedEnemiesList = new List<Enemy>();
            _sortedPowerUpList = new List<PowerUp>();
            _plantedBombs = new List<Bomb>();
            projectilesList = new List<Projectile>();
            //collision system init:
            updateLoadingInfos("..." + Lang.cur.Inicjuje_system_kolizji + "...");
            collSys = new CollisionSystem(this);
            CollisionReport.collSystem = collSys;
            powerPillTimer = new Timer(Timer.eUnits.MSEC, 1000 * 15, 0, true, false);

            updateLoadingInfos("..." + Lang.cur.wczytuje_poziom + "...");
            //InitGameMap:
            initGameMap();//after this op. PC will be created
            //We need to preinit PC:
            PC.restoreFromSave(sav);

            //create gui:
            updateLoadingInfos("..." + Lang.cur.tworze_GUI + "...");
            gui = new GUI();
            //music player init
            statusScr = new statusScreen();
            updateLoadingInfos("..." + Lang.cur.inicjuje_odtwarzacz_muzyki + "...");
            mPlayer = new MusicPlayer();

            //create statistics:
            stats = new Statistics();

            updateLoadingInfos("..." + Lang.cur.inicjalizuje_obiekty_poziomu + "...");
            initializeMOBs();
            updateLoadingInfos("..." + Lang.cur.alokuje_pamiec_tekstur + "...");
            Projectile.projectilesVisualsInit();
            InitTeleportFX();

            startGameDurationTimer();
            //todo set current time to old time
            gameDuration.currentTime = sav.player.gameDuration;
            startLvlDurationTimer();
        }
        #region loading_screen
        private Text loadScreenTxtMsg;
        private Obj loadScreenBG;
        private Obj loadScreenAni;
        private void updateLoadingInfos(string msg)
        {
            float xCenter = (float)Game.self.activeViewport.width / 2f;
            float yCenter = (float)Game.self.activeViewport.height / 2f;
            
            float xMinus = TextManager.font_default_20.Measure(msg).Width / 2;
            loadScreenTxtMsg = Game.self.textMenager.produceText(TextManager.font_default_20, msg, xCenter - xMinus, yCenter, QuickFont.QFontAlignment.Left);

            __renderLoadScreen();            
        }

        private void initLoadScreen()
        {
             loadScreenBG = new Obj("../data/Textures/MENU/LOADING_BG.dds", 0.5, 0.5, Obj.align.CENTER_BOTH, false);
             loadScreenAni = new Obj("../data/Textures/MENU/LOADING_ANI_A0.dds", 0.5, 0.42, Obj.align.CENTER_BOTH, false);
             loadScreenBG.isGUIObjectButUnscaled = true;
             loadScreenAni.isGUIObjectButUnscaled = true;
        }
        private void __renderLoadScreen()
        {
            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
            loadScreenBG.Render();
            loadScreenAni.Render();
            if (loadScreenTxtMsg != null) 
            loadScreenTxtMsg.Print();
            Game.self.SwapBuffers();
        }
        #endregion
        private void initializeMOBs()
        {
            PC.Initialize();
            for (int i = 0; i < enemiesList.Count; i++)
                enemiesList[i].Initialize();
        }
        public void nextLevel()
        {
            pauseGameDurationTimer();
            //update saveGame
            Profile.currentProfile.autoSave();

            updateLoadingInfos("...dealokuje pamiec tekstur");
            powerPillTimer.restart();
            powerPillTimer.stop();
            enemiesList = new List<Enemy>();
            sortedEnemiesList = new List<Enemy>();
            _sortedPowerUpList = new List<PowerUp>();
            _plantedBombs = new List<Bomb>();
            projectilesList = new List<Projectile>();
            
            level++;

            updateLoadingInfos("...wczytuje poziom");
            initGameMap();

            updateLoadingInfos("...inicjalizuje obiekty poziomu");
            initializeMOBs();
            PC.renewSkills();
            Game.self.gameCamera.correctForNewLevel();

            //start timers:
            continueGameDurationTimer();
            startLvlDurationTimer();

        }
        private void initGameMap()
        {
            Game.self.gameCamera.resetPos();            
            String mapFile = "LEVEL_" + level.ToString() + ".pn"+"g";//workaround to force it always as dds
            mapFile = GameMap.MapsPath + mapFile;
            _Map = new GameMap(mapFile, this);
            EngineApp.Game.self.gameViewport.setGameMap(_Map);//adding map to viewport rendering
        }

        public void InitPC(int x, int y)
        {
            if (PC == null)//pc still not created:
            {
                Obj oPCdef = new Obj("../data/Textures/GAME/MOB/cookie_move_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                Obj oPCidle = new Obj("../data/Textures/GAME/MOB/cookie_idle_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                Obj oPCeat = new Obj("../data/Textures/GAME/MOB/cookie_attack_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                Obj oPCfrozen = new Obj("../data/Textures/GAME/MOB/cookie_frozen_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
                oPCdef.setTexAniFPS(12);
                oPCidle.setTexAniFPS(20);
                oPCeat.setTexAniFPS(18);
                oPCeat.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
                oPCidle.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
                _pc = new Player(x, y, 60);//60
                _pc.setStateVisual(oPCdef, "DEFAULT");
                _pc.setStateVisual(oPCidle, "IDLE");
                _pc.setStateVisual(oPCeat, "ATTACK");
                _pc.setStateVisual(oPCfrozen, "FROZEN");
            }
            else
            {   //only move hero to new starting position:
                PC.Move(x - PC.pX, y - PC.pY, false);
            };
            
            //mobList.Add(_pc);
        }
        private bool afterFirstUpdate;
        public void Update()
        {
            // Some very ugly bugfix:
            if (!afterFirstUpdate)
            {
                afterFirstUpdate = true;
                Game.self.InitCamera();
            }


            if (gamePaused) { statusScr.Update(); return; } //game paused? don't do any updates
            
            //Update on slow down:
            slowDownUpdate();

            powerPillUpdate();
            //update collisions:
            collSys.Update();
            //update music player:
            mPlayer.Update();
            //re-sort MOB list: & update them
            updateMOBs();

            //Updates powerUPs:
            for (int i = 0; i < sortedPowerUpList.Count; i++)
                sortedPowerUpList[i].Update();

            //Updates planted bombs: (change keyframes checking if they're ready to explode
            for (int i = 0; i < _plantedBombs.Count; i++)
                _plantedBombs[i].Update();

            //update Projectiles:
            for (int i = 0; i < projectilesList.Count; i++)
                projectilesList[i].Update();

            //update StatusScreen(this needed only when he's easing-out
            statusScr.Update();
        }

        private void slowDownUpdate()
        {
            if (slowdownActive && slowdownTimer.enabled == false)
            {
                slowdownActive = false;
                Profile.currentProfile.config.options.sound.musicVol *= 10.0;
                Game.self.SoundMan.recalculateMusic();
                for (int i = 0; i < enemiesList.Count; i++)
                {
                    enemiesList[i].resetMovementSpeed();
                }
            }
        }

        private void updateMOBs()
        {
            sortedEnemiesList.Clear();
            _pc.Update();
            for (int i = 0; i < enemiesList.Count; i++)
            {
                enemiesList[i].Update();//update mob
                int j = 0;
                for (; j < sortedEnemiesList.Count; j++)
                {
                    if (enemiesList[i].pY < sortedEnemiesList[j].pY)
                        break;
                    else if (enemiesList[i].pX < sortedEnemiesList[j].pX)
                        break;
                }
                sortedEnemiesList.Insert(j, enemiesList[i]);
                j++;
            }
        }
        public void Render()
        {//handles all object render during Game
            if (_Map != null)
            {
                _Map.Render();
            }
            //renders bomb(overlaying all other objects:)
            for (int i = 0; i < _plantedBombs.Count; i++)
                _plantedBombs[i].Render();

            //render Projectiles:
            for (int i = 0; i < projectilesList.Count; i++)
                projectilesList[i].Render();

            // Render lightmaps:
            Game.self.lightEngine.Render();

            //music player render:
            mPlayer.Render();

            //gui render:
            gui.Render();
            statusScr.Render();
        }

        internal void KeyboardEvt(object sender, OpenTK.Input.KeyboardKeyEventArgs k)
        {
            if (_pc != null)
                _pc.KeyboardEvt(sender, k);
            if( k.Key == OpenTK.Input.Key.Escape)
                    ESCClicked(); 
        }
        /// <summary>
        /// ads to list of power ups, in sorted order
        /// sort by Y then X position
        /// </summary>
        /// <param name="p"></param>
        public void addPowerUP(PowerUp p)
        {
           /* int i = 0;
            while (i<sortedPowerUpList.Count)
            {
                if ((sortedPowerUpList[i].pY < p.pY) && (sortedPowerUpList[i].pY < p.pY))
                    i++;
                else
                    break;
            }
            sortedPowerUpList.Insert(i, p);
            */
            sortedPowerUpList.Add(p);
        }
        public void removePowerUp(PowerUp p)
        {
            sortedPowerUpList.Remove(p);
        }

        //Teleport Stuff:
        private Obj _teleportFX; public Obj teleportFX{get {return _teleportFX;}}
        private void InitTeleportFX()
        {
            _teleportFX = new Obj("../data/Textures/Game/FX/TELEPORT_A0.dds", 128, 128, Obj.align.CENTER_BOTH);
            _teleportFX.setTexAniFPS(30);
            _teleportFX.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
        }
        public void ReinitTeleportFX(int px, int py)
        {
            _teleportFX.x = px; _teleportFX.y = py;
            _teleportFX.restartTexAni();
        }

        internal void addBomb(Bomb bomb)
        {
            _plantedBombs.Add(bomb);
        }
        internal void removeBomb(Bomb bomb)
        {
            _plantedBombs.Remove(bomb);
        }
        
        internal void bombExplode(Bomb bomb)
        {
            int y = bomb.gridY;
            for (int x = bomb.gridX - 1; x <= bomb.gridX + 1; x++)
            {
                if (x == bomb.gridX)
                {
                    for (y = bomb.gridY - 1; y <= bomb.gridY + 1; y++)
                    {
                        Map.tryDestroyObject(x, y);
                    }
                    y = bomb.gridY;
                }
                else
                {
                    Map.tryDestroyObject(x, y);
                }
            }
            Map.addBombDecay(bomb.pX, bomb.pY);
        }

        internal void heroHasNewWP()
        {
            for (int i = 0; i < enemiesList.Count; i++)
            {
                if(enemiesList[i].enemyState == Enemy.eEnemyState.NORMAL)
                enemiesList[i].recalculateShortestWay();
            }
        }

        private void powerPillUpdate()
        {
            if (!powerPillActive())
            {
                for (int i = 0; i < enemiesList.Count; i++)
                {
                    if (enemiesList[i].enemyState == Enemy.eEnemyState.FLEE)
                        enemiesList[i].enemyState = Enemy.eEnemyState.NORMAL;
                }
            }
        }

        public bool powerPillActive()
        {
            return powerPillTimer.enabled;
        }
        internal void PlayerTakePowerPellet()
        {
            powerPillTimer.restart();
            for (int i = 0; i < sortedEnemiesList.Count; i++)
            {
                sortedEnemiesList[i].enemyState = Enemy.eEnemyState.FLEE;
            }
        }

        internal void slowEnemies()
        {
            Sound slowdown = new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_TIMESLOW.ogg", false, false);
            slowdown.volume = 0.8;
            //Mute music when slowdown is active:
            Profile.currentProfile.config.options.sound.musicVol *= 0.1;
            Game.self.SoundMan.recalculateMusic();
            slowdown.Play();
            slowdownTimer.start();
            slowdownActive = true;
            for (int i = 0; i < enemiesList.Count; i++)
            {
                enemiesList[i].setSlow();
            }

        }
        /// <summary>
        /// Get's an grid pos of passed Object
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public static Point getObjGridPos(Obj obj)
        {
            Point ret = new Point((obj.x + obj.width / 2) / GameManager.gridSize,
                                  (obj.y + obj.height / 2) / GameManager.gridSize);
            return ret;
        }

        public void playFailSound()
        {
            if (!failureTimer.enabled)
            {
                failureTimer.start();
                Sound failure = new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_DISABLED.ogg", false, true, 0.8);
            }
        }

        public void Pause()
        {
            gamePaused = true;
        }
        public void UnPause()
        {
            gamePaused = false;
        }
        public void toggleIngameMenu()
        {
            Pause();
            statusScr.Show();
        }
        public void untoggleIngameMenu()
        {
            UnPause();
            statusScr.Hide();
        }

        internal void ESCClicked()
        {
           if(!statusScr.active)
           {
               toggleIngameMenu();
           }
           else
           {
               untoggleIngameMenu();
           }
        }
        public void Free()
        {
            mPlayer.Free();
        }
    }
}
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;
using OpenTK;
using OpenTK.Graphics.OpenGL;
using EngineApp;

namespace CookieMonster.CookieMonster_Objects
{

    class GameMap
    {
        private GameManager gameMgr;
        private Bitmap _interpretationMap; // generated automatically
        private Obj[,] mapRenderQueueFirst;//Darkness Objects
        private Obj[,] mapRenderQueue; //queue is sorted but need to put in movable/dynamic objects like player, enemies
        private Obj[,] torches; //Animated Torch
        private Obj[,] paths; //paths on map [and bridges too] (rendered firstly after background)
        private List<Portal> _portals = new List<Portal>(); //portale przenosza z pewnego pkt. mapy na inny;
        private Obj _bg; public Obj background { get { return _bg; } }
        public Waynet wayNetwork{get; private set;}
        static public String MapsPath = "../data/Maps/";
        public int mapWidth { get { return _interpretationMap.Width; } }
        public int mapHeight { get { return _interpretationMap.Height; } }
        public int cookiesCount { get; private set; }
        public bool waynetActive { get; private set; }
        static int level = 10;

        //internal OpenGL stuff:
        /// <summary>
        /// Static part of buffer that will be rendered always the same (in exact position
        /// and with exact same image) - used for performance optimization.
        /// </summary>
        private int[] _staticBufferTextures; private int staticTexSize = 512;
        private int staticTexCntX, staticTexCntY, realYstartPos;
        private int yStaticMapShift = -286;//282


        public GameMap(string bitPath,GameManager g)
        {
            //reset all Lights:
            EngineApp.Game.self.lightEngine.clearAllLights();
            EngineApp.Game.self.lightEngine.lightAddStrength = 0.6f;
            EngineApp.Game.self.lightEngine.lightMulStrength = 0.4f;
            level++;
            neighborReport.map = this;
            Portal.resetPortalsCount();

            _bg = new Obj(PATH_BACKGROUND_TILE, 0.5, 0.5, Obj.align.CENTER_BOTH);
            gameMgr = g;
            _interpretationMap = (Bitmap)Bitmap.FromFile(bitPath);
            cookiesCount = 0;
            if (gameMgr.statistics != null)
            {
                gameMgr.statistics.newLevel();//resets lvlPoints
            }
            wayNetwork = new Waynet(this);
            generateMap();
            generateStaticMapToTexture();
        }
        /// <summary>
        /// Function checks point passed as argument goes
        /// through portal, if that's true it will return Point with
        /// coordinates on the other side of portal.
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        public Point tryGoThroughPortal(Point entry)
        {
            Point p = entry;
            for (int i = 0; i < _portals.Count; i++)
            {
                if (_portals[i].gridPt1.Equals(p))
                {
                    p.X = _portals[i].gridPt2.X;
                    p.Y = _portals[i].gridPt2.Y;
                    return p;
                }
                else if (_portals[i].gridPt2.Equals(p))
                {
                    p.X = _portals[i].gridPt1.X;
                    p.Y = _portals[i].gridPt1.Y;
                    return p;
                }
            }
            return entry;
        }
        
        public objType getObjTypeFromPixel(int x, int y)
        {
            if ((x < 0) || (x >= _interpretationMap.Width) || (y < 0) || (y >= _interpretationMap.Height))
            {/* new DebugMsg("tried to read map pixel out of bounds!");*/ return objType.OTHER; }
            return colorIs(_interpretationMap.GetPixel(x, y));
        }
        public Color getPXColor(int x, int y)
        {
            if ((x < 0) || (x >= _interpretationMap.Width) || (y < 0) || (y >= _interpretationMap.Height))
                return Color.Transparent;
            return _interpretationMap.GetPixel(x, y);
        }
        public Portal getPortalByColor(Color c)
        {
            for (int i = 0; i < _portals.Count; i++)
                if (_portals[i].portalColor == c) return _portals[i];
            return null;
        }
        public void generateMap()
        {
            //if (level == 1) waynetActive = false;
            waynetActive = true;
            mapRenderQueue = new Obj[mapWidth, mapHeight]; // new List<Obj>();
            mapRenderQueueFirst = new Obj[mapWidth, mapHeight];
            torches = new Obj[mapWidth, mapHeight];
            //lensFlares = new List<Obj>();
            paths = new Obj[mapWidth, mapHeight];
            for (int y = 0; y < _interpretationMap.Height; y++)
                for (int x = _interpretationMap.Width-1; x >= 0; x--)//in choosen isometric view it will be look much better
                {
                    Color c = _interpretationMap.GetPixel(x, y);
                    objType t = colorIs(c);
                    AddObject(t,x,y);
                }
                wayNetwork.generateWays();
                shortestWayAlgoritm.wnet = wayNetwork;
                ShortestWaysTable.Initialize();
                shortestWayAlgoritm New;
                System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();
                timer.Start();
                for (int i = 0; i < wayNetwork.Count; i++)
                    New = new shortestWayAlgoritm(wayNetwork[i], null);
                timer.Stop();
                long time = timer.ElapsedMilliseconds;
                wayNetwork.renderWaynet = false;

        }
        /// <summary>
        /// When map is fully loaded this function will create texture with rendered
        /// static part of this GameMap.
        /// </summary>
        private void generateStaticMapToTexture()
        {            
            // Clear current buffer:
            GL.ClearColor(0,0,0,0);
            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
            GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);

            int w = Game.self.Width, h = Game.self.Height;
                        //Delete old textures:
            if (_staticBufferTextures != null)
                GL.DeleteTextures(staticTexCntX * staticTexCntY, _staticBufferTextures);

            // Compute real startpoint X ("zero"):
            realYstartPos = EngineApp.Game.self.Height;
            // openGL coords was making alot of troubles with (0,0) at
            // down left corner of current rendered viewport (not the whole scene!)
            // Finding upper left corner of viewport, which (just after rendering all static Obj's
            // when camera offset is still(0,0) is at the same time upper left corner
            // of whole scene is much more handy, and as i throught - needed anyway.
            // 20:11 2012-10-27
             #region Count needed amount of textures:
            int mapW = (mapWidth-1) * GameManager.gridSize;
            int mapH = mapHeight * GameManager.gridSize;

            staticTexCntX = (int)Math.Ceiling(mapW / (float)staticTexSize);
            staticTexCntY = (int)Math.Ceiling(mapH / (float)staticTexSize);  
            #endregion
            
            // Generate image(s) for storing buffer after rendering objects:
            _staticBufferTextures = new int[staticTexCntX * staticTexCntY+1];
            GL.GenTextures(staticTexCntX * staticTexCntY, _staticBufferTextures);

            // Creating textures from actual gameMap
            // ---
            // How this works(loop2D):
            // 1. Sets new arrayPointer (22*i,22*i)
            // 2. Set new camShift (21+shift=16*i)
            // 3. Render objects on new part of map (>1024x1024px)
            // 4. Put rendered stuff into 4 new textures
            // 5. Quit if all objects was rendered, or start from 1. again.
            
            int objToRenderX = 22;//in one loop, in one row/column
            int objToRenderY = 11;
            int objShiftX = 16;
            int objShiftY = 16;
            // "Height" loop: (only one row per loop)
            for (int i = 0; i < staticTexCntY; i++)
            {
                // 11 - number of objects per one texture:
                int texTillEnd = staticTexCntX;
                // "Width" loop:
                for (int j = 0; j < Math.Ceiling(staticTexCntX/2.0); j++)
                {
                    texTillEnd -= 2; //decrease number of textures till end by two (they're be rendered in this loop)

                    Camera cam = Game.self.gameCamera;
                    Point arrayPointer = new Point(j * (objToRenderX - 1), i * (objToRenderY - 1));
                    Point camShift = new Point((j * (objToRenderX - 1)) * GameManager.gridSize + j * objShiftX,
                                               (i * (objToRenderY - 1)) * GameManager.gridSize + i * objShiftY);
                    cam.SetPos(-camShift.X, -camShift.Y);
                    new DebugMsg("Moved camera to: (" + camShift.X + "," + camShift.Y + ")");
                        
                    // render underlying objects:
                    //renderBackground();
                    for (int x = arrayPointer.X; (x < arrayPointer.X + objToRenderX && x < mapWidth); x++)
                    {
                        for (int y = arrayPointer.Y; (y < objToRenderY + arrayPointer.Y && y < mapHeight); y++)
                        {
                            if(mapRenderQueueFirst[x,y]!=null)
                                mapRenderQueueFirst[x, y].Render();
                        }
                    } for (int x = arrayPointer.X; (x < arrayPointer.X + objToRenderX && x < mapWidth); x++)
                    {
                        for (int y = arrayPointer.Y; (y < objToRenderY + arrayPointer.Y && y < mapHeight); y++)
                        {
                            if (paths[x, y] != null)
                                paths[x, y].Render();
                        }
                    } for (int x = arrayPointer.X; (x < arrayPointer.X + objToRenderX && x < mapWidth); x++)
                    {
                        for (int y = arrayPointer.Y; (y < objToRenderY + arrayPointer.Y && y < mapHeight); y++)
                        {
                            if (mapRenderQueue[x, y] != null)
                                mapRenderQueue[x, y].Render();
                        }
                    }
                     
                    GL.ReadBuffer(ReadBufferMode.Back);
                    // Drawing textures in one main loop  
                    // there is always 2x2 textures to draw
                    // new: 2x2 wasn't working properly, reduced to 2x1
                    for (int _y = 0; (_y < 1 && _y + i < staticTexCntY); _y++)
                    {
                        for (int _x = 0; (_x < 2 && _x + 2*j < staticTexCntX); _x++) //+2 cause of decreasing texTillEnd by two at start of loop
                        { // 'magic' happens here:
                            int x_start = j*2;
                            int y_start = i;
                            /*        *  column  *    *           row           */
                            int idx = (j * 2 + _x) + (i + _y) * staticTexCntX;
                            GL.BindTexture(TextureTarget.Texture2D, _staticBufferTextures[idx]);
                            GL.CopyTexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, (_x * staticTexSize), realYstartPos - ((_y + 1) * staticTexSize), staticTexSize, staticTexSize, 0);
                            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
                            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
                            new DebugMsg("Created mapTEX[" + idx + "] - (" + (_x * staticTexSize) + "," + (realYstartPos - ((_y + 1) * staticTexSize)) + ")");
                        }
                    }

                    Game.self.SwapBuffers();
                    for (int z = 0; z < int.MaxValue / 8; z++) ;
                    Game.self.SwapBuffers();
                    GL.Clear(ClearBufferMask.ColorBufferBit|ClearBufferMask.DepthBufferBit);
                }
            }

            
            //clear back to black:
            GL.ClearColor(0, 0, 0, 0);
            GL.Clear(ClearBufferMask.ColorBufferBit);
            GL.Enable(EnableCap.ClipPlane0);

            // Reshape viewport to old shape
            //GL.Viewport(0, 0,w,h);
            
        }
        /// <summary>
        /// Render static part of Map buffer
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        private void renderStaticPartOfMap(int _x,int _y)
        {
            int xoff = 0, yoff = realYstartPos - staticTexSize;
            int staticTexSizeY = staticTexSize - 20;
            for (int y = 0; y < staticTexCntY; y++)
            {
                for (int x = 0; x < staticTexCntX; x++)
                { //'magic' happens here: 
                    GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
                    GL.BindTexture(TextureTarget.Texture2D, _staticBufferTextures[y * staticTexCntX + x]);
                xoff = (staticTexSize) * x;
                yoff = realYstartPos - staticTexSizeY + (staticTexSizeY) * y;
                GL.Begin(BeginMode.Quads);
                /* 0---2 How
                 * |  /| Quad
                 * | / | is
                 * 1/--3 Made */
                float zero = 1f/(float)staticTexSize;
                float one = 1f - (1f / (float)staticTexSize);
                GL.TexCoord2(zero, one);
                    GL.Vertex2(_x + xoff, _y + yoff);

                    GL.TexCoord2(zero, zero);
                    GL.Vertex2(_x + xoff, _y + staticTexSizeY + yoff);

                    GL.TexCoord2(one, zero);
                    GL.Vertex2(_x + xoff + staticTexSize, _y + staticTexSizeY + yoff);

                    GL.TexCoord2(one, one);
                    GL.Vertex2(_x + xoff + staticTexSize, _y + yoff);
                GL.End();  
               }
            }
            //Back to old blend function:
            GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
        }
        private void renderBackground()
        {
            int w = EngineApp.Game.self.Width;
            int h = EngineApp.Game.self.Height;
            Camera c = EngineApp.Game.self.gameCamera;
            GL.BindTexture(TextureTarget.Texture2D, background.glTexID);
            GL.Begin(BeginMode.Quads);
            /* 0---2 How
             * |  /| Quad
             * | / | isy
             * 1/--3 Made */
            float x = 880;
            float y = 550;
            GL.TexCoord2(0 - c.camOffsetX / x, 1.5 + c.camOffsetY / y);
            GL.Vertex2(0,0);

            GL.TexCoord2(0 - c.camOffsetX / x, 0 + c.camOffsetY / y);
            GL.Vertex2(0,h);

            GL.TexCoord2(1.5 - c.camOffsetX / x, 0 + c.camOffsetY / y);
            GL.Vertex2(w, h);

            GL.TexCoord2(1.5 - c.camOffsetX / x, 1.5 + c.camOffsetY / y);
            GL.Vertex2(w, 0);
            GL.End(); 
        }
        public void Render()
        {
            renderBackground();
            //Renders static parts of map:
            Camera c = EngineApp.Game.self.gameCamera;
            renderStaticPartOfMap(c.camOffsetX, c.camOffsetY + yStaticMapShift);//(c.camOffsetX, c.camOffsetY + );

            int i = 0;
            bool pcRendered = false;

            //MOBS:
            for (i = 0; i < gameMgr.sortedEnemiesList.Count;i++)
            {
                if (gameMgr.sortedEnemiesList[i] != null)
                    gameMgr.sortedEnemiesList[i].Render();
            }
            //POWER UPS:
            for (i = 0; i < gameMgr.sortedPowerUpList.Count;i++ )
            {
                if (gameMgr.sortedPowerUpList[i] != null)
                        gameMgr.sortedPowerUpList[i].Render();
            }
            //PLAYER:
            gameMgr.PC.Render();

            //portals: overlaping most of map objects:
            for (i = 0; i < _portals.Count; i++)
                _portals[i].Render();

           // for (i = 0; i < lensFlares.Count; i++)
           //     lensFlares[i].Render();
        }
        #region Creating Map objects readed from interpretationMap pixel data
        private void AddObject(objType typ, int x, int y)
        {
            //Converts x,y map to real x,y offset + adding half of grid size
            //(objects will be rendered as center) -> that will be cool just trust me ;)
            int cx, cy;//converted input x,y offset pos
            cx = x * GameManager.gridSize +(GameManager.gridSize / 2);//centerize it!
            cy = y * GameManager.gridSize +(GameManager.gridSize / 2);//centerize it!
            Color col = _interpretationMap.GetPixel(x, y);
            switch(typ)
            {
                case objType.PORTAL:
                    addPortal(cx, cy, col); break;
                case objType.PLAYER:
                    addPlayer(cx,cy); break;
                case objType.POWERUP:
                    addPowerUP(cx,cy,col); break;
                case objType.ENEMY:
                    addEnemy(cx,cy,col); break;
                case objType.DESTROYABLE|objType.DARKNESS:
                    addBridge(cx, cy,x,y); break;
                case objType.PATH:
                    addPath(cx, cy); break;
               
                default://multi-flags:
                    if (typ == (objType.COLLIDEABLE | objType.CLIFF))
                        addCliff(cx, cy);
                    else if (typ == (objType.COLLIDEABLE | objType.DARKNESS))
                        addDarkness(cx, cy);
                    else if (typ == (objType.COLLIDEABLE | objType.LIGHT_EMITING))
                        addTorch(cx, cy);
                    else if(typ == objType.COLLIDEABLE)
                        addWall(cx, cy); 
                break;
            }
        }

        private void addBridge(int x, int y,int gridx, int gridy)
        {
            if (getObjTypeFromPixel(gridx - 1, gridy) != (objType.DESTROYABLE | objType.DARKNESS))
            {
                paths[gridx, gridy] = new Obj(PATH_BRIDGE_ENDL, x, y, Obj.align.CENTER_BOTH);
                //paths.Add(new Obj(PATH_BRIDGE_ENDL, x, y, Obj.align.CENTER_BOTH));
            }
            else if (getObjTypeFromPixel(gridx + 1, gridy) != (objType.DESTROYABLE | objType.DARKNESS))
            {
                paths[gridx, gridy] = new Obj(PATH_BRIDGE_ENDR, x, y, Obj.align.CENTER_BOTH);
                //paths.Add(new Obj(PATH_BRIDGE_ENDR, x, y, Obj.align.CENTER_BOTH));
            }
            else
            {
                paths[gridx, gridy] = new Obj(PATH_BRIDGE, x, y, Obj.align.CENTER_BOTH);
                //paths.Add(new Obj(PATH_BRIDGE, x, y, Obj.align.CENTER_BOTH));
            };
            
        }

        private void addCliff(int x, int y)
        {
            int gridx = (x-(GameManager.gridSize/2))/GameManager.gridSize;
            int gridy = (y-(GameManager.gridSize/2))/GameManager.gridSize;
            Obj cliff = Cliffs.getCliffVisual(new neighborReport(gridx, gridy, objType.CLIFF));
            if (cliff == null) return;
            cliff = cliff.shallowCopy();
            //path
            //create waypoint(report)
            y -= cliff.height / 2;//FIX
            x -= cliff.width / 2;//FIX
            cliff.x = x;
            cliff.y = y;
            
            //NOTE: From lists to arrays of objects
            mapRenderQueueFirst[x,y] = cliff;
            //mapRenderQueueFirst.Add(cliff);//cliff can be threaten like path
        }

        private void addEnemy(int x, int y,Color c)
        { 
            //color range: (1-126) (BLUE)
            // NORMAL 1-40
            // WIZARD 41-60
            // THIEF 61-80
            // SHOOP 81-100
            // ASSASSIN 101-120
            addPath(x, y);

            y -= GameManager.gridSize / 2;//FIX
            x -= GameManager.gridSize / 2;//FIX
            if (c.B < 41)
                new Enemy(Enemy.enemyType.NORMAL, x, y, 50);
            else if (c.B < 61)
                new Wizard(x, y, 40);
            else if (c.B < 81)
                new Thief(x, y, 50);
            else if (c.B < 101)
                new Lazer(x, y, 55);
            else if (c.B < 121)
                new Quickie(x, y, 61);
        }

        private void addDarkness(int x,int y)
        {
            mapRenderQueueFirst[x,y] = new Obj(PATH_DARKNESS, x, y, Obj.align.CENTER_BOTH); 
            //mapRenderQueueFirst.Add(new Obj(PATH_DARKNESS, x, y, Obj.align.CENTER_BOTH));
        }
        void addPowerUP(int x, int y,Color c)
        {
            //COLORS: R0,G(1-126),B0
            addPath(x, y);
            byte g = c.G;
            if (g<=40)//cookies! yummy
            {
                cookiesCount++;
                new PowerUp(x,y,PATH_PU_COOKIE);
            }
            else if(g<=60)//power pill
            {
                new PowerUp(x, y, PATH_PU_POWERPILL);
            }
            else if(g<=70)//bomb
            {
                new PowerUp(x, y, PATH_PU_BOMB);
            }
            else if (g <= 80)//enemyslower
            {
                new PowerUp(x, y, PATH_PU_ENEMYSLOWER);
            }
            else if (g <= 90)//extra life
            {
                new PowerUp(x, y, PATH_PU_LIFE);
            }
            else if (g <= 100)//extra skill point
            {
                new PowerUp(x, y, PATH_PU_SKILLPOINT);
            };
            
            //TODO: rest
        }

        private void addPath(int x, int y)
        {
            // mapRenderQueue.Add(new Obj(PATH_, x, y, Obj.align.LEFT));
            int gridx = (x-(GameManager.gridSize/2))/GameManager.gridSize;
            int gridy = (y-(GameManager.gridSize/2))/GameManager.gridSize;
            neighborReport report = new neighborReport(gridx, gridy);
            Obj path = new Obj();// = Paths.getPathVisual(report);

            if (Profile.currentProfile.config.options.graphics.renderPaths)
            {
                Obj rp = new Obj();
                rp = Paths.getPathVisual(report);
                if (rp == null) return; // no path, break this right now!
                path = rp.shallowCopy();
                //path
                //create waypoint(report)
                y -= path.height / 2;//FIX
                x -= path.width / 2;//FIX
                path.x = x;
                path.y = y;
                paths[gridx, gridy] = path;
                //paths.Add(path);
            }
            if (report.createWaypoint == true && waynetActive)
            {
                wayNetwork.addWaypoint(new Waypoint(gridx, gridy));
            }
        }

        private void addPlayer(int x, int y)
        {
            addPath(x, y);
            y -= GameManager.gridSize / 2;//FIX
            x -= GameManager.gridSize / 2;//FIX
            gameMgr.InitPC(x, y);
            //dont add player to map render queue, he's moveable so his position in rnd queue will vary!
        }
        private void addPortal(int x,int y, Color c)
        {
            addPath(x, y);
            bool workDone = false;
            for (int i = 0; (i < _portals.Count && workDone == false); i++)
            {
                workDone = _portals[i].matchWithPortal(x, y, c, i);
            }
            if (!workDone) // so we will need to create new portal
            {
                Portal tmp = new Portal(x,y, c);
                _portals.Add(tmp);
            }
        }
         

        private void addWall(int x, int y)
        { //TODO: Unfinished
            int gridx = (x - (GameManager.gridSize / 2)) / GameManager.gridSize;
            int gridy = (y - (GameManager.gridSize / 2)) / GameManager.gridSize;
            mapRenderQueue[gridx,gridy] = new Obj(PATH_STONEWALL, x, y, Obj.align.CENTER_BOTH);
            //mapRenderQueue.Add(new Obj(PATH_STONEWALL, x, y, Obj.align.CENTER_BOTH));
        }
        private void addTorch(int x, int y)
        { //TODO: Unfinished
            int gridx = (x - (GameManager.gridSize / 2)) / GameManager.gridSize;
            int gridy = (y - (GameManager.gridSize / 2)) / GameManager.gridSize;
            addWall(x, y);
            Obj Torch = new Obj(PATH_TORCH, x-2, y-14, Obj.align.CENTER_BOTH);
            Torch.setTexAniFPS(12);
            Torch.Desynchronize();

            torches[gridx,gridy] = Torch;
            //mapRenderQueue.Add(Torch);

            //setup light:
            radialGradient torchGrad = new radialGradient(new Vector2(),
                                                          130f,
                                                          new Vector4(1f, 0.8f, 0.2f, 0.65f),
                                                          new Vector4(1f, 0.3f, 0f, 0f),
                                                          BlendingFactorSrc.SrcAlpha,
                                                          BlendingFactorDest.One);
            Light torch = new Light(Light.eLightType.STATIC, torchGrad);
            torch.setPos(new OpenTK.Vector2(x - 2, y - 14));

            //lensFlares.Add(new Obj(PATH_TORCHLIGHT, x, y, Obj.align.CENTER_BOTH));
            // torch light in another List, rendered at least
        }
#endregion

        [Flags]
        public enum objType
        {
            OTHER = 1 << 0, COLLIDEABLE = 1 << 1, DESTROYABLE = 1 << 2, LIGHT_EMITING = 1 << 3,
            POWERUP = 1 << 4, ENEMY = 1 << 5, PORTAL = 1 << 6, PLAYER = 1 << 7, CLIFF = 1 << 8, DARKNESS = 1 << 9,
            PATH = 1 << 10
        }
        private objType colorIs(Color c)
        {
            objType ret = 0;
            UInt32 argb = (UInt32)c.ToArgb();
            //PowerUp?
            UInt32 tmp = argb;
            tmp = tmp | COLOR_POWERUP_RANGE;
            if ((argb | COLOR_POWERUP_RANGE) == (COLOR_POWERUP_BASE | COLOR_POWERUP_RANGE))
            {//check if color is in range
                tmp = (argb & COLOR_POWERUP_RANGE)%0xFF;
                if ((tmp >= COLOR_POWERUP_MIN) && (tmp <= COLOR_POWERUP_MAX))
                    ret = objType.POWERUP;
            }
            //Enemy?
            else if ((argb | COLOR_ENEMY_RANGE) == (COLOR_ENEMY_BASE | COLOR_ENEMY_RANGE))
            {//check if color is in range
                tmp = (argb & COLOR_ENEMY_RANGE) % 0xFF;
                if ((tmp >= COLOR_ENEMY_MIN) && (tmp <= COLOR_ENEMY_MAX))
                    ret = objType.ENEMY;
            }
            //Portal?
            else if ((argb | COLOR_PORTAL_RANGE | COLOR_PORTAL_RANGE2) == (COLOR_PORTAL_BASE | COLOR_PORTAL_RANGE | COLOR_PORTAL_RANGE2))
            {//check if color is in range this time it's double range
                tmp = (argb & COLOR_PORTAL_RANGE) % 0xFF;
                if ((tmp >= COLOR_PORTAL_MIN) && (tmp <= COLOR_PORTAL_MAX))
                {
                    tmp = (argb & COLOR_PORTAL_RANGE2) % 0xFF;
                    if ((tmp >= COLOR_PORTAL_MIN) && (tmp <= COLOR_PORTAL_MAX))
                        return objType.PORTAL;
                }
            };
            //flags:
            if ((argb & CFLAG_COLLIDE) == CFLAG_COLLIDE)
                ret |= objType.COLLIDEABLE;
            if ((argb & CFLAG_DESTROYABLE) == CFLAG_DESTROYABLE)
                ret |= objType.DESTROYABLE;
            if ((argb & CFLAG_LIGHTEMITING) == CFLAG_LIGHTEMITING)
                ret = ret|objType.LIGHT_EMITING;

            if (argb == COLOR_PLAYER)
                return objType.PLAYER;
            if (argb == COLOR_CLIFF)
                return objType.COLLIDEABLE | objType.CLIFF;
            if (argb == COLOR_DARKNESS)
                return objType.COLLIDEABLE | objType.DARKNESS;

            if (ret == objType.DESTROYABLE)//it's a bridge:
                return ret | objType.DARKNESS;

            //at least, it's an path?
            if ((ret == 0) && ((argb & COLOR_NOTHING) != COLOR_NOTHING))
                ret |= objType.PATH;
                
            return ret;

        }

        #region Textures Paths Constants
        static private string PATH_DARKNESS               = "../Data/Textures/GAME/SOB/DARKNESS.dds";
        static private string PATH_STONEWALL              = "../Data/Textures/GAME/SOB/StoneWall_V0.dds";
        static private string PATH_BACKGROUND_TILE        = "../Data/Textures/GAME/BG_Stone_V0.png";
        static private string PATH_TORCH                  = "../Data/Textures/GAME/SOB/Torch_A0.dds";
        static private string PATH_TORCHLIGHT             = "../Data/Textures/GAME/SOB/TorchLight_V0.dds";
        static private string PATH_BRIDGE                 = "../Data/Textures/GAME/SOB/bridge_V0.dds";
        static private string PATH_BRIDGE_ENDL            = "../Data/Textures/GAME/SOB/bridge_endL_V0.dds";
        static private string PATH_BRIDGE_ENDR            = "../Data/Textures/GAME/SOB/bridge_endR_V0.dds";
        static private string PATH_BRIDGEDESTROYED        = "../Data/Textures/GAME/SOB/Bridge_Destroyed_V0.dds";
        static private string PATH_BOARDEDDOORS           = "../Data/Textures/GAME/SOB/BoardedUpDoors_V0.dds";
        static private string PATH_BOARDEDDOORSDESTROYED  = "../Data/Textures/GAME/SOB/BoardedUpDoors_Destroyed_V0.dds";

        //theese static's are public cause PowerUP class need them to recognize which kind of powerUP is being created                                          
        static public string PATH_PU_COOKIE              = "../Data/Textures/GAME/SOB/Cookie_V0.dds";
        static public string PATH_PU_POWERPILL           = "../Data/Textures/GAME/SOB/PowerPill_A0.dds";
        static public string PATH_PU_LIFE                = "../Data/Textures/GAME/SOB/Life_A0.dds";
        static public string PATH_PU_SKILLPOINT               = "../Data/Textures/GAME/SOB/STAR_A0.dds";
        static public string PATH_PU_ENEMYSLOWER         = "../Data/Textures/GAME/SOB/TIME_SLOW.dds";
        static public string PATH_PU_BOMB                = "../Data/Textures/GAME/SOB/Bomb.dds";

        //others
        static public string PATH_BOMBDECAY = "../Data/Textures/GAME/FX/Bomb_Exploded.dds";

        #endregion
        #region Colours Constants
        // POWER-UPs:
        // R0 G(1-40) B0 - Cookie
        // R0 G(41-60) B0 - Power pill
        // R0 G(61-70) B0 - Bomb
        // R0 G(71-80) B0 - EnemySlower
        // R0 G(81-90) B0 - Live
        // R0 G(91-100) B0 - Skill Point

        // Enemies: R0 G0 B(1-126)
        // NORMAL 1-40
        // WIZARD 41-60
        // THIEF 61-80
        // SHOOP 81-100
        // ASSASSIN 101-120

        // Misc:
        // BRIDGE: R0G0B192
        // (WiP)BARRICADE R192G0B192
        //Color Flags:
        static private UInt32 CFLAG_COLLIDE = 0x00C00000;//red = 192
        static private UInt32 CFLAG_LIGHTEMITING = 0x0000C000;//green = 192
        static private UInt32 CFLAG_DESTROYABLE = 0x000000C0;//blue = 192

        //Range Flags:
        // Power up: 127,(128-192),255,255
        static private UInt32 COLOR_POWERUP_BASE = 0xFF000100;//255=a,0,1,0
        static private UInt32 COLOR_POWERUP_RANGE = 0x0000FF00;//(Green)
        static private UInt32 COLOR_POWERUP_MIN = 1;
        static private UInt32 COLOR_POWERUP_MAX = 126;

        // Enemies: R0 G0 B(1-126) A255
        static private UInt32 COLOR_ENEMY_BASE = 0xFF000001;//,255=a,0,0,1
        static private UInt32 COLOR_ENEMY_RANGE = 0x000000FF;//(Blue)
        static private UInt32 COLOR_ENEMY_MIN = 1;
        static private UInt32 COLOR_ENEMY_MAX = 126;

        // Portals: 127,(128-192),(128-192),255
        static private UInt32 COLOR_PORTAL_BASE = 0xFF008080;//127,0,1,1
        static private UInt32 COLOR_PORTAL_RANGE = 0x0000FF00;//(Green)
        static private UInt32 COLOR_PORTAL_RANGE2 = 0x000000FF;//(,Blue)
        static private UInt32 COLOR_PORTAL_MIN = 128;//Ranges of both color must be the same!!
        static private UInt32 COLOR_PORTAL_MAX = 192;

        //Specific Colors:(test last, don't let it intersect with flags, etc
        //Player
        static private UInt32 COLOR_PLAYER = 0xFFFFFFFF;//white
        static private UInt32 COLOR_CLIFF = 0xFF808080;//gray 50%
        static private UInt32 COLOR_DARKNESS = 0xFF000000;//black 
        static private UInt32 COLOR_NOTHING = 0xFFBFBFBF;//
        #endregion


        internal void tryDestroyObject(int x, int y)
        {
            //new DebugMsg("tryDestroy:(" + x.ToString() + ":" + y.ToString() + ")", DebugLVL.info);
            //object is a bridge:
            if (getObjTypeFromPixel(x, y) == (objType.DESTROYABLE | objType.DARKNESS))
            {
                Color oldCol = _interpretationMap.GetPixel(x, y);
                Color newColor = Color.FromArgb(oldCol.A,192, oldCol.G, oldCol.B);
                _interpretationMap.SetPixel(x, y, newColor);
                Obj bridge = getPathAt(x, y);
                if (bridge != null)
                {
                    bridge.setDestroyed();
                }               
            }
        }

        private Obj getPathAt(int x, int y)
        {
            int grid = GameManager.gridSize;
            if(paths==null) return null;

            // podany gridPos wykracza poza indeksy obecnej tablicy paths:
            if (x > paths.GetUpperBound(0) || y > paths.GetUpperBound(1))
                return null;
            return paths[x, y];
        }

        internal void addBombDecay(int x, int y)
        {
            Obj decay = new Obj(PATH_BOMBDECAY, x, y, Obj.align.LEFT);
            decay.width *=2; decay.height *=2;
            decay.x -= decay.width / 2; decay.y -= decay.height / 2;
            // TODO: sth with that! Like.. creating another on array? List should be ok too...
            // paths.Add(decay);
            
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using EngineApp;
using QuickFont;

namespace CookieMonster.CookieMonster_Objects
{
    class GUI
    {
        QFont guiFont = TextManager.newQFont("Rumpelstiltskin.ttf", 25);
        QFont livesFont = TextManager.newQFont("Rumpelstiltskin.ttf", 30);
        QFont controllsFont = TextManager.newQFont("KOMIKAX.ttf", 25,true);
        Obj background;
        List<Obj> PUBackgrounds;
        List<Obj> SkillsBackgrounds;
        Obj PUBomb; Obj PUTimeSlow;
        Obj SkillBoost; Obj SkillIceBolt;
        Obj DisabledSkillBoost; Obj DisabledSkillIceBolt;

        Obj lives;
        Text powerUpTxt;
        Text SkillsTxt;
        Text Points;
        List<Text> PUControllLetters;
        List<Text> SkillsControllLetters;

        Obj enterButtonToNextLevel;
        public GUI()
        {
            const int textFromDownLine = 70;
            const int textKeyHints = 85;
            Viewport act = Game.self.activeViewport;
            TextManager txtMan = Game.self.textMenager;
            double y_bg = 0.8575;
            double y_obj = 0.90;
            background = new Obj("../data/Textures/GAME/GUI/BG.dds", 0.5, y_bg, Obj.align.CENTER_X);
            background.isGUIObject = true;//so it won't move with camera

            livesFont.Options.Colour = new OpenTK.Graphics.Color4(200,  230, 250, 255);
            //Power ups:
            PUBackgrounds = new List<Obj>();
            Obj tmp = new Obj("../data/Textures/GAME/GUI/GUI_PU_BG.dds", 0.1565, y_obj, Obj.align.CENTER_X, false);
            tmp.isGUIObjectButUnscaled = true;
            PUBackgrounds.Add(tmp);
            tmp = new Obj("../data/Textures/GAME/GUI/GUI_PU_BG.dds", 0.2175, y_obj, Obj.align.CENTER_X, false);
            tmp.isGUIObjectButUnscaled = true;
            PUBackgrounds.Add(tmp);


            PUBomb = new Obj("../data/Textures/GAME/SOB/Bomb.dds", 0.1565, y_obj, Obj.align.CENTER_X, false);
            PUBomb.isGUIObjectButUnscaled = true;
            PUTimeSlow = new Obj("../data/Textures/GAME/SOB/TIME_SLOW.dds", 0.2175, y_obj, Obj.align.CENTER_X, false);
            PUTimeSlow.isGUIObjectButUnscaled = true;
            lives = new Obj("../data/Textures/GAME/GUI/LIVE.dds", 0.18, 0.935, Obj.align.CENTER_X, false);
            lives.isGUIObjectButUnscaled = true;

            powerUpTxt = txtMan.produceText(guiFont, Lang.cur.Dopalacze, 28, (float)(act.height - textFromDownLine));
            PUControllLetters = new List<Text>();
            controllsFont.Options.Colour = new OpenTK.Graphics.Color4(255,255,255,192);
            PUControllLetters.Add(txtMan.produceText(controllsFont, "Z", 187, (float)(act.height - textKeyHints)));
            PUControllLetters.Add(txtMan.produceText(controllsFont, "X", 265, (float)(act.height - textKeyHints)));


            SkillsBackgrounds = new List<Obj>();
            tmp = new Obj("../data/Textures/GAME/GUI/GUI_SKILL_BG.dds", 0.895, y_obj, Obj.align.CENTER_X, false);
            tmp.isGUIObjectButUnscaled = true;
            SkillsBackgrounds.Add(tmp);
            tmp = new Obj("../data/Textures/GAME/GUI/GUI_SKILL_BG.dds", 0.955, y_obj, Obj.align.CENTER_X, false);
            tmp.isGUIObjectButUnscaled = true;
            SkillsBackgrounds.Add(tmp);
            SkillsTxt = txtMan.produceText(guiFont, Lang.cur.umiejetnosci, act.width - 335, (float)(act.height - textFromDownLine));
            SkillsControllLetters = new List<Text>();
            SkillsControllLetters.Add(txtMan.produceText(controllsFont, "C", act.width - 148, (float)(act.height - textKeyHints)));
            SkillsControllLetters.Add(txtMan.produceText(controllsFont, "V", act.width - 72, (float)(act.height - textKeyHints)));

            SkillBoost = new Obj("../data/Textures/GAME/SKILLS/SKILL_BOOST.dds", 0.895, y_obj, Obj.align.CENTER_X, false);
            SkillBoost.isGUIObjectButUnscaled = true;
            SkillIceBolt = new Obj("../data/Textures/GAME/SKILLS/SKILL_ICEBOLT.dds", 0.955, y_obj, Obj.align.CENTER_X, true);
            SkillIceBolt.isGUIObjectButUnscaled = true;

            DisabledSkillBoost = new Obj("../data/Textures/GAME/SKILLS/SKILL_BOOST_DISABLED.dds", 0.895, y_obj, Obj.align.CENTER_X, true);
            DisabledSkillBoost.isGUIObjectButUnscaled = true;
            DisabledSkillIceBolt = new Obj("../data/Textures/GAME/SKILLS/SKILL_ICEBOLT_DISABLED.dds", 0.955, y_obj, Obj.align.CENTER_X, true);
            DisabledSkillIceBolt.isGUIObjectButUnscaled = true;

            Points = txtMan.produceText(guiFont, Lang.cur.punkty_0, act.width / 2 - 310, (float)(act.height - textFromDownLine));

            enterButtonToNextLevel = new Obj("../data/Textures/GAME/GUI/enter_button.dds", 0.5, 0.0, Obj.align.CENTER_X, true);
        }
        public void Render()
        {
            GameManager gm = Game.self.gameManager;
            double y_obj = 0.90;
            background.Render();
            for (int i = 0; i < PUBackgrounds.Count; i++)
                PUBackgrounds[i].Render();
            for (int i = 0; i < SkillsBackgrounds.Count; i++)
                SkillsBackgrounds[i].Render();
            powerUpTxt.Print();
            SkillsTxt.Print();

            //Print powerUps tiles:
            if ((gm.PC.powerUpsInventory & POWER_UP.BOMB) == POWER_UP.BOMB)//hero has bomb:
                PUBomb.Render();
            if ((gm.PC.powerUpsInventory & POWER_UP.ENEMY_SLOWER) == POWER_UP.ENEMY_SLOWER)
                PUTimeSlow.Render();

            //print skills:

            if (gm.PC.hasSkill(Skill.skillNames.Boost) != null)
            {
                Skill boost = gm.PC.hasSkill(Skill.skillNames.Boost);
                if (boost.cooldownTimer.enabled)
                {
                    double part = 1.0 - (boost.cooldownTimer.currentTime / (double)boost.cooldownTimer.totalTime);
                    part = Math.Max(0f,Math.Min(0.99f,Math.Round(part, 2)));// 100% safe etc. :P
                    part *= 100;
                    int p = (int)part;
                    Obj tmp = new Obj("../data/Textures/GAME/GUI/SKILL_REFRESHING_" + p + ".dds", 0.895, y_obj, Obj.align.CENTER_X, false);
                    tmp.isGUIObjectButUnscaled = true;
                    /*tmp.setRenderOnce();*/ tmp.Render();
                    DisabledSkillBoost.Render();
                }
                else
                    SkillBoost.Render();
            }
            else
                DisabledSkillBoost.Render();

            if (gm.PC.hasSkill(Skill.skillNames.IceBolt) != null)
            {
                Skill iceBolt = gm.PC.hasSkill(Skill.skillNames.IceBolt);
                if (iceBolt.cooldownTimer.enabled)
                {
                    double part = 1.0 - (iceBolt.cooldownTimer.currentTime / (double)iceBolt.cooldownTimer.totalTime);
                    part = Math.Max(0f, Math.Min(0.99f, Math.Round(part, 2)));// 100% safe etc. :P
                    part *= 100;
                    int p = (int)part;
                    if (p > 99) p = 99; else if (p < 0) p = 0;
                    Obj tmp = new Obj("../data/Textures/GAME/GUI/SKILL_REFRESHING_" + p + ".dds", 0.955, y_obj, Obj.align.CENTER_X, false);
                    tmp.isGUIObjectButUnscaled = true;
                    /*tmp.setRenderOnce(); */tmp.Render();
                    DisabledSkillIceBolt.Render();
                }
                else
                    SkillIceBolt.Render();
            }
            else
                DisabledSkillIceBolt.Render();

           
            for (int i = 0; i < PUControllLetters.Count; i++)
                PUControllLetters[i].Print();
            for (int i = 0; i < SkillsControllLetters.Count; i++)
                SkillsControllLetters[i].Print();

            //Lives:
            const int maxLives = 5;
            int l; int startX = (int)(600.0 / (double)Viewport.guiBase_width * gm.activeView.width); 
            int stepX = 50;
            for (l = 0; ((l + 1 < gm.PC.lives)&&(l<maxLives)); l++)
            {
                lives.x = startX + l * stepX;
                lives.Render();
            }
            if (gm.PC.lives - l - 1 > 1)
            {
                TextManager txtMan = Game.self.textMenager;
                Viewport act = Game.self.activeViewport;
                Text restLives = txtMan.produceText(livesFont, "+" + (gm.PC.lives - maxLives - 2).ToString(), (float)(startX + 10 + l * stepX), (float)(act.height - 70));
                restLives.Print();
            }

            Points.msg = Lang.cur.punkty + Game.self.gameManager.statistics.lvlPoints.ToString() + " / " + (Game.self.gameManager.Map.cookiesCount * Statistics.ptsPerCookie).ToString();
            Points.Print();

            if (Game.self.gameManager.canStartNextLevel)
            {
                enterButtonToNextLevel.Render();
            }
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;
using System.Drawing;

namespace CookieMonster.CookieMonster_Objects
{
    /// <summary>
    /// MOB... Moveable OBject
    /// </summary>
    class MOB
    {
        #region fields
        static public GameManager GameMan;

        public enum eMOBType { MOB, POWERUP, ENEMY, PLAYER, PROJECTILE }
        private eMOBType _mobType = eMOBType.MOB;
        public eMOBType mobType { get { return _mobType; } set { if (_mobType == eMOBType.MOB)_mobType = value; } }
        //movement stuff:
        public enum eDir
        { L, R, U, D, UNDEF };
        public eDir dirBuffer;//keystorke is first inserted into buffer, when mob is on ideal grid pos then dir is set to dirBuffer
        private eDir dir;
        public bool mobMirrored { get; private set; }
        public eDir direction
        {
            set
            {
            if (dir == value) return; //same key as previous? do nothing!
            //if ((((value == eDir.L) || (value == eDir.D)) && ((dir == eDir.R) || (dir == eDir.R)))
            //|| (((dir == eDir.L) || (dir == eDir.D)) && ((value == eDir.R) || (value == eDir.R))))
            if (((value == eDir.L) && (!mobMirrored)) || ((value == eDir.R) && (mobMirrored)))
            {
                mobMirrored = !mobMirrored;
                if (visualDefault != null)
                {
                    for (int i = 0; i < visuals.Count; i++)
                    {
                        visuals[i].width *= -1;
                    }
                        posX -= currentVisual.width;//(int)(visualDefault.width * 4.8);
                    
                }
            }
            if ( (movingHorizontal && ((value == eDir.L) || (value == eDir.R)))
            ||   (movingVertical   && ((value == eDir.U) || (value == eDir.D))) )
            { 
                Waypoint wp = nextWP; 
                nextWP = lastWP; 
                lastWP = wp; 
                if ((wp!=null)&&(lastWP == null))lastWP = wp.getWPAtDirection(inverseDirection(value)); 
            }
            dir = value;
            }
            get  {  return dir;  }
        }
        public bool movingHorizontal { get { return (dir == eDir.L) || (dir == eDir.R); } }
        public bool movingVertical { get { return !movingHorizontal; } }
        private Timer moveGap;//in ms
        public int   pxMove {get; private set;}
        public double baseSpeed { get; private set; }//value will be set when object being constructed 
        private double _speed;
        public double speed
        {//in pixels per second:
         // finding proper value by:
         // 1 timer dur: 20-50(ms) per "move" frame
         // 2 px per "move" frame: 1..n
            get { return _speed; }
            set
            {
                _speed = value;
                double px_Move = pxMove;
                if (value == 0.0) { px_Move = 0; moveGap = new Timer(Timer.eUnits.MSEC, 100000, 0, false, false); return; } 
                double ms_min = 20.0; double ms_max = 1000.00;
                for (px_Move = 1; px_Move * (1000.0 / 50.0) <= value; px_Move++) ;
                //pxMove--;//pxMove founded, now timer interlace
                double step = ms_max-ms_min;
                step/=2.0;
                while(step>1.0)
                {
                    if (1000.0 / (ms_min + step) / px_Move < value)
                        ms_max -= step;
                    else
                        ms_min += step;
                    step /= 2.0;
                }
                if (moveGap != null) moveGap.Dispose();
                moveGap = new Timer(Timer.eUnits.MSEC, (int)ms_max,0,true,false);
                moveGap.start();
                pxMove = (int)px_Move;
            }
        }
        
        private int posX,posY;//in pixels, on screen

        // collision stuff:
        private Rectangle bbox;//bounding box of MOB -> for intersecting with map collision
        public Rectangle boundingBox { get { return bbox; } }
        private CollisionReport _myCollision; 

        //Waynet stuff:
        public Waypoint currentWP { get; private set; } // it's not null only when enemy is EXACTLY on wp pos
        public Waypoint lastWP { get; private set; } // last currentWP
        public Waypoint nextWP { get; private set; } // wp readed from lastWP.Way(in direciton of MOB is heading)

        //TODO: temporary stuff, remove when not needed
        public int lastWPid { get { if (lastWP != null)return lastWP._id; else return -1; } }
        public int nxtWPid { get { if (nextWP != null)return nextWP._id; else return -1; } }

        private List<Obj> visuals = new List<Obj>();//list of created visuals
        private Obj visualDefault;//moving
        private Obj visualIdle; //stand?(it's even possible?) or blocked by obstacles
        private Obj visualAttack;//near player(enemy) or about to eat cookie (player)
        private Obj visualHurt;// hmmm...
        private Obj visualFrozen;

        public enum eState { DEFAULT, IDLE, ATTACK, HURT, FROZEN };
        private eState _state;
        public eState state { set { _state = value; currentVisual.setTexAniFrame(0); } get { return _state; } }
        public bool isOnGrid { get; private set; }
        public bool invincible { get; private set; }
        private Timer freezeTimer = new Timer(Timer.eUnits.MSEC, (10 * 1000), 0, true, false);
        private Obj iceCubeVisual = new Obj("../data/Textures/GAME/SOB/icecube.dds", 0, 0, Obj.align.CENTER_BOTH);
        public bool isFrozen { get { return state == eState.FROZEN; } }
        private Light attachedLight;
        #endregion

        #region properties
        public CollisionReport myCollision
        {
            get
            {
                return _myCollision;
            }
            set
            {
                if (_myCollision == null)//it can be set only once
                    _myCollision = value;
            }
        }
        public Obj currentVisual
        {
            get
            {
                Obj ret = visualDefault;
                if ((state == eState.IDLE) && (visualIdle != null))
                    ret = visualIdle;
                else if ((state == eState.ATTACK) && (visualAttack != null))
                    ret = visualAttack;
                else if ((state == eState.HURT) && (visualHurt != null))
                    ret = visualHurt;
                else if ((state == eState.FROZEN) && (visualFrozen != null))
                    ret = visualFrozen;
                return ret;
            }
        }
        public int pX
        {
            get
            {
                if (!mobMirrored)
                    return posX;
                else
                return posX + currentVisual.width;
            }
            private set
            {
                if (!mobMirrored)
                    posX = value;
                else
                    posX = value - currentVisual.width;
            }
        }
        public int pY
        {
            get { return posY; }
        }
        /// <summary>
        /// returns on grid X position of MOB
        /// </summary>
        public int gridX
        {
            get
            {
                if (direction == eDir.R)
                    return pX / GameManager.gridSize;
                else
                    return (pX) / GameManager.gridSize;
                    // return (pX + GameManager.gridSize/2+1) / GameManager.gridSize;
            }
        }
        /// <summary>
        /// returns on grid Y position of MOB
        /// </summary>
        public int gridY
        {
            get 
            {
                if (direction == eDir.U)
                    return (pY) / GameManager.gridSize;
                else
                    return (pY) / GameManager.gridSize;
            }
        }
        /// <summary>
        /// return's next predicted grid X pos
        /// </summary>
        public int nextGridX
        {
            get
            {
                int grid = GameManager.gridSize;
                
                if (dir == eDir.R)
                    return (pX + pxMove + GameManager.gridSize) / GameManager.gridSize;
                else if (dir == eDir.L)
                    return (pX - pxMove) / GameManager.gridSize;
                else
                    return gridX;
            }
        }
        /// <summary>
        /// return's next predicted grid Y pos
        /// </summary>
        public int nextGridY
        {
            get
            {
                if (dir == eDir.U)
                    return (pY - pxMove) / GameManager.gridSize;
                else if (dir == eDir.D)
                    return (pY + pxMove + GameManager.gridSize) / GameManager.gridSize;
                else
                    return gridY;
            }
        }
        #endregion

        public MOB(int posx, int posy, double spd)
        {
            mobMirrored = false;
            direction = eDir.R;//by default
            posX = posx; posY = posy;
            pxMove = 1;
            baseSpeed = speed = spd;
            mobType = eMOBType.MOB;//value will be overwritten if object only inherits from MOB
        }
        /// <summary>
        /// this method should be called when all objects creations ended
        /// especially waynet is fully generated cause it sets last/nextWP proper values
        /// </summary>
        public void Initialize()
        {
            if (!GameMan.Map.waynetActive) return; 

            lastWP = currentWP = GameMan.Map.wayNetwork.getWPAt((uint)gridX, (uint)gridY);
            if (lastWP != null)
            {
                nextWP = lastWP.getWPAtDirection(direction);
                if (nextWP == null) nextWP = lastWP;
            }

        }
        /// <summary>
        /// handled states:
        /// "DEFAULT" "IDLE" "ATTACK" "RUNAWAY" (new 21:50 2012-08-12)"FROZEN"
        /// (case insensitive)
        /// </summary>
        /// <param name="vis"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        public void setStateVisual(Obj vis, string type)
        {
            string typ = type.ToUpper();
            visuals.Add(vis);
            switch (typ)
            {
                case "IDLE":
                    visualIdle = vis; break;
                case "ATTACK":
                    visualAttack = vis; break;
                case "HURT":
                    visualHurt = vis; break;
                case "FROZEN":
                    visualFrozen = vis; break;
                default:
                    visualDefault = vis; break;
            }
        }

        internal void Render()
        {
           currentVisual.x = posX; currentVisual.y = posY;
           currentVisual.Render();

            //Freeze FX:
           if (state == eState.FROZEN)
           {
               iceCubeVisual.x = pX; iceCubeVisual.y = pY;
               iceCubeVisual.Render();
           }

            //Teleport FX:
           if (isIgnitOfCurrentTeleportFX)
               if (!GameMan.teleportFX.texAniFinished())
                   GameMan.teleportFX.Render();
               else
                   isIgnitOfCurrentTeleportFX = false;
        }
        private bool lastCollsionStatic;
        public void Update()
        {            
            //for cookies eating
            updateTakenPowerUP();
            if (state == eState.FROZEN)
            {
                if (freezeTimer.enabled == false)
                {
                    state = eState.DEFAULT;
                }
                return;
            }
            //check if its time to change dir (MOB is ideally on grid)
            if (speed == 0.0) return; //no movement, no update
            int grid = GameManager.gridSize;
            int x = posX, y = posY;
            
            // if player want to inverse direction: just do it even if mob isn't on grid point:            
            if(moveGap.enabled==false)//timer ended, next move
            {
                checkDirection();
                moveGap.start();
                updateBoundingBox();
                //speed = speed;//reinit timer ??? not sure if it will work
                if (myCollision!=null && myCollision.collisionStatic == true)
                { //in collision with static obj! don't move!
                    if (lastCollsionStatic == false)//I just hit wall
                    {
                        if (state != eState.ATTACK)
                            state = eState.IDLE;
                        //make move (snap to grid)
                        if(movingHorizontal)
                            Move(pxMove - ((pX + pxMove) % GameManager.gridSize), 0,false);
                        else //if (dir == eDir.D)
                            Move(0,pxMove - ((pY + pxMove) % GameManager.gridSize),false);

                    }
                    lastCollsionStatic = myCollision.collisionStatic;
                    return;
                }
                else if(state == eState.IDLE)
                    state = eState.DEFAULT;
                if (direction == eDir.R)
                        Move(pxMove, 0);
                else if (direction == eDir.L)
                        Move(-pxMove, 0);
                else if (direction == eDir.U)
                        Move(0, -pxMove);
                else if (direction == eDir.D)
                        Move(0, pxMove);

                if(myCollision!=null)
                    lastCollsionStatic = myCollision.collisionStatic;

                //Waypoint's stuff
                if (!GameMan.Map.waynetActive) return;
                Waypoint wp;
                wp = GameMan.Map.wayNetwork.getWPAt((uint)gridX, (uint)gridY);
                currentWP = wp; // do it, even if wp is null
                if (currentWP != null)
                { //MOB reached new wp:
                    lastWP = currentWP;
                    //enemy part
                    //direction = chaseRoute.Pop();
                    nextWP = lastWP.getWPAtDirection(direction);
                }
            }
        }
        public void Move(int _x, int _y)
        {
            Move(_x, _y, true);
        }
        public void Move(int _x, int _y,bool snapToGrid)
        {
            int grid = GameManager.gridSize;
            int oldX = posX, oldY = posY;
            if(snapToGrid)
            {
                if (movingHorizontal)
                    snapToGridX(_x);
                if (movingVertical)
                    snapToGridY(_y);  
            }
            else
            {
                posX+=_x; posY+=_y;
            }
            
            if ((pX % grid == 0) && (pY % grid == 0))
                isOnGrid = true;
            else
                isOnGrid = false;
            
            currentVisual.x = posX;
            currentVisual.y = posY;

            //Move attached light:
            if (attachedLight!=null)
            {
                attachedLight.move(new OpenTK.Vector2(posX-oldX,posY-oldY));
            };
        }

        private void snapToGridY(int _y)
        {
            int grid = GameManager.gridSize;
            if ((direction == eDir.D) && ((posY % grid) > ((posY + _y) % grid)))
                posY = (posY + _y) - ((posY + _y) % grid);
            else if ((direction == eDir.U) && (posY % grid != 0) && ((posY % grid) < ((posY + _y) % grid)))
                posY = (posY + _y) + grid - ((posY + _y) % grid);
            else
                posY += _y;
        }
        private void snapToGridX(int _x)
        {
            int grid = GameManager.gridSize;
            if ((direction == eDir.R) && (posX % grid > (posX + _x) % grid))
                posX = (posX + _x) - ((posX + _x) % grid);
            else if ((direction == eDir.L) && (pX % grid != 0) && (pX % grid < (pX + _x) % grid))
            {
                pX = (pX + _x) + (grid-((pX + _x) % grid));
            }
            else
                posX += _x;
        }

        private void checkDirection()
        {
            // direction will change in the same orientation -> then just do it and don't care 'bout nothing
            if (((dirBuffer == eDir.L) && (direction == eDir.R)) || ((direction == eDir.L) && (dirBuffer == eDir.R))
            || ((dirBuffer == eDir.U) && (direction == eDir.D)) || ((direction == eDir.U) && (dirBuffer == eDir.D)))
            {
                direction = dirBuffer;
            }
            // MOB is on grid pos -> we trying to change direction
            if (GameMan.Map.waynetActive)
            {
                Waypoint wp = Waypoint.wnet.getWPAt((uint)gridX, (uint)gridY);
                if ((direction != dirBuffer) && (isOnGrid) && wp != null)
                {
                    // mob it's on grid, now check if grid on direction which he want to head
                    // is not collideable
                    eDir oldDir = direction;
                    direction = dirBuffer;
                    int grid = GameManager.gridSize;

                    if ((direction == eDir.D) && (wp.downWP == null)) direction = oldDir;
                    else if ((direction == eDir.L) && (wp.leftWP == null)) direction = oldDir;
                    else if ((direction == eDir.R) && (wp.rightWP == null)) direction = oldDir;
                    else if ((direction == eDir.U) && (wp.upWP == null)) direction = oldDir;

                }
            }
            else if (!GameMan.Map.waynetActive && isOnGrid && direction != dirBuffer)
            {
                    // mob it's on grid, now check if grid on direction which he want to head
                    // is not collideable
                    eDir oldDir = direction;
                    direction = dirBuffer;
                    myCollision.Update();
                    if (myCollision.collisionStatic)
                        direction = oldDir;
                    myCollision.Update();
            }
        }
        /// <summary>
        /// update BoundingBox by setting rectangle passed as
        /// the parameters.
        /// </summary>
        public void updateBoundingBox(int x, int y, int width, int height)
        {
            bbox = new Rectangle(x, y, width, height);
        }
        public void updateBoundingBox()
        {
            if (mobType == eMOBType.PROJECTILE)
            {
                Rectangle res;
                if (((Projectile)this).type == Projectile.eProjType.Lazer)
                {
                    res = new Rectangle(pX, pY, currentVisual.width, currentVisual.height);

                    if (res.Height < res.Width)
                    {
                        int h = res.Height;
                        res.Height -= h / 4;
                        res.Y += h / 4;
                    }
                    else
                    {
                        int w = res.Width;
                        res.Width -= w / 4;
                        res.X += w / 4;
                    }

                    bbox = res;
                }
            }
            else
            {
                Point startPt;
                int wLoss = currentVisual.width / 4, hLoss = currentVisual.height / 4 - 4;
                wLoss = Math.Abs(wLoss); // when MOB is mirrored it will be negative value
                int bboxWidth = GameManager.gridSize;
                if (currentVisual.width < bboxWidth) bboxWidth = Math.Abs(currentVisual.width);
                else wLoss = bboxWidth / 4;

                int bboxHeight = GameManager.gridSize;
                if (currentVisual.height < bboxHeight) bboxHeight = currentVisual.height;
                else hLoss = bboxHeight / 3 - 4;
                //if (currentVisual.width>0)
                //    startPt = new Point(pX - GameManager.gridSize, pY);
                //else
                startPt = new Point(pX, pY);
                //Obj gridPos = new Obj("../data/Textures/HLP_GRID.dds", startPt.X + wLoss, startPt.Y + hLoss, Obj.align.LEFT);
                //gridPos.width = Math.Abs(bboxWidth) - (2 * wLoss);
                //gridPos.height = bboxHeight - (2 * hLoss);
                //gridPos.setRenderOnce();
                //gridPos.setCurrentTexAlpha(190);
                bbox = new Rectangle(startPt.X + wLoss, startPt.Y + hLoss, Math.Abs(bboxWidth) - (2 * wLoss), bboxHeight - (2 * hLoss));
            }  
        }
        private PowerUp takenPowerUP; private int cookieEatenHoldFrames;
        public void eatCookie(PowerUp cookie)
        {
            if (takenPowerUP == cookie) return;
            //another cookie still eaten, speed it up
            if(takenPowerUP!=null)
                if (takenPowerUP.type == POWER_UP.COOKIE)
                {
                    GameMan.removePowerUp(takenPowerUP);
                    state = eState.DEFAULT;
                    takenPowerUP = null;
                }
            state = eState.ATTACK;
            currentVisual.restartTexAni();
            cookieEatenHoldFrames = 1;
            takenPowerUP = cookie;
            Sound cookieVaccum;
            int rnd = GameManager.variantizer.Next(20);
            if(rnd < 9)
                cookieVaccum = new Sound(Sound.eSndType.SFX, "../data/Sounds/COOKIE_EAT1.ogg", false, false,0.33);
            else if(rnd < 18)
                cookieVaccum = new Sound(Sound.eSndType.SFX, "../data/Sounds/COOKIE_EAT2.ogg", false, false,0.33);
            else if (rnd < 19)
                cookieVaccum = new Sound(Sound.eSndType.SFX, "../data/Sounds/COOKIE_EAT3.ogg", false, false,0.95);
            else
                cookieVaccum = new Sound(Sound.eSndType.SFX, "../data/Sounds/COOKIE_EAT4.ogg", false, false,0.7);

            cookieVaccum.Play();
            GameMan.statistics.addEatenCookies(1);
            GameMan.removePowerUp(takenPowerUP);
        }
        private void updateTakenPowerUP()
        {
            if (takenPowerUP == null) return;
            //cookie:
            if (takenPowerUP.type == POWER_UP.COOKIE)
            {
                if (currentVisual.texAniFinished())
                {
                    if (cookieEatenHoldFrames > 0) cookieEatenHoldFrames--;
                    else
                    {
                        //GameMan.removePowerUp(takenPowerUP);
                        state = eState.DEFAULT;
                        takenPowerUP = null;
                    }
                }
                //else if (state != eState.ATTACK)//something strange occured, but still we need to remove cookie:
                //{
                //    new DebugMsg("state was changed during eating cookie\n but still disposing cookie from map...", DebugLVL.warn);
                //   GameMan.removePowerUp(takenPowerUP);
                //    takenPowerUP = null;
                //}
            }
        }

        private bool isIgnitOfCurrentTeleportFX;
        public void Teleport(Obj dst)
        {

            Point dstPt = GameManager.getObjGridPos(dst);
            int sizeDiff = Math.Abs(currentVisual.width) - GameManager.gridSize;
            posX = (dstPt.X + 1) * GameManager.gridSize + sizeDiff;
            if (!mobMirrored)
                posX -= currentVisual.width;

            posY = dstPt.Y * GameManager.gridSize;

            new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_TELEPORT.ogg", false, true);
            //FX:
            GameMan.ReinitTeleportFX((int)(dst.x - GameManager.gridSize * 2.25), (int)(dst.y - GameManager.gridSize * 2.25));
            isIgnitOfCurrentTeleportFX = true;
        }

        public eDir inverseDirection(MOB.eDir dir)
        {
            if (dir == eDir.L) return eDir.R;
            if (dir == eDir.R) return eDir.L;
            if (dir == eDir.D) return eDir.U;
            if (dir == eDir.U) return eDir.D;
            return eDir.UNDEF;
        }
        public void setSlow()
        {
            const int SLOW_TIME_MULTIPILER = 7;//7x slower movement? ugh i think so
            moveGap = new Timer(Timer.eUnits.MSEC, (int)moveGap.totalTime * SLOW_TIME_MULTIPILER, 0, true, false);
            moveGap.start();
        }
        public virtual void setFreeze()
        {
            iceCubeVisual.setCurrentTexAlpha(180);
            state = eState.FROZEN;
            freezeTimer.restart();
        }
        public void resetMovementSpeed()
        {
            speed = baseSpeed;
        }
        public void icreaseBaseSpeed(int val)
        {
            baseSpeed += val;
        }

        public virtual void Kill()
        {
            throw new NotImplementedException();
        }
        public void attachLight(Light light)
        {
            if(attachedLight!=null)new DebugMsg("WARN: There is already some light attached to this mob!");
            attachedLight = light;
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;
using EngineApp;
using System.IO;
using QuickFont;
using System.Drawing;
using OpenTK.Graphics;

namespace CookieMonster.CookieMonster_Objects
{
    /// <summary>
    /// Class used for playing music, randoming next track, any slides, fades etc.
    /// it had to be inited only, rest will be handled by itself.
    /// </summary>
    class MusicPlayer
    {
        // evry day imma shufflin' ;D
        static Random shuffler = new Random((int)DateTime.Now.Ticks & 0x0000FFFF);
        const string tracksFolder = "../data/Music/";
        const string trackInfosBG = "../data/Textures/MENU/TRACK_BG.dds";
        QFont trackTag_Font = TextManager.newQFont("KOMIKAX.ttf", 20, System.Drawing.FontStyle.Regular, true);
        String curTrackPath;
        Sound currentMusic;
        string curTrackTitle, curTrackArtist;
        Viewport playerViewport;
        Timer trackTagsDisplayDuration;
        public MusicPlayer()
        {
            Color4 cc = new Color4(73, 160, 255, 255);
            trackTag_Font.Options.Colour = cc;
            playerViewport = new Viewport(Game.self.activeViewport.width, Game.self.activeViewport.height,true);
            playerViewport.partialViewport = true; // it will prevent viewport from rendering game map, texts etc.
            trackTagsDisplayDuration = new Timer(Timer.eUnits.MSEC, 7000, 0, true, false);
            curTrackPath = randomTrackName();
            playTrack();
        }
        public void Update()
        {
            //remove displayed track infos:
            if (trackTagsDisplayDuration.enabled == false)
            {
                TextManager txtMan = Game.self.textMenager;
                txtMan.removeText(curTrackArtist);
                txtMan.removeText(curTrackTitle);
            }
            if (currentMusic.state==Sound.eSoundState.STOP)
            {
                string oldPath = curTrackPath;
                for (int i = 0; ((i < 5) && curTrackPath == oldPath); i++)
                    curTrackPath = randomTrackName();
                playTrack();
            }
            playerViewport.Update();
        }
        public void Render()
        {
          playerViewport.Render();
        }
        public void Free()
        {
            trackTagsDisplayDuration.Dispose();
            currentMusic.Free();
        }

        #region private methods
        private string randomTrackName()
        {
            string[] tracksOGG = Directory.GetFiles(tracksFolder, "*.ogg");
            string[] tracksMP3 = Directory.GetFiles(tracksFolder, "*.mp3");
            tracksMP3.CopyTo(tracksOGG,0);
            
            int n = shuffler.Next(tracksOGG.Length);
            return tracksOGG[n];
        }
        private void playTrack()
        {
            if (currentMusic != null)
                currentMusic.Free();
            currentMusic = new Sound(Sound.eSndType.MUSIC, curTrackPath, false, true);
            currentMusic.volume = 0.80;
            //filenames need to be in format of "ARTIST - TITLE" to be correctly displayed
            String filename = curTrackPath.Substring(curTrackPath.LastIndexOf("/") + 1);
            filename = filename.Substring(0, filename.LastIndexOf("."));
            
            curTrackArtist = filename.Substring(0, filename.LastIndexOf("-"));
            curTrackTitle  = filename.Substring(filename.LastIndexOf("-")+2);
            trackTagsDisplayDuration.start();
            putTrackInfosToViewport();
        }
        private void putTrackInfosToViewport()
        {
            int screenH = Game.self.activeViewport.height;
            //Obj bg = new Obj(trackInfosBG, 5, screenH-120, Obj.align.LEFT);
            //bg.isGUIObject = true;
            //bg.setCurrentTexAlpha(155);
            //playerViewport.addObject(bg);
            TextManager txtMan = Game.self.textMenager;
            //TODO: Uncoment this is temporary
            txtMan.addText(trackTag_Font, curTrackArtist, 50f, (float)screenH-110, QFontAlignment.Left);
            txtMan.addText(trackTag_Font, curTrackTitle, 50f, (float)screenH-80, QFontAlignment.Left);
        }
        #endregion
    }
}
using System;
using System.Collections.Generic;

using System.Text;
using System.Drawing;

namespace CookieMonster.CookieMonster_Objects
{
    class neighborReport
    {
        static public GameMap map;
        public GameMap.objType Up, Right, Down, Left;
        public bool U, R, D, L;//if true there is a way at this side
        public int ways;
        public bool dontCreatePath;
        public bool createWaypoint;
        public GameMap.objType checkedType;
        private int _x, _y; public int x { get { return _x; } }
                            public int y { get { return _y; } }
        public neighborReport(int x, int y)
            : this(x, y, GameMap.objType.COLLIDEABLE)
        {
            //collideable is threaten as default report type
        }
        public neighborReport(int x, int y, GameMap.objType reportedType)//x,y are grid(bitmap) pos!
        {
            _x = x; _y = y;
            Point pU = new Point(x, y - 1), pR = new Point(x + 1, y), pD, pL;
            dontCreatePath = false;
            ways = 0;
            int gs = GameManager.gridSize;
            Up = map.getObjTypeFromPixel(x, y - 1);
            Right = map.getObjTypeFromPixel(x + 1, y);
            Down = map.getObjTypeFromPixel(x, y + 1);
            Left = map.getObjTypeFromPixel(x - 1, y);
            if ((Up & reportedType) != reportedType)
            { U = true; ways++; }
            if ((Right & reportedType) != reportedType)
            { R = true; ways++; }
            if ((Down & reportedType) != reportedType)
            { D = true; ways++; }
            if ((Left & reportedType) != reportedType)
            { L = true; ways++; }

            // Create waypoint there?
            // bugfix: don't insert waypoint on portal pixels:
            if ((map.getObjTypeFromPixel(x, y) & GameMap.objType.PORTAL) == GameMap.objType.PORTAL)
                createWaypoint = false;
            else if ((ways == 2) && (((R == true) && (L == true)) || ((U == true) && (D == true))))
            {
                createWaypoint = false;
            }
            else
                createWaypoint = true;
            if (ways == 4)//check if there is nothing surrounding this pixel, if true, just don't create any path tex!
            {
                /* So we got X's:  O X O  We need "O"'s too, let's grab em
                 *                 X . X
                 *                 O X O 
                 */
                int additionalWays = 0;
                if ((map.getObjTypeFromPixel(x - 1, y - 1) & reportedType) != reportedType)
                    additionalWays++;
                if ((map.getObjTypeFromPixel(x + 1, y - 1) & reportedType) != reportedType)
                    additionalWays++;
                if ((map.getObjTypeFromPixel(x - 1, y + 1) & reportedType) != reportedType)
                    additionalWays++;
                if ((map.getObjTypeFromPixel(x + 1, y + 1) & reportedType) != reportedType)
                    additionalWays++;
                if (additionalWays > 0)
                    dontCreatePath = true;
            }
            else if (ways == 3)//need special threatment:
            {//we will check two point (laying between paths) what i mean by this:
                /* O X O  So we will check both O's if they're uncollidable
                 * X . X  we won't render path, elsewhere path need to be rendered
                 * - - -
                 */
                int pointsOk = 0;
                int px = -1, py = -1;
                if (R == true)
                    px = x + 1;
                if (U == true)
                    py = y - 1;
                if ((px != -1) && (py != -1))//already one point to chceck
                    if ((map.getObjTypeFromPixel(px, py) & reportedType) != reportedType)
                        pointsOk++;
                    else
                        return;//one of point's is collideable, futher checking is waste of CPU
                if (L == true)
                {
                    if (pointsOk == 1)//R was true too, one point already checked this will be second and last
                    {
                        px = x - 1;
                        if ((map.getObjTypeFromPixel(px, py) & reportedType) != reportedType)
                        { pointsOk++; dontCreatePath = true; }
                        else
                            return;//unfortunately secont point isn't uncollideable, but hey, we have new path :)
                    }
                    else///so U was false => D got2be true checking R & D and L & D then:
                    {
                        if (D == false) return; //safety is always welcome ;)
                        py = y + 1;
                        if ((map.getObjTypeFromPixel(px, py) & reportedType) != reportedType)
                            pointsOk++;
                        else
                            return;//one of point's is collideable, futher checking is waste of CPU
                        px = x - 1;
                        if ((map.getObjTypeFromPixel(px, py) & reportedType) != reportedType)
                        { pointsOk++; dontCreatePath = true; }
                        else
                            return;//unfortunately secont point isn't uncollideable, but hey, we have new path :)
                    }
                    if (pointsOk == 2) dontCreatePath = true;
                    return;
                }
                if (D == true)
                {// we are here so L was false,then R and U are true and checked, so right now 
                    // we need to make last check and see what we got here:
                    py = y + 1;
                    if ((map.getObjTypeFromPixel(px, py) & reportedType) != reportedType)
                    { pointsOk++; dontCreatePath = true; }
                    else
                        return;//unfortunately secont point isn't uncollideable, but hey, we have new path :)
                }
            }
            else if (ways == 2)//need special threatment:
            {//we will check only one point, but first we need to make sure which one ...
                int px = -1, py = -1;
                if (R == true)
                    px = x + 1;
                else if (L == true)
                    px = x - 1;
                if (U == true)
                    py = y - 1;
                else if (D == true)
                    py = y + 1;
                if ((px == -1) || (py == -1))
                    return;//it's an straight path not curved!!!
                if ((map.getObjTypeFromPixel(px, py) & reportedType) != reportedType)
                    dontCreatePath = true;
            }

        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;

namespace CookieMonster.CookieMonster_Objects
{

    //static class for generating proper Paths visuals:
    class Paths
    {
        static Obj[] OneWay = new Obj[4];
        static Obj[] TwoWayStraight = new Obj[4];
        static Obj[] TwoWayTurn = new Obj[4];
        static Obj[] ThreeWay = new Obj[4];
        public static Obj   FourWay;
        static void Initialize()
        {
            //One Way:
            /*L*/OneWay[0] = new Obj("../data/textures/GAME/PATHS/PATH_1_L.dds", 0, 0, Obj.align.CENTER_BOTH);
            /*U*/OneWay[1] = new Obj("../data/Textures/GAME/PATHS/PATH_1_L.dds", 0, 0, Obj.align.CENTER_BOTH);
                 OneWay[1].Rotate(90f);
            
            /*R*/OneWay[2] = new Obj("../data/Textures/GAME/PATHS/PATH_1_L.dds", 0, 0, Obj.align.CENTER_BOTH);
                 OneWay[2].Rotate(180f);

            /*D*/OneWay[3] = new Obj("../data/Textures/GAME/PATHS/PATH_1_L.dds", 0, 0, Obj.align.CENTER_BOTH);
                 OneWay[3].Rotate(270f);

            //Two ways:
            /*L*/TwoWayStraight[0] = new Obj("../data/Textures/GAME/PATHS/PATH_2_LR.dds", 0, 0, Obj.align.CENTER_BOTH);
            /*U*/TwoWayStraight[1] = new Obj("../data/Textures/GAME/PATHS/PATH_2_LR.dds", 0, 0, Obj.align.CENTER_BOTH);
                 TwoWayStraight[1].Rotate(90f);

            /*R*/TwoWayStraight[2] = new Obj("../data/Textures/GAME/PATHS/PATH_2_LR.dds", 0, 0, Obj.align.CENTER_BOTH);
                 TwoWayStraight[2].Rotate(180f);

            /*D*/TwoWayStraight[3] = new Obj("../data/Textures/GAME/PATHS/PATH_2_LR.dds", 0, 0, Obj.align.CENTER_BOTH);
                 TwoWayStraight[3].Rotate(270f);

            //Two ways with turn:
            /*L*/TwoWayTurn[0] = new Obj("../data/Textures/GAME/PATHS/PATH_2_LU.dds", 0, 0, Obj.align.CENTER_BOTH);
            /*U*/TwoWayTurn[1] = new Obj("../data/Textures/GAME/PATHS/PATH_2_LU.dds", 0, 0, Obj.align.CENTER_BOTH);
                 TwoWayTurn[1].Rotate(90f);

            /*R*/TwoWayTurn[2] = new Obj("../data/Textures/GAME/PATHS/PATH_2_LU.dds", 0, 0, Obj.align.CENTER_BOTH);
                 TwoWayTurn[2].Rotate(180f);

            /*D*/TwoWayTurn[3] = new Obj("../data/Textures/GAME/PATHS/PATH_2_LU.dds", 0, 0, Obj.align.CENTER_BOTH);
                 TwoWayTurn[3].Rotate(270f);
            
            //Three Ways
            /*L*/ThreeWay[0] = new Obj("../data/Textures/GAME/PATHS/PATH_3_LUR.dds", 0, 0, Obj.align.CENTER_BOTH);
            /*U*/ThreeWay[1] = new Obj("../data/Textures/GAME/PATHS/PATH_3_LUR.dds", 0, 0, Obj.align.CENTER_BOTH);
                 ThreeWay[1].Rotate(90f);

            /*R*/ThreeWay[2] = new Obj("../data/Textures/GAME/PATHS/PATH_3_LUR.dds", 0, 0, Obj.align.CENTER_BOTH);
                 ThreeWay[2].Rotate(180f);

            /*D*/ThreeWay[3] = new Obj("../data/Textures/GAME/PATHS/PATH_3_LUR.dds", 0, 0, Obj.align.CENTER_BOTH);
                 ThreeWay[3].Rotate(270f);

            //Four Ways (only one)
                 FourWay = new Obj("../data/Textures/GAME/PATHS/PATH_4_LURD.dds", 0, 0, Obj.align.CENTER_BOTH);
        } 
        static public Obj getPathVisual(neighborReport rep)
        {
            if (Paths.FourWay == null) Paths.Initialize();
            if (rep.dontCreatePath == true) return null;//dont create any path!
            string result = "../data/Textures/GAME/PATHS/PATH_";
            result += rep.ways.ToString()+"_";
            if (rep.L) result += "L";
            if (rep.U) result += "U";
            if (rep.R) result += "R";
            if (rep.D) result += "D";
            result += ".dds"; 
            //ok, filename generated, now it's time to apply rotations,etc.
            Obj o = null;
            if (rep.ways == 4)
                o = FourWay;
            else if (rep.ways == 3)
            {
                if (rep.L)
                    if (rep.U)
                        if (rep.R)
                            o = ThreeWay[0];
                        else
                            o = ThreeWay[3];
                    else
                        o = ThreeWay[2];
                else
                    o = ThreeWay[1];
            }
            else if (rep.ways == 2)
            {
                if (rep.L)
                {
                    if (rep.R)//todo: random? 0 and 3
                    { o = TwoWayStraight[0]; }
                    else
                        if (rep.U)
                            o = TwoWayTurn[0];
                        else
                            o = TwoWayTurn[3];
                }
                else//L-false
                {
                    if(rep.R)
                    {
                        if(rep.U)
                            o = TwoWayTurn[1];
                        else
                            o = TwoWayTurn[2];
                    }
                    else o = TwoWayStraight[1];//todo: random?
                }
            }
            else
            {
                     if (rep.L)
                    o = OneWay[0];
                else if (rep.U)
                    o = OneWay[1];
                else if (rep.R)
                    o = OneWay[2];
                else
                    o = OneWay[3];
            }
            if (o == null) o = OneWay[0];
            return o;
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;
using OpenTK.Input;

namespace CookieMonster.CookieMonster_Objects
{
    class Skill
    {
        static string[] names = { "Lodowy pocisk", "Przyspieszenie" };

        public enum skillNames { IceBolt, Boost};
        string name;
        public skillNames type { get; private set; }
        public int level{get; private set;}
        public int cooldown { get; private set; }
        public Timer cooldownTimer { get; private set; }
        public int baseTalentPointCost { get; private set; }
        public int talentPointCost { get; private set; }
        public Skill(skillNames s)
        {
            level = 1;
            if (s == skillNames.Boost)
            {
                cooldown = 30;
            }
            else
            {
                cooldown = 20;
            }
            cooldownTimer = new Timer(Timer.eUnits.MSEC, cooldown * 1000, 0, true, false);
            type = s;
            name = names[(int)type];
            baseTalentPointCost = 2;
            talentPointCost = baseTalentPointCost + 2 * level;
        }
        public void riseLevel()
        {
            level++;
            if (type == skillNames.Boost)
            {
                cooldown -= 5;//30/25/20/15
            }
            else
            {
                cooldown /= 2;//20/10/5/2,5..
            }
            cooldownTimer = new Timer(Timer.eUnits.MSEC, cooldown * 1000, 0, true, false);
            name = names[(int)type] + " " + level.ToString();
            talentPointCost = baseTalentPointCost + 2 * level;
        }
    }
    class Player : MOB
    {
        //statistics:
        public int level {get; private set;}
        public int exp{get; private set;}
        public int exp_next{get; private set;}
        public int talentPoints { get; private set; }

        //Skills:
        List<Skill> earnedSkills = new List<Skill>();
        Timer skillBoostTimer; bool skillBoostEnabled;
        private Obj boostFXCurrent;
        private Obj boostFXHorizontal;
        private Obj boostFXUp;
        private Obj boostFXDown;
        //private List<Obj> boostFXSteps;
        //Timer boostFXTimer = new Timer(Timer.eUnits.MSEC, 200, 0, true, false);
        //attributes:
        //double speed => in base class MOB
        public int maxLives { get; private set; }
        int _lives; public int lives { get { return _lives; } set { if (value <= maxLives)_lives = value; } }
        
        private POWER_UP _powerUpsInventory; public POWER_UP powerUpsInventory { get { return _powerUpsInventory; } }
        public int modX { get { return pX % GameManager.gridSize; } }
        public int modY { get { return pY % GameManager.gridSize; } }
       
        private Obj powerPillAura;   
        //Misc:
        //TODO: temporary stuff:
        public Player(int posx, int posy, double spd)
            : base(posx, posy, spd)
        {
            //new DebugMsg("Stworzono obiekt gracza", DebugLVL.info);
            //new DebugMsg("...jest bardzo ladny, naprawde", DebugLVL.info);
            //new DebugMsg(this, "direction", DebugLVL.info);
            //new DebugMsg(this, "dirBuffer", DebugLVL.info);
            //new DebugMsg(this, "pX");
            //new DebugMsg(this, "pY");
            //new DebugMsg(this, "modX");
            //new DebugMsg(this, "modY");
            level = 0; exp = 0; exp_next = 100;
            _lives = 2;
            maxLives = 3;
            mobType = eMOBType.PLAYER;
            skillBoostTimer = new Timer(Timer.eUnits.MSEC, 10 * 1000, 0, true, false);
            //collision:
            base.myCollision = new CollisionReport(this);
            myCollision.cdEvent += new CollisionReport.CDEvtHandler(playerDynamicCollison);
            talentPoints = 90;
            initPowerPillVisuals();
            //now baseSpeed is property of MOB class and this value will be set to speed at MOB constructor
            //baseSpeed = speed;
            //boostFXSteps = new List<Obj>();
            boostFXHorizontal = new Obj("../data/Textures/Game/MOB/COOKIE_BOOST_HORIZONTAL_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            boostFXUp = new Obj("../data/Textures/Game/MOB/COOKIE_BOOST_UP_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            boostFXDown = new Obj("../data/Textures/Game/MOB/COOKIE_BOOST_DOWN_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            boostFXCurrent = boostFXHorizontal;
            _powerUpsInventory = POWER_UP.ENEMY_SLOWER;
        }

        private void initPowerPillVisuals()
        {
            //power pill aura visuals:
            
            powerPillAura = new Obj("../data/Textures/Game/FX/POWERPILL_AURA_A0.dds", 0, 0, Obj.align.CENTER_BOTH);
            powerPillAura.setTexAniFPS(15);
            powerPillAura.ScaleAbs = 1.0;
            Obj_Animation ani = new Obj_Animation(powerPillAura);
            ani.addKeyframe(0, 0, 1.0, 5.0, new Timer(Timer.eUnits.MSEC, 15 * 1000));
            ani.addKeyframe(0, 0, 1.0, 0.9, new Timer(Timer.eUnits.MSEC, 15 * 1000));
            ani.setLoopType(Obj_Animation.eLoopType.None);
            ani.affectionFlags &= ~Obj_Animation.eAffectionFlags.affectPos;
            powerPillAura.addAni(ani);
        }

        public void Update()
        {       
            Waypoint oldLastWP = lastWP;
            base.Update();
            if (oldLastWP != lastWP)
            {
                GameMan.heroHasNewWP();
            }
            if (skillBoostEnabled)
            {
                if (skillBoostTimer.enabled == false)
                {
                    resetMovementSpeed();
                    skillBoostEnabled = false;
                }
            }
        }

        private void UpdateBoostFX()
        {
            if (direction == eDir.R || direction == eDir.L)
            {
                if (mobMirrored)
                    boostFXHorizontal.x = currentVisual.x + 10;
                else
                    boostFXHorizontal.x = currentVisual.x- 10;
                boostFXHorizontal.y = currentVisual.y;
                if ((boostFXHorizontal.width > 0 && mobMirrored)
                || (boostFXHorizontal.width < 0 && !mobMirrored)) boostFXHorizontal.width *= -1;
                boostFXCurrent = boostFXHorizontal;
            }
            else if (direction == eDir.U)
            {
                boostFXUp.y = currentVisual.y+10;
                boostFXUp.x = currentVisual.x;
                if ((boostFXUp.width > 0 && mobMirrored)
                || (boostFXUp.width < 0 && !mobMirrored)) boostFXUp.width *= -1;
                boostFXCurrent = boostFXUp;
            }
            else if (direction == eDir.D)
            {
                boostFXDown.y = currentVisual.y-10;
                boostFXDown.x = currentVisual.x;
                if ((boostFXDown.width > 0 && mobMirrored)
                || (boostFXDown.width < 0 && !mobMirrored)) boostFXDown.width *= -1;
                boostFXCurrent = boostFXDown;
            }
        }
        public void Render()
        {
            if (GameMan.powerPillActive())
            {
                powerPillAura.x = pX + Math.Abs(currentVisual.width)/2;
                powerPillAura.y = pY + currentVisual.height/2;
                powerPillAura.applyAlignCorrection();
                powerPillAura.Render();
            }
            base.Render();
            RenderBoostFX();
        }

        private void RenderBoostFX()
        {
            if (skillBoostEnabled && myCollision.collisionStatic != true && state != eState.FROZEN)
            {
                UpdateBoostFX();
                boostFXCurrent.Render();
            }
        }
        
        /// <summary>
        /// checks if player has skill, if not
        /// method will return null
        /// </summary>
        /// <param name="type"></param>
        /// <returns>Pointer to this skill type in earnedSkills list</returns>
        public Skill hasSkill(Skill.skillNames type)
        {
            Skill s = null;
            for (int i = 0; i < earnedSkills.Count; i++)
            {
                if (earnedSkills[i].type == type)
                    s = earnedSkills[i];
            }
            return s;
        }

        /// <summary>
        /// Rises a Skill
        /// </summary>
        /// <param name="type">Type of the skill</param>
        /// <param name="costTP">true if rise will cost any TalentPts.</param>
        /// <returns>Returns true when skill was risen, false when player doesn't have enough TP</returns>
        public bool riseSkill(Skill.skillNames type,bool costTP)
        {
            Skill s = hasSkill(type);
            bool skillCreated = false;
            int cost = -1;
            if (s == null)
            {
                skillCreated = true;
                s = new Skill(type);
                cost = s.baseTalentPointCost;
            }
            if (cost == -1) cost = s.talentPointCost;//skill wasn't just created so take value from TP cost
            if(talentPoints>=cost && costTP)
                talentPoints = talentPoints-cost;//decreasing talent pts by skill cost
            else if(costTP)
                return false; //no talent points, no skill!!!

            if (skillCreated)
                earnedSkills.Add(s);
            else
                s.riseLevel();
            return true;
        }
        public bool riseSkill(Skill.skillNames type)
        {
            return riseSkill(type, true);
        }
        public bool riseMaxLives()
        {
            if (talentPoints > 0)
            {
                maxLives++;
                talentPoints--;
                return true;
            }
            return false;
        }
        public bool riseSpeed()
        {
            if (talentPoints > 0)
            {
                speed += 5; //current speed, actually can be different than baseSpeed
                icreaseBaseSpeed(5);//so we need to update both (when player is boosted)
                talentPoints--;
                return true;
            }
            return false;
        }
        private void nextLevel()
        {
            level++;
            talentPoints++;
            exp_next = generateExpNext();
        }

        private int generateExpNext()
        {
            int ret = level * 150 + level * level * 15;
            ret = ret + (100- (ret%100));//round up by 100;
            return ret;
        }
        public void addExp(int val)
        {
            exp += val;
            if (exp >= exp_next)
            {//TODO: some jingle to play?
                nextLevel();
            }
        }

        internal void KeyboardEvt(object sender, KeyboardKeyEventArgs k)
        {
            switch (k.Key)
            {
                case Key.Left:
                    dirBuffer = eDir.L; break;
                case Key.Right:
                    dirBuffer = eDir.R; break;
                case Key.Up:
                    dirBuffer = eDir.U; break;
                case Key.Down:
                    dirBuffer = eDir.D; break;
                case Key.Z:
                    if ((powerUpsInventory & POWER_UP.BOMB) == POWER_UP.BOMB)
                    {
                        _powerUpsInventory = powerUpsInventory & ~POWER_UP.BOMB;
                        new Bomb(pX, pY);
                    }
                    break;
                case Key.X:
                    if ((powerUpsInventory & POWER_UP.ENEMY_SLOWER) == POWER_UP.ENEMY_SLOWER)
                    {
                        _powerUpsInventory = powerUpsInventory & ~POWER_UP.ENEMY_SLOWER;
                        GameMan.slowEnemies();
                    }
                    break;
                case Key.C:
                    useSkill(Skill.skillNames.Boost); break;
                case Key.V:
                    useSkill(Skill.skillNames.IceBolt); break;
                case Key.Enter:
                    if (GameMan.canStartNextLevel) GameMan.nextLevel(); break;
                


            }
        }
        private void useSkill(Skill.skillNames type)
        {
            if (state == eState.FROZEN) return; //no using skill when frozen!
            Skill s = hasSkill(type);
            if (s == null)
                return; // can't use skill u don't have
            if (s.cooldownTimer.enabled) 
                return; //can't use skill that's on cooldown
            s.cooldownTimer.start();
            if (type == Skill.skillNames.Boost)
            {
                skillBoostTimer.restart();
                //resetMovementSpeed();
                speed = baseSpeed + 40.0 + 10.0*s.level;
                skillBoostEnabled = true;
            }
            else if (type == Skill.skillNames.IceBolt)
            {
                new Projectile(Projectile.eProjType.IceBolt, this, this.pX, this.pY, 70.0);
            }
        }
        /// <summary>
        /// Sets skills cooldown to 0
        /// </summary>
        public void renewSkills()
        {
            for (int i = 0; i < earnedSkills.Count; i++)
            {
                if (earnedSkills[i].cooldownTimer != null)
                {
                    earnedSkills[i].cooldownTimer.restart();
                    earnedSkills[i].cooldownTimer.stop();
                }
            }

        }
        private void playerDynamicCollison(MOB src, collDynEventArgs fe)
        {
            Sound pickup = new Sound(Sound.eSndType.SFX, "../data/Sounds/PICKUP.ogg", false, false);
            pickup.volume = 0.8;

            if (fe.cdPowerUP != null)
            {
                if (fe.cdPowerUP.type == POWER_UP.COOKIE)
                    src.eatCookie(fe.cdPowerUP);
                else if (fe.cdPowerUP.type == POWER_UP.BOMB)
                {
                    _powerUpsInventory |= POWER_UP.BOMB;
                    GameMan.removePowerUp(fe.cdPowerUP);
                    pickup.Play();
                }
                else if (fe.cdPowerUP.type == POWER_UP.ENEMY_SLOWER)
                {
                    _powerUpsInventory |= POWER_UP.ENEMY_SLOWER;
                    GameMan.removePowerUp(fe.cdPowerUP);
                    pickup.Play();
                }
                else if (fe.cdPowerUP.type == POWER_UP.POWER_PELLET)
                {
                    initPowerPillVisuals();
                    GameMan.PlayerTakePowerPellet();
                    GameMan.removePowerUp(fe.cdPowerUP);
                    pickup.Play();
                }
                else if (fe.cdPowerUP.type == POWER_UP.LIFE)
                {
                    int oldLives = lives;
                    lives++;
                    if (lives != oldLives)
                    {
                        pickup.Play();
                        GameMan.removePowerUp(fe.cdPowerUP);
                    }
                    else
                    {
                        GameMan.playFailSound();
                    }
                }
                else if (fe.cdPowerUP.type == POWER_UP.SKILL_POINT)
                {
                    talentPoints++;
                    pickup.Play();
                    GameMan.removePowerUp(fe.cdPowerUP);
                }
            }
            if (fe.enemy != null)
            {
                if (fe.enemy.enemyState == Enemy.eEnemyState.FLEE)
                {
                    switch (fe.enemy.type)
                    {
                        case Enemy.enemyType.NORMAL: GameMan.statistics.addPoints(50); break;
                        case Enemy.enemyType.THIEF: GameMan.statistics.addPoints(20); break;
                        case Enemy.enemyType.WIZARD: GameMan.statistics.addPoints(70); break;
                        case Enemy.enemyType.SHOOPDAWOOP: GameMan.statistics.addPoints(80); break;
                        case Enemy.enemyType.ASSASSIN: GameMan.statistics.addPoints(100); break;
                    }
                    fe.enemy.enemyState = Enemy.eEnemyState.WOUNDED;
                }
                else if (fe.enemy.enemyState == Enemy.eEnemyState.NORMAL)
                {
                    Kill();
                }
            }
            //  
        }


        public override void Kill()
        {
            new DebugMsg("Player should be dead!");
            //throw new NotImplementedException();
        }
        /// <summary>
        /// Restore player attributes & skills
        /// based on savegame playerData
        /// </summary>
        /// <param name="sav">passed Savegame</param>
        internal void restoreFromSave(Savegame sav)
        {
            speed = sav.player.movementSpeed;
            level = (int)sav.player.level;
            exp  = (int)sav.player.exp;
            _lives = (int)sav.player.lives;
            maxLives = (int)sav.player.maxLives;
            talentPoints = (int)sav.player.talentPts;
            //inventory:
            if (sav.player.invHasBomb > 0)
                _powerUpsInventory |= POWER_UP.BOMB;
            if (sav.player.invHasTimeSlow > 0)
                _powerUpsInventory |= POWER_UP.ENEMY_SLOWER;
            //skills:
            for (int i = 0; i < sav.player.speedBoostLVL; i++)
                riseSkill(Skill.skillNames.Boost, false);

            for (int i = 0; i < sav.player.iceBoltLVL; i++)
                riseSkill(Skill.skillNames.IceBolt, false);
            
            exp_next = generateExpNext();
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;
using System.Drawing;

namespace CookieMonster.CookieMonster_Objects
{
    class Portal
    {
        static private int portalsCount = 0;
        static private string PATH_PORTAL_PREFIX = "../Data/Textures/GAME/SOB/PORTAL_";
        static int maxPortalsImages = 3;//Portal_1-3_A0-n.dds (thatswhatimtalkinbout)
        private Color _portalColor;
        private bool _finished = false; // when its finished new Portal on list will be created
        private Obj[] _portalOBJ = new Obj[2];
        public Obj portalObj1 { get { return _portalOBJ[0]; } }
        public Obj portalObj2 { get { return _portalOBJ[1]; } }

        public Point gridPt1
        {
            get
            {
                if (portalObj1 == null) return new Point(-1,-1);
                return new Point((portalObj1.x + (GameManager.gridSize / 2)) / GameManager.gridSize,
                                 (portalObj1.y + (GameManager.gridSize / 2)) / GameManager.gridSize);
            }
        }
        public Point gridPt2
        {
            get
            {
                if (portalObj2 == null) return new Point(-1, -1);
                return new Point((portalObj2.x + (GameManager.gridSize / 2)) / GameManager.gridSize,
                                 (portalObj2.y + (GameManager.gridSize / 2)) / GameManager.gridSize);
            }
        }
        
        public Portal(int x,int y, Color c)
        {
            _portalColor = c;
            _portalOBJ[0] = new Obj(PATH_PORTAL_PREFIX + portalsCount % maxPortalsImages + "_A0.dds", x, y, Obj.align.CENTER_BOTH);
            portalsCount++;
            //visual stuff:
            _portalOBJ[0].setTexAniFPS(12);
            //_portalOBJ[0].width = 60; _portalOBJ[0].height = 60;
            //_portalOBJ[0].x -= 6; _portalOBJ[0].y -= 6;
            //bounding box:
            
        }
        public Color portalColor
        {
            get { return _portalColor; }
        }
        public bool matchWithPortal(int x, int y, Color c, int inListIdx)
        {
            if ( (_portalColor == c) && (_portalOBJ[1]==null) )
            {
                _portalOBJ[1] = new Obj(PATH_PORTAL_PREFIX + inListIdx % maxPortalsImages + "_A0.dds", x, y, Obj.align.CENTER_BOTH);
                //visual stuff:
                _portalOBJ[1].setTexAniFPS(12);
                //_portalOBJ[1].width = 60; _portalOBJ[1].height = 60;
                //_portalOBJ[1].x -= 6; _portalOBJ[1].y -= 6;
                _finished = true;
                return true;
            }
            else
                return false;
        }
        public bool portalFinished()
        { return _finished; }
        

        // public Point teleportPoint(Point startPoint)
        // {
        //     if (startPoint.Equals(_pos[0]))
        //         return _pos[1];
        //     else
        //         return _pos[0];
        // }
        public void Render()
        {
            // if portal is unfinished do not render!
            if (_portalOBJ[1] == null) return;
            _portalOBJ[0].Render();
            _portalOBJ[1].Render();

        }
        public static void resetPortalsCount()
        {
            portalsCount = 0;
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    [Flags]
    enum POWER_UP
    {
        COOKIE,//just some cookie to eat
        POWER_PELLET,//classic pac-man powerup
        LIFE,
        BOMB,
        ENEMY_SLOWER,
        SKILL_POINT,
        INSTANT_STONE
    }
    class PowerUp : MOB
    {
        private POWER_UP _type; public POWER_UP type { get { return _type; } }
        static public GameManager GameMan;
        public PowerUp(int posx, int posy,String visual)
            : base(posx, posy, 0)
        {
            base.setStateVisual(new Obj(visual,posx,posy,Obj.align.CENTER_BOTH), "DEFAULT");

            base.Move(- base.currentVisual.width / 2,-base.currentVisual.height / 2,false); 
            GameMan.addPowerUP(this);
            base.updateBoundingBox();//for objects without movement, so in future bbox willn't be 
            //calculated anymore
            if(visual==GameMap.PATH_PU_COOKIE)
                    _type = POWER_UP.COOKIE;
            else if(visual==GameMap.PATH_PU_POWERPILL)
                    _type = POWER_UP.POWER_PELLET; 
            else if(visual==GameMap.PATH_PU_BOMB)
                    _type = POWER_UP.BOMB;
            else if (visual == GameMap.PATH_PU_LIFE)
            {
                _type = POWER_UP.LIFE;
                currentVisual.setTexAniFPS(15);
            }
            else if (visual == GameMap.PATH_PU_SKILLPOINT)
            {
                _type = POWER_UP.SKILL_POINT;
                currentVisual.setTexAniFPS(10);
            }
            else if (visual == GameMap.PATH_PU_ENEMYSLOWER)
                _type = POWER_UP.ENEMY_SLOWER;

            mobType = eMOBType.POWERUP;
        }
        public void Update()
        {
           // base.Update();
        }
        public void Render()
        {
            base.Render();
        }
        public void Remove()
        {
            GameMan.removePowerUp(this);
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;
using System.Drawing;

namespace CookieMonster.CookieMonster_Objects
{
    class Projectile : MOB
    {
        //Ice Bolt:
        static Obj iceBoltVisuals;
        static Obj iceBoltDestroy;
        static Obj iceBoltVisualsSecond;
        static Obj lastUsedIceBoltVisual;

        //Lazer:
        static Obj lazerVisuals;
        static Obj lazerVisualsSecond;
        static Obj lastUsedLazerVisual;

        //Knife:
        static Obj knifeVisuals;
        static Obj knifeVisualsSecond;
        static Obj lastUsedKnifeVisual;
        static Obj knifeDestroy;

        static bool lazerStaticVisualsInited = false;
        static bool iceBoltStaticVisualsInited = false;
        public MOB owner { get; private set; }
        public enum eProjType { IceBolt, Lazer, Knife }
        public eProjType type {get; private set;}
        public bool isBeingDestroyed { get; private set; }
        #region Overriden_Properties
        public int gridX
        {
            get
            {
                if (type == eProjType.IceBolt)
                {
                    switch (direction)
                    {
                        case eDir.U: return base.gridX + 1; break;
                        case eDir.D: return base.gridX + 1; break;
                        case eDir.L: return base.gridX - 3; break;
                        case eDir.R: return base.gridX + 3; break;
                        default: return base.gridX; break;
                    }
                }
                else if (type == eProjType.Knife)
                    {
                        switch (direction)
                        {
                            case eDir.U: return base.gridX + 1; break;
                            case eDir.D: return base.gridX + 1; break;
                            case eDir.L: return base.gridX - 1; break;
                            default: return base.gridX; break;
                        }
                    }
                else return base.gridX;
            }
        }
        public int gridY
        {
            get
            {
                if (type == eProjType.IceBolt)
                {
                    switch (direction)
                    {
                        case eDir.U: return base.gridY + 1; break;
                        case eDir.D: return base.gridY + 4; break;
                        case eDir.L: return base.gridY + 3; break;
                        case eDir.R: return base.gridY + 3; break;
                        default: return base.gridY; break;
                    }
                }
                else if (type == eProjType.Knife)
                {
                    switch (direction)
                    {
                        case eDir.R: return base.gridY + 1; break;
                        case eDir.L: return base.gridY + 1; break;
                        default: return base.gridY; break;
                    }
                }
                else return base.gridY;
            }
        }

        public int nextGridX
        {
            get { return gridX; }
        }
        public int nextGridY
        {
            get { return gridY; }
        }
        #endregion
        public Projectile(eProjType typ, MOB _owner, int posx, int posy, double spd)
            : base(posx - GameManager.gridSize/2, posy, spd) 
        {
            type = typ;
            owner = _owner;
            mobType = eMOBType.PROJECTILE;
            direction = owner.direction;
            base.myCollision = new CollisionReport(this);
            myCollision.cdEvent += new CollisionReport.CDEvtHandler(projectileDynamicCollision);
            if (typ == eProjType.IceBolt)
                InitIceBolt();
            else if (typ == eProjType.Lazer)
                InitLazer();
            else if (typ == eProjType.Knife)
                InitKnife();
            //add projectile to proj. list:
            GameMan.projectilesList.Add(this);
            mobType = eMOBType.PROJECTILE;
        }


        static public void projectilesVisualsInit()
        {
            //Ice Bolt
            iceBoltVisuals = new Obj("../data/Textures/Game/FX/ICEBOLT_A0.dds", 0, 0, Obj.align.CENTER_X);
            iceBoltDestroy = new Obj("../data/Textures/Game/FX/ICEBOLT_EXPLODE_A0.dds", 0, 0, Obj.align.CENTER_X);
            iceBoltVisualsSecond = new Obj("../data/Textures/Game/FX/ICEBOLT_A0.dds", 0, 0, Obj.align.CENTER_X);
        
            //Lazer:
            lazerVisuals       = new Obj("../data/Textures/Game/FX/FX_LAZER_A0.dds",0,0,Obj.align.LEFT);
            lazerVisualsSecond = new Obj("../data/Textures/Game/FX/FX_LAZER_A0.dds", 0, 0, Obj.align.LEFT);

            //Knife:
            knifeVisuals = new Obj("../data/Textures/Game/FX/THROWING_KNIFE.dds", 0, 0, Obj.align.CENTER_X);
            knifeVisualsSecond = new Obj("../data/Textures/Game/FX/THROWING_KNIFE.dds", 0, 0, Obj.align.CENTER_X);
            knifeDestroy = new Obj("../data/Textures/Game/FX/SWORD_EXPLODE_A0.dds", 0, 0, Obj.align.CENTER_X);
        }
        private void InitLazer()
        {
            if (!lazerStaticVisualsInited)
            {
                lazerVisuals.setTexAniLoopType(Obj_texAni.eLoopType.DEFAULT);
                lazerVisuals.setTexAniFPS(20);
                lazerVisualsSecond.setTexAniLoopType(Obj_texAni.eLoopType.DEFAULT);
                lazerVisualsSecond.setTexAniFPS(20);

                lazerStaticVisualsInited = true;
            }
            if (lastUsedLazerVisual != lazerVisuals)
            {
                setStateVisual(lazerVisuals, "DEFAULT");
                lastUsedLazerVisual = lazerVisuals;
            }
            else
            {
                setStateVisual(lazerVisualsSecond, "DEFAULT");
                lastUsedLazerVisual = lazerVisualsSecond;
            }
            currentVisual.setTexAniFrame(0);
            Obj vis = currentVisual;
            int visWAbs = Math.Abs(vis.width);

            //Rotate visual:
            if (direction == eDir.L)
            {
                Move(-visWAbs / 2 - visWAbs / 3, 4, false);
                currentVisual.Rotate(180);
            }
            else if (direction == eDir.D)
            {
                Move(-visWAbs / 3 - visWAbs / 26, +(visWAbs / 3) +visWAbs / 10, false);
                currentVisual.Rotate(90);
            }
            else if (direction == eDir.R)
            {
                Move(+visWAbs / 14, 4, false);
                currentVisual.Rotate(0);
            }
            else if (direction == eDir.U)
            {
                Move(-visWAbs / 3 - visWAbs/28, -(visWAbs / 3) -visWAbs/10, false);
                currentVisual.Rotate(270);
            }
            //Play cast sound:
            Sound cast = new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_LAZER_SHOOT.ogg",false,true,1.0);
            //Set Bbox:
            updateBoundingBox();
            
        }
        private void InitIceBolt()
        {
            if (!iceBoltStaticVisualsInited)
            {
                iceBoltDestroy.ScaleAbs = 3.0;
                iceBoltDestroy.setTexAniFPS(28);
                iceBoltDestroy.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
                iceBoltVisuals.ScaleAbs = 2.0;
                iceBoltVisuals.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
                iceBoltVisuals.setTexAniFPS(15);
                iceBoltVisualsSecond.ScaleAbs = 2.0;
                iceBoltVisualsSecond.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
                iceBoltVisualsSecond.setTexAniFPS(15);

                iceBoltStaticVisualsInited = true;
            }
            if (lastUsedIceBoltVisual != iceBoltVisuals)
            {
                setStateVisual(iceBoltVisuals, "DEFAULT");
                lastUsedIceBoltVisual = iceBoltVisuals;
            }
            else
            {
                setStateVisual(iceBoltVisualsSecond, "DEFAULT");
                lastUsedIceBoltVisual = iceBoltVisualsSecond;
            }
            currentVisual.setTexAniFrame(0);
            //pX = owner.gridX * GameManager.gridSize - GameManager.gridSize;
            //pY = owner.gridY * GameManager.gridSize + GameManager.gridSize / 2;

            //Rotate visual:
            if (direction == eDir.L)
            {
                Move(0, -currentVisual.height/2 + 27, false);
                currentVisual.Rotate(270);
            }
            else if (direction == eDir.D)
            {
                Move(0, -currentVisual.height / 2, false);
                currentVisual.Rotate(180);
            }
            else if (direction == eDir.R)
            {
                Move(0, -currentVisual.height / 2 + 27, false);
                currentVisual.Rotate(90);
            }
            else if (direction == eDir.U)
            {
                Move(0, -currentVisual.height / 2 + 27, false);
                currentVisual.Rotate(0);
            }

            //Play cast sound:
            Sound cast = new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_ICEBOLT.ogg", false, false);
            cast.volume = 0.8;
            cast.Play();
        }
        private void InitKnife()
        {
            knifeDestroy.setTexAniFPS(15);
            knifeDestroy.setTexAniLoopType(Obj_texAni.eLoopType.NONE);
            if (lastUsedKnifeVisual != knifeVisuals)
            {
                setStateVisual(knifeVisuals, "DEFAULT");
                lastUsedKnifeVisual = knifeVisuals;
            }
            else
            {
                setStateVisual(knifeVisualsSecond, "DEFAULT");
                lastUsedKnifeVisual = knifeVisualsSecond;
            }

            //Rotate visual:
            if (direction == eDir.L)
            {
                Move(0, -currentVisual.height / 2 + 27, false);
                currentVisual.Rotate(180);
            }
            else if (direction == eDir.D)
            {
                Move(currentVisual.width/4,0, false);
                currentVisual.Rotate(90);
            }
            else if (direction == eDir.R)
            {
                Move(currentVisual.width, -currentVisual.height / 2 + 27, false);
                currentVisual.Rotate(0);
            }
            else if (direction == eDir.U)
            {
                Move(currentVisual.width / 4,0, false);
                currentVisual.Rotate(270);
            }

            //Play knifethrow sound:
            Sound knifethrow = new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_KNIFE_THROW.ogg", false, false);
            knifethrow.Play();
        }


        public void Update()
        {
            if (isBeingDestroyed == true)
            { // projectile started destroying-ani
              // when last keyframe reached, delete Projectile
                if (iceBoltDestroy.texAniFinished() == true)
                {
                    GameMan.projectilesList.Remove(this);
                }
                return;
            }
            if (speed == 0.0) return; //no movement, no update
            int grid = GameManager.gridSize;

            if (myCollision.collisionStatic == true )
            {
                Destroy();
                return;
            }
            //TODO: When rotate by other value than 0 
            // correct Y-position store current Obj correction so
            // everything will be handled like it could be.
            if (direction == eDir.R)
                Move(pxMove, 0, false);
            else if (direction == eDir.L)
                Move(-pxMove, 0, false);
            else if (direction == eDir.U)
                Move(0, -pxMove, false);
            else if (direction == eDir.D)
                Move(0, pxMove, false);

            //Update bbox:
            if(type == eProjType.IceBolt || type == eProjType.Knife)
                updateBoundingBox(gridX * GameManager.gridSize, gridY * GameManager.gridSize, GameManager.gridSize, GameManager.gridSize);
        }
        public void Destroy()
        {
            if (type == eProjType.IceBolt)
            {
                isBeingDestroyed = true;
                iceBoltDestroy.setTexAniFrame(0);
                iceBoltDestroy.x = gridX * GameManager.gridSize - 64;
                iceBoltDestroy.y = gridY * GameManager.gridSize - 64;
                
                //Play cast sound:
                Sound destroy = new Sound(Sound.eSndType.SFX,"../data/Sounds/GAME_ICEBOLT_DESTROY.ogg", false, false);
                destroy.volume = 1.0;
                destroy.Play();
            }
            else if (type == eProjType.Knife)
            {
                destroyKnife();
            }
            else if (type == eProjType.Lazer)
            {
                GameMan.projectilesList.Remove(this);
            }
            GameMan.collisionSystem.RemoveReport(this);
        }

        public void Render()
        {
            if (isBeingDestroyed)
            {
                if (type == eProjType.IceBolt)
                    iceBoltDestroy.Render();
                else if (type == eProjType.Knife)
                    knifeDestroy.Render();
                return;
            }
            base.Render();
        }
        private void projectileDynamicCollision(MOB src, collDynEventArgs fe)
        {
            if (type == eProjType.IceBolt)
            {
                if (isBeingDestroyed) return; //no cdDyn when destroying projectile!
                //projectile collide with player
                if (owner.mobType == eMOBType.ENEMY && fe.player != null)
                {
                    Sound freeze = new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_ICEBOLT_FREEZE.ogg", false, false);
                    freeze.volume = 0.8;
                    freeze.Play();
                    fe.player.setFreeze();
                    Destroy();
                }
                if (fe.enemy != null && (MOB)fe.enemy != owner)
                {
                    Sound freeze = new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_ICEBOLT_FREEZE.ogg", false, false);
                    freeze.volume = 0.8;
                    freeze.Play();
                    if (fe.enemy.enemyState == Enemy.eEnemyState.FLEE)
                    {
                        GameMan.statistics.addPoints(50);
                        fe.enemy.enemyState = Enemy.eEnemyState.WOUNDED;
                    }
                    else if (fe.enemy.enemyState == Enemy.eEnemyState.NORMAL)
                    {
                        fe.enemy.setFreeze();
                    }
                    Destroy();
                }
            }
            else if (type == eProjType.Lazer)
            {
                if (fe.enemy != null && (MOB)fe.enemy != owner)
                {
                }
                if (fe.player != null && (MOB)fe.player != owner)
                {
                    ((MOB)fe.player).Kill();
                }
            }
            else if (type == eProjType.Knife)
            {
                if (fe.player != null && (MOB)fe.player != owner)
                {
                    ((MOB)fe.player).Kill();

                    new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_KNIFE_HIT.ogg", false, true);
                    // Don't destroy using Destroy method, it would cause call of destroyKnife method
                    // which is used to destroy knife when colliding with wall, etc.
                    GameMan.projectilesList.Remove(this);
                    GameMan.collisionSystem.RemoveReport(this);
                }
            }

        }
        private void destroyKnife()
        {
            new Sound(Sound.eSndType.SFX, "../data/Sounds/GAME_KNIFE_STONECOLLIDE.ogg", false, true);
            isBeingDestroyed = true;
            knifeDestroy.setTexAniFrame(0);
            knifeDestroy.x = currentVisual.x;
            knifeDestroy.y = currentVisual.y;
        }

    }
}
using System;
using System.Collections.Generic;

using System.Drawing;
using System.Text;
using QuickFont;
using EngineApp;

namespace CookieMonster.CookieMonster_Objects
{
    class Statistics
    {
        static public uint ptsPerCookie = 10;
        public uint points { get; private set; }
        public uint lvlPoints { get; private set; } //only current level points

        private uint _eatenCookies; public uint eatenCookies { get { return _eatenCookies; } }

        QFont ptFont = TextManager.newQFont("Rumpelstiltskin.ttf", 20, true);
        public Statistics()
        {
            points = 0;
            lvlPoints = 0;
            _eatenCookies=0;
        }
        public void newLevel() { lvlPoints = 0; }
        public void addPoints(uint v)
        {
            Camera curCam = Game.self.gameCamera;
            points += v;
            lvlPoints += v;
            ptFont.Options.Colour = new OpenTK.Graphics.Color4(255,255,255,200);
            Text msg = Game.self.textMenager.produceText(ptFont, "+" + v.ToString() + "pts.", (float)(Game.self.gameManager.PC.pX + 30 + curCam.camOffsetX), (float)(Game.self.gameManager.PC.pY + curCam.camOffsetY + 10));
            //Text msg = new Text(ptFont, new ProcessedText(), (float)(Game.self.gameManager.PC.pX + 30 + curCam.camOffsetX), (float)(Game.self.gameManager.PC.pY + curCam.camOffsetY + 10), "+" + v.ToString() + "pts.");
            msg.setLifeTime(600);
            msg.setAnimationMove(new Point(0, -3));
            Game.self.textMenager.addText(msg);
            
            //give exp pts to hero:
            Game.self.gameManager.PC.addExp((int)v);
            
        }
        public void addEatenCookies(uint v)
        {
            _eatenCookies += v;
            addPoints(v * ptsPerCookie); //every cookie is 10 pts.
        }

    }
}
using System;
using System.Collections.Generic;

using System.Text;
using EngineApp;
using System.Drawing;
using QuickFont;

namespace CookieMonster.CookieMonster_Objects
{
    class statusScreen
    {
        public bool active { get; private set; }
        private Obj background;
        private Obj cookie; private int cookieDstXPos, cookieMoveWidth;
        private Obj pause;
        private Timer easeInTimer;
        private Timer easeOutTimer;

        //menu stuff:
        private Menu menu_status;
        private bool menuCreated;
        public Rectangle menuArea { get; private set; }
        public QFont FontStatus_BIG { get; private set; }
        public QFont FontStatus_Small { get; private set; }
        public QFont FontStatus_Little { get; private set; }

#region menu contents
        //menu texts: (generated in generateContents method, rendered by onRender function by MENU_STATUS)
        public Text Level_initial { get; private set; }
        public Text Level         { get; private set; }

        public Text TalentPts_initial   { get; private set; }
        public Text TalentPts_initial2  { get; private set; }
        public Text TalentPts           { get; private set; }
        public List<Obj> TalentPtsStars { get; private set; }

        public Text Atributes_initial       { get; private set; }
        public Text Atributes               { get; private set; }
        public Text Atributes_speed         { get; private set; }
        public Text Atributes_maxLives      { get; private set; }
        public Text Atributes_speed_val     { get; private set; }
        public Text Atributes_maxLives_val  { get; private set; }
        public Text Atributes_speed_plus    { get; private set; } 
        public Text Atributes_maxLives_plus { get; private set; }
        public Obj  Atributes_speed_add     { get; private set; } //there? rather as menu item
        public Obj  Atributes_maxLives_add  { get; private set; }
        
        public Text Skills_initial       { get; private set; }
        public Text Skills               { get; private set; }
        public Text Skills_boost         { get; private set; }
        public Text Skills_icebolt       { get; private set; }
#endregion

        public statusScreen()
        {
            easeInTimer = new Timer(Timer.eUnits.MSEC, 400, 0, true, false);
            easeOutTimer = new Timer(Timer.eUnits.MSEC, 200, 0, true, false);
            background = new Obj("../data/Textures/GAME/GUI/STATUSSCREEN_BG.dds", 0.5, 0.45, Obj.align.CENTER_BOTH);
            background.isGUIObjectButUnscaled = true;
            menuArea = new Rectangle(background.x + 53, background.y + 216, 500, 750);

            cookie = new Obj("../data/Textures/GAME/GUI/STATUSSCREEN_COOKIE.dds", 1.05, 1.09, Obj.align.RIGHT);
            cookie.isGUIObjectButUnscaled = true;
            cookieDstXPos = cookie.x;// +cookie.width;
            cookieMoveWidth = 950;
            cookie.x += cookieMoveWidth;

            pause = new Obj("../data/Textures/GAME/GUI/STATUSSCREEN_PAUSE.dds", 1.0, 0.85, Obj.align.RIGHT);
            pause.isGUIObjectButUnscaled = true; pause.x -= 200;


            FontStatus_BIG = TextManager.newQFont("Rumpelstiltskin.ttf", 37,FontStyle.Regular,true);
            FontStatus_Small = TextManager.newQFont("Rumpelstiltskin.ttf", 28, FontStyle.Regular, true);
            FontStatus_Little = TextManager.newQFont("Rumpelstiltskin.ttf", 25, FontStyle.Regular, true);
            TalentPtsStars = new List<Obj>();
        }
        public void Show()
        {
            active = true;
            easeOutTimer.restart(); easeOutTimer.stop();
            easeInTimer.start();
            menuCreated = false;
            cookie.setCurrentTexAlpha(255);
            cookie.x = cookieDstXPos + cookieMoveWidth;
        }
        public void Hide()
        {
            easeInTimer.restart(); easeInTimer.stop();
            easeOutTimer.start();
            Game.self.gameState &= ~Game.game_state.Menu;
        }
        public void Update()
        {
            if (easeInTimer.enabled)
            { // menu is easing in
                double multi = ((easeInTimer.currentTime - 150.0) / easeInTimer.totalTime);
                if (multi < 0.0) multi = 0.0;
                cookie.x = cookieDstXPos + (int)(cookieMoveWidth * multi);
                multi = 1.0 - (easeInTimer.currentTime / 300.0);
                if (multi < 0.0) multi = 0.0;
                background.setCurrentTexAlpha((byte)(255 * multi));
            }
            else if (easeOutTimer.enabled)
            { // menu is easing out
                double multi = (easeOutTimer.currentTime*1.0 / easeOutTimer.totalTime);
                if (multi > 1.0) multi = 1.0;
                background.setCurrentTexAlpha((byte)(255.0 * multi));
                cookie.setCurrentTexAlpha((byte)(255.0 * multi));

            }
            else if (active && !menuCreated)
            {// menu just eased in -> time to create menu
                menuCreated = true;
                menu_status = new Menu("MENU_STATUS", Menu_Instances.Status_OnLoad, null, Menu_Instances.Status_OnRender, Menu_Manager.cursor);
                Game.self.menuManager.setCurrentMenu(menu_status);
                Game.self.gameState |= Game.game_state.Menu;
            }
            else if (!easeOutTimer.enabled && active && !((Game.self.gameState & Game.game_state.Menu) == Game.game_state.Menu))
            { // status menu just has easedout
                active = false;
            }
        }
        public void Render()
        {
            if (active)
            {
                background.Render();
                cookie.Render();
            }
        }

        public void generateContents()
        {
            GameManager gm = Game.self.gameManager;
            TextManager txtMan = Game.self.textMenager;
            int pX, pY;
            const int lMargin = 20;

            menu_status.clearMenuItems();
            //Level X:
            pX = menuArea.Left + lMargin;
            pY = menuArea.Top + (int)(menuArea.Height * 0.085);//8%

            Level_initial = new Text(FontStatus_BIG, new ProcessedText(), pX, pY - 10, Lang.cur.POZIOM_FIRST+"     " + gm.PC.level + "(" + gm.PC.exp+"/"+gm.PC.exp_next+")");
            Level = new Text(FontStatus_Small, new ProcessedText(), pX + 4, pY, " " + Lang.cur.POZIOM_REST);
           
            //Talent Pts
            pX = menuArea.Right+90;
            pY = menuArea.Top + (int)(menuArea.Height * 0.085);//8%
            TalentPts_initial2 = txtMan.produceText(FontStatus_BIG, Lang.cur.PKT_TALENTU__P + "        ", pX - 15, pY - 10, QFontAlignment.Right);
            TalentPts_initial = txtMan.produceText(FontStatus_BIG, Lang.cur.PKT_TALENTU__T + "     ", pX + 2, pY - 10, QFontAlignment.Right);
            TalentPts        = txtMan.produceText(FontStatus_Small, " "+Lang.cur.KT_ALENTU, pX + 4, pY, QFontAlignment.Right);
            //Talent Stars:
            TalentPtsStars.Clear();
            int starXStep = 40;
            pY += (int)(menuArea.Height * 0.12); pX += 20;
            for (int i = 0; i < Game.self.gameManager.PC.talentPoints; i++)
            {
                Obj star = new Obj("../data/Textures/GAME/GUI/STAR_COLOR.dds", pX - starXStep * i, pY, Obj.align.RIGHT);
                star.isGUIObjectButUnscaled = true;
                TalentPtsStars.Add(star);
            }

            //Atributes:
            pX = menuArea.Left + lMargin;
            pY = menuArea.Top + (int)(menuArea.Height * 0.25);//25%

            Atributes_initial = new Text(FontStatus_BIG, new ProcessedText(), pX, pY - 10, Lang.cur.ATRYBUTY__A);
            Atributes = new Text(FontStatus_Small, new ProcessedText(), pX + 5, pY, " "+Lang.cur.TRYBUTY);

            pY += (int)(menuArea.Height * 0.07);
            Atributes_speed = new Text(FontStatus_Little, new ProcessedText(), pX, pY, Lang.cur.SZYBKOSC+":");
            pX += (int)(menuArea.Width * 0.4);
            int speed = (int)gm.PC.speed;
            Atributes_speed_val = new Text(FontStatus_Little, new ProcessedText(), pX, pY, speed.ToString());

            pX += (int)(menuArea.Width * 0.15);
            pY -= (int)(menuArea.Height * 0.02);
            Obj add = new Obj("../data/Textures/GAME/GUI/STAR_GRAY.dds", pX, pY, Obj.align.CENTER_X);
            add.isGUIObjectButUnscaled = true;
            Obj addOn = new Obj("../data/Textures/GAME/GUI/STAR_COLOR.dds", pX, pY, Obj.align.CENTER_X);
            addOn.isGUIObjectButUnscaled = true;
            Obj addClick = new Obj("../data/Textures/GAME/GUI/STAR_COLOR_BIG.dds", pX, pY, Obj.align.CENTER_X);
            addClick.isGUIObjectButUnscaled = true;
            menu_status.addItem(new Menu_Item("raiseSpeed", add, addOn, addClick, Menu_Instances.Status_ButtonOnHover,null, Menu_Instances.Status_AtrBoostClick));

            pY -= (int)(menuArea.Height * 0.006);
            pX += 4;
            Atributes_speed_plus = new Text(FontStatus_Small, null, pX, pY, "+5");

            //Max lives number:

            pX = menuArea.Left + lMargin;
            pY = menuArea.Top + (int)(menuArea.Height * 0.39);//39%
            Atributes_maxLives = new Text(FontStatus_Little, new ProcessedText(), pX, pY, Lang.cur.MAXDOT_ILDOT_ZYC+":");
            pX += (int)(menuArea.Width * 0.4);
            Atributes_maxLives_val = new Text(FontStatus_Little, new ProcessedText(), pX, pY, gm.PC.maxLives.ToString());

            pX += (int)(menuArea.Width * 0.15);
            pY -= (int)(menuArea.Height * 0.02);
            add = new Obj("../data/Textures/GAME/GUI/STAR_GRAY.dds", pX, pY, Obj.align.CENTER_X);
            add.isGUIObjectButUnscaled = true;
            addOn = new Obj("../data/Textures/GAME/GUI/STAR_COLOR.dds", pX, pY, Obj.align.CENTER_X);
            addOn.isGUIObjectButUnscaled = true;
            addClick = new Obj("../data/Textures/GAME/GUI/STAR_COLOR_BIG.dds", pX, pY, Obj.align.CENTER_X);
            addClick.isGUIObjectButUnscaled = true;
            menu_status.addItem(new Menu_Item("raiseMaxLives", add, addOn, addClick, Menu_Instances.Status_ButtonOnHover, null, Menu_Instances.Status_AtrMaxLivesClick));

            pY -= (int)(menuArea.Height * 0.006);
            pX += 4;
            Atributes_maxLives_plus = new Text(FontStatus_Small, null, pX, pY, "+1");

            //Skills:
            pX = menuArea.Left + lMargin;
            pY = menuArea.Top + (int)(menuArea.Height * 0.50);//50%

            Skills_initial = new Text(FontStatus_BIG, new ProcessedText(), pX, pY - 10, Lang.cur.UMIEJETNOSCI__U);
            Skills = new Text(FontStatus_Small, new ProcessedText(), pX + 7, pY, " "+Lang.cur.MIEJETNOSCI);

            //Skill Boost:
            pY += (int)(menuArea.Height * 0.07);
            Skill s = gm.PC.hasSkill(Skill.skillNames.Boost);
            int lvl = s == null ? 1 : s.level + 1;
            Skills_boost = new Text(FontStatus_Little, new ProcessedText(), pX, pY, Lang.cur.TRAMPY_MOCY+"("+lvl+")");
            
            pX += (int)(menuArea.Width * 0.55);
            pY -= (int)(menuArea.Height * 0.02);

            Obj root = new Obj("../data/Textures/GAME/GUI/STAR_GRAY.dds", pX, pY, Obj.align.CENTER_X); root.isGUIObjectButUnscaled = true;
            Obj rootOn = new Obj("../data/Textures/GAME/GUI/STAR_COLOR.dds", pX, pY, Obj.align.CENTER_X); rootOn.isGUIObjectButUnscaled = true;
            Obj rootClick = new Obj("../data/Textures/GAME/GUI/STAR_COLOR_BIG.dds", pX, pY, Obj.align.CENTER_X); rootClick.isGUIObjectButUnscaled = true;

            pX = 32; // absolute pre-positioning of whole group of other stars
            int tpCost;
            if (s == null) tpCost = new Skill(Skill.skillNames.Boost).baseTalentPointCost;
            else tpCost = s.talentPointCost;
            for (int i = 1; i < tpCost; i++)
            { // generate rest of 'needed' start as child of "main" star
                pX +=starXStep; pY = 0;
                add = new Obj("../data/Textures/GAME/GUI/STAR_GRAY.dds", pX, pY, Obj.align.CENTER_X);
                add.isGUIObjectButUnscaled = true; root.addChildObj(add);
                addOn = new Obj("../data/Textures/GAME/GUI/STAR_COLOR.dds", pX, pY, Obj.align.CENTER_X);
                addOn.isGUIObjectButUnscaled = true;  rootOn.addChildObj(addOn);
                addClick = new Obj("../data/Textures/GAME/GUI/STAR_COLOR_BIG.dds", pX, pY, Obj.align.CENTER_X);
                addClick.isGUIObjectButUnscaled = true; rootClick.addChildObj(addClick);         
            }
            menu_status.addItem(new Menu_Item("raiseBoost", root, rootOn, rootClick, Menu_Instances.Status_ButtonOnHover, null, Menu_Instances.Status_SkillBoost));

            //Skill IceBolt:
            pY = menuArea.Top + (int)(menuArea.Height * 0.64);//64%
            pX = menuArea.Left + lMargin;
            s = gm.PC.hasSkill(Skill.skillNames.IceBolt);
            lvl = s == null ? 1 : s.level + 1;
            Skills_icebolt = new Text(FontStatus_Little, new ProcessedText(), pX, pY, Lang.cur.LODOWY_POCISK+"(" + lvl + ")");

            pX += (int)(menuArea.Width * 0.55);
            pY -= (int)(menuArea.Height * 0.02);

            root = new Obj("../data/Textures/GAME/GUI/STAR_GRAY.dds", pX, pY, Obj.align.CENTER_X); root.isGUIObjectButUnscaled = true;
            rootOn = new Obj("../data/Textures/GAME/GUI/STAR_COLOR.dds", pX, pY, Obj.align.CENTER_X); rootOn.isGUIObjectButUnscaled = true;
            rootClick = new Obj("../data/Textures/GAME/GUI/STAR_COLOR_BIG.dds", pX, pY, Obj.align.CENTER_X); rootClick.isGUIObjectButUnscaled = true;

            pX = 32; // absolute pre-positioning of whole group of other stars

            if (s == null) tpCost = new Skill(Skill.skillNames.IceBolt).baseTalentPointCost;
            else tpCost = s.talentPointCost;
            for (int i = 1; i < tpCost; i++)
            { // generate rest of 'needed' start as child of "main" star
                pX += starXStep; pY = 0;
                add = new Obj("../data/Textures/GAME/GUI/STAR_GRAY.dds", pX, pY, Obj.align.CENTER_X);
                add.isGUIObjectButUnscaled = true; root.addChildObj(add);
                addOn = new Obj("../data/Textures/GAME/GUI/STAR_COLOR.dds", pX, pY, Obj.align.CENTER_X);
                addOn.isGUIObjectButUnscaled = true; rootOn.addChildObj(addOn);
                addClick = new Obj("../data/Textures/GAME/GUI/STAR_COLOR_BIG.dds", pX, pY, Obj.align.CENTER_X);
                addClick.isGUIObjectButUnscaled = true; rootClick.addChildObj(addClick);
            }
            menu_status.addItem(new Menu_Item("raiseBoost", root, rootOn, rootClick, Menu_Instances.Status_ButtonOnHover, null, Menu_Instances.Status_SkillIceBolt));

            //TO MENU BUTTON:
            pX = menuArea.Left+35; pY = menuArea.Bottom-210;
            Obj toMenu = new Obj("../data/Textures/GAME/GUI/STATUSCREEN_TOMENU.dds", pX, pY, Obj.align.CENTER_X);
            toMenu.isGUIObjectButUnscaled = true;
            Obj toMenuHover = new Obj("../data/Textures/GAME/GUI/STATUSCREEN_TOMENU_ACTIVE.dds", pX, pY, Obj.align.CENTER_X);
            toMenuHover.isGUIObjectButUnscaled = true;
            menu_status.addItem(new Menu_Item("toMenu", toMenu, toMenuHover, toMenuHover, Menu_Instances.Status_ButtonOnHover, null, Menu_Instances.Status_exitToMenuClick));

           
        }
        public void renderContents()
        {
            if (Level_initial == null) return;
            //level:
            Level_initial.Print();
            Level.Print();
            //talent pts
            TalentPts_initial.Print();
            TalentPts_initial2.Print();
            TalentPts.Print();
            for (int i = 0; i < TalentPtsStars.Count; i++)
                TalentPtsStars[i].Render();
            //atributes:
            Atributes_initial.Print();
            Atributes.Print();
            Atributes_speed.Print();
            Atributes_speed_val.Print();
            Atributes_speed_plus.Print();

            Atributes_maxLives.Print();
            Atributes_maxLives_val.Print();
            Atributes_maxLives_plus.Print();

            Skills_initial.Print();
            Skills.Print();
            Skills_boost.Print();
            Skills_icebolt.Print();

            pause.Render();
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    /// <summary>
    /// Static table containing all already
    /// calculated shortest ways between paths
    /// </summary>
    class ShortestWaysTable
    {
        public static ShortestWay[,] shortestWays{get; private set;}//[wpSrcID,wpDstID]

        static public void Initialize()
        {
            if (shortestWayAlgoritm.wnet.Count > 0)
                shortestWays = new ShortestWay[shortestWayAlgoritm.wnet.Last._id + 1, shortestWayAlgoritm.wnet.Last._id + 1];
            else
                new DebugMsg("There was no waynet when creating shortestWayTable!", DebugLVL.warn);
        }
        static public void addShortestWay(ShortestWay s)
        {
            if(s.wpList[0]!=null)
            {
                int j = s.wpList.Count-1;
                if(s.wpList[j]!=null)
                {
                    for (int i = 0; i < s.wpList.Count-1; i++)//left side
                    {
                        for (int k = j; k > i; k--)
                        {
                            int iID = s.wpList[i]._id, kID = s.wpList[k]._id;
                            if (shortestWays[iID, kID] == null)//if there is already this way entered don't overwrite it
                            {
                                ShortestWay middleway = s.Copy(i, k+1);
                                addOneShortestWay(middleway);          //add way to ways table
                                addOneShortestWay(middleway.Reverse());//add reversed way too
                            }
                        }
                    }
                }
            }   
        }
        static private void addOneShortestWay(ShortestWay s)
        {
            if (s.wpList[0] != null)
            {
                if (s.wpList[s.wpList.Count - 1] != null)
                {
                    int i1D = s.wpList[0]._id;
                    int i2D = s.wpList[s.wpList.Count - 1]._id;
                    shortestWays[i1D, i2D] = s;
                }
            }

        }
        static public ShortestWay getCopy(int i, int j)
        {
            if ((i > 0) && (shortestWayAlgoritm.wnet.Last._id >= i)
            && (j > 0) && (shortestWayAlgoritm.wnet.Last._id >= j) )
            {
                if (shortestWays[i, j] == null) return null;
                return shortestWays[i,j].Copy();
            }
            return null;
        }
    }
    class wayDirectionStack
    {
        public List<MOB.eDir> dirList{get; private set;}

        public wayDirectionStack()
        {
            dirList = new List<MOB.eDir>();
        }
        /// <summary>
        /// "pop's" first value from List
        /// </summary>
        /// <returns></returns>
        public MOB.eDir Pop()
        {
            //TODO: index out of range smtimes
            MOB.eDir ret = dirList[0];
            dirList.RemoveAt(0);
            return ret;
        }
        internal wayDirectionStack Copy()
        {
            wayDirectionStack copy = new wayDirectionStack();
            for (int i = 0; i < dirList.Count; i++)
                copy.dirList.Add(dirList[i]);
            return copy;
        }
        internal wayDirectionStack Copy(int beg,int end)
        {
            if (beg < 0) beg=0;
            if (end > dirList.Count) end = dirList.Count;

                wayDirectionStack copy = new wayDirectionStack();
            for (int i = beg; i < end ; i++)
                copy.dirList.Add(dirList[i]);
            return copy;
        }
        /// <summary>
        /// return reversed Direction stack
        /// (usable when creating same way but 
        /// reversing start and dst point)
        /// </summary>
        /// <returns></returns>
        internal wayDirectionStack Reverse()
        {
            //TODO: directions need to be reversed too! U->D; R->L ..etc
            wayDirectionStack reverse = new wayDirectionStack();
            reverse.dirList = new List<MOB.eDir>();
            for (int i = 0; i < dirList.Count; i++)
                reverse.dirList.Add(Reverse(dirList[dirList.Count - 1 - i]));
            return reverse;
        }
        public static MOB.eDir Reverse(MOB.eDir dir)
        {
            if (dir == MOB.eDir.L)
                return MOB.eDir.R;
            else if (dir == MOB.eDir.R)
                return MOB.eDir.L;
            else if (dir == MOB.eDir.U)
                return MOB.eDir.D;
            else //if (dir == MOB.eDir.D)
                return MOB.eDir.U;
            //else
            //    return null;
        }
    }
    class ShortestWay
    {
        /// <summary>
        /// First = start waypoint;
        /// Last = destination Point
        /// </summary>
        public List<Waypoint> wpList{get; private set;}
        public uint weight{get; set;}
        public wayDirectionStack route{get; private set;}

        public ShortestWay()
        {
            wpList = new List<Waypoint>();
            route = new wayDirectionStack();
        }
        public override string ToString()
        {
            string ret = "";
            for (int i = 0; i < route.dirList.Count; i++)
                ret += route.dirList[i]+"+";
            return ret;
        }
        public MOB.eDir Pop()
        {
            //TODO: + prevent from null at indexes
            //Way wp0wp1 = Way.getWay(wpList[0], wpList[1]);
            //if(wp0wp1 == null) return MOB.eDir.UNDEF;
            //else
            //{
                //TODO: getWay dont work properly, but this should be done even later
                //weight -= wp0wp1.weight;
                wpList.RemoveAt(0);
                return route.Pop();
            //}
        }
        /// <summary>
        /// Returns deep clone of object
        /// </summary>
        /// <returns></returns>
        public ShortestWay Copy()
        {
            ShortestWay copy = new ShortestWay();
            copy.wpList = new List<Waypoint>();
            for (int i = 0; i < wpList.Count; i++)
                copy.wpList.Add(wpList[i]);
            copy.weight = weight;
            copy.route = route.Copy();
            return copy;
        }
        /// <summary>
        /// returns deep copy of object
        /// </summary>
        /// <param name="beg">starting index (begin trim)</param>
        /// <param name="end">ending indec (end trim)</param>
        /// <returns></returns>
        public ShortestWay Copy(int beg, int end)
        {
            ShortestWay copy = new ShortestWay();
            copy.wpList = new List<Waypoint>();
            for (int i = beg; i < end; i++)
                copy.wpList.Add(wpList[i]);
            //Weight will be recalculated from scratch:
            copy.weight = 0;
            for (int i = beg; i < end-1; i++)
                copy.weight += Way.getWay(wpList[i], wpList[i + 1]).weight;
            copy.route = new wayDirectionStack();
            copy.route = route.Copy(beg,end);
            return copy;
        }
        public ShortestWay Reverse()
        {
            ShortestWay reverse = new ShortestWay();
            reverse.wpList = new List<Waypoint>();
            for (int i = 0; i < wpList.Count; i++)
                reverse.wpList.Add(wpList[wpList.Count-1-i]);
            reverse.weight = weight;
            reverse.route = new wayDirectionStack();
            reverse.route = route.Reverse();
            return reverse;
        }

        internal void generateDirectionStack()
        {
            for (int i = 0; i < wpList.Count - 1; i++)
            {
                if(wpList[i].Up != null)
                {
                    if (wpList[i].upWP == wpList[i+1])
                    {
                        route.dirList.Add(MOB.eDir.U);
                    }
                }
                if (wpList[i].Left != null)
                {
                    if (wpList[i].Left.end == wpList[i+1])
                    {
                        route.dirList.Add(MOB.eDir.L);
                    }
                }
                if (wpList[i].Down != null)
                {
                    if (wpList[i].downWP == wpList[i+1])
                    {
                        route.dirList.Add(MOB.eDir.D);
                    }
                }
                if (wpList[i].Right != null)
                {
                    if (wpList[i].rightWP == wpList[i+1])
                    {
                        route.dirList.Add(MOB.eDir.R);
                    }
                }
            }
        }
    }
    class wayInInfo
    {
        public Waypoint wp;
        public Waypoint elder; //when weight is modified then elder will be changed too
        public uint smallestWeight = uint.MaxValue;
        public wayInInfo(Waypoint wpoint)
        {
            wp = wpoint;
        }
        /// <summary>
        /// Call it always when new way to this path was found
        /// func will decide if weight need to be updated.
        /// </summary>
        /// <param name="eld"></param>
        /// <param name="smallestWeight"></param>
        public bool Update(Waypoint eld, uint weight)
        {
            if (weight < smallestWeight)
            {
                smallestWeight = weight;
                elder = eld;
                return true;
            }
            return false;
        }
    }
    class wayOutInfo
    {
        public Waypoint wp;
        public Waypoint elder;//from which wp way comes
        public uint addWeight;//weight to add when creating connection from this wp

        public wayOutInfo(Waypoint t, Waypoint eld, uint weight)
        {
            wp = t; elder = eld; addWeight = weight;
        }
    }
    class shortestWayAlgoritm
    { // with use of Dijkstra algorithm
        static public Waynet wnet;
        wayInInfo[] IN;
        wayOutInfo[] OUT;
        Waypoint destinationPoint;

        wayOutInfo lastAddedPoint;
        uint smallestWeight; int smallestWeightID;
        uint nxtSmallestWeight; int nxtSmallestWeightID;
        public ShortestWay result{get; private set;}
        private bool INArrayIsBlank()
        {
            for (int i = 0; i < IN.Length; i++)
            {
                if (IN[i] != null) return false;
            }
            return true;
        }
        public shortestWayAlgoritm(Waypoint startpoint, Waypoint dstpoint)
        {
            bool goThroughAllWays = false;
            if (dstpoint == null) goThroughAllWays = true;
            smallestWeight = nxtSmallestWeight =  uint.MaxValue;
            IN = new wayInInfo[wnet.Count];//declare array with size wnet waypoints count;
            OUT = new wayOutInfo[wnet.Count];
            //1.Create IN List
            for(int i=0;i<wnet.Count;i++)
            {
                    IN[i] = new wayInInfo(wnet[i]);
            }
            //2. Move startpoint to OUT list:
            IN[startpoint._id].smallestWeight = 0;
            moveToOutList(IN[startpoint._id]);
            lastAddedPoint = OUT[startpoint._id];
            smallestWeight -= 1;//for entering into while loop
            //::At this point we have done initiation stuff::

            while (((lastAddedPoint.wp != dstpoint) && (goThroughAllWays == false)) || ((goThroughAllWays == true) && (!INArrayIsBlank())))
            {// I will create graph till I'll add dest.point to it: 
             // (ADD: if dest.point!=null => then i will create full OUT table!)
                
                //1. Check's last added wp connections:
                Waypoint wp; uint weight;
                #region updateWeightByNewWP
                //Firstly, if there is smallestWeight is not present generete it and nxtSmallestWeight btw.
                if ((lastAddedPoint != OUT[startpoint._id]) && (smallestWeight == uint.MaxValue))
                {
                    findCurrentSmallestWeigth();
                    if ((smallestWeight == uint.MaxValue) && (nxtSmallestWeight == smallestWeight))
                    {
                        // paths are generated wrong, Waynet is broken apart :(
                        // TODO: Some error should be raised here
                        return;
                    }
                    
                }
                //A.UP
                if ((lastAddedPoint.wp.Up != null)&&(IN[lastAddedPoint.wp.upWP._id]!=null))
                {
                   wp = lastAddedPoint.wp.upWP;
                   weight = lastAddedPoint.addWeight + lastAddedPoint.wp.Up.weight;
                   // try to update info on this wp, it means
                   // if current weight is smaller than stored 
                   // in wayInInfo then write new elder (lastAddedWp) and new weight 
                   if(IN[wp._id]!=null)
                   IN[wp._id].Update(lastAddedPoint.wp, weight);
                   if (weight < smallestWeight)//this weight is new smallest weight:
                   {
                       if (smallestWeightID != wp._id)
                       { nxtSmallestWeight = smallestWeight; nxtSmallestWeightID = smallestWeightID; }
                       smallestWeight = weight; smallestWeightID = wp._id;
                   }
                   else if (weight < nxtSmallestWeight)
                   {
                       if (smallestWeightID != wp._id)
                       { nxtSmallestWeight = weight; nxtSmallestWeightID = wp._id; }
                   }
                }
                //B. RIGHT
                if ((lastAddedPoint.wp.Right != null) && (IN[lastAddedPoint.wp.rightWP._id] != null))
                {
                    wp = lastAddedPoint.wp.rightWP;
                    weight = lastAddedPoint.addWeight + lastAddedPoint.wp.Right.weight;
                    if (IN[wp._id] != null)
                        IN[wp._id].Update(lastAddedPoint.wp, weight);
                    if (weight < smallestWeight)//this weight is new smallest weight:
                    {
                        if (smallestWeightID != wp._id)
                        { nxtSmallestWeight = smallestWeight; nxtSmallestWeightID = smallestWeightID; }
                        smallestWeight = weight; smallestWeightID = wp._id;
                    }
                    else if (weight < nxtSmallestWeight)
                    {
                        if (smallestWeightID != wp._id)
                        { nxtSmallestWeight = weight; nxtSmallestWeightID = wp._id; }
                    }
                }
                //C. DOWN
                if ((lastAddedPoint.wp.Down != null) && (IN[lastAddedPoint.wp.downWP._id] != null))
                {
                    wp = lastAddedPoint.wp.downWP;
                    weight = lastAddedPoint.addWeight + lastAddedPoint.wp.Down.weight;
                    if (IN[wp._id] != null)
                        IN[wp._id].Update(lastAddedPoint.wp, weight);
                    if (weight < smallestWeight)//this weight is new smallest weight:
                    {
                        if (smallestWeightID != wp._id)
                        { nxtSmallestWeight = smallestWeight; nxtSmallestWeightID = smallestWeightID; }
                        smallestWeight = weight; smallestWeightID = wp._id;
                    }
                    else if (weight < nxtSmallestWeight)
                    {
                        if (smallestWeightID != wp._id)
                        { nxtSmallestWeight = weight; nxtSmallestWeightID = wp._id; }
                    }
                }
                //D. LEFT
                if ((lastAddedPoint.wp.Left != null) && (IN[lastAddedPoint.wp.leftWP._id] != null))
                {
                    wp = lastAddedPoint.wp.leftWP;
                    weight = lastAddedPoint.addWeight + lastAddedPoint.wp.Left.weight;
                    if(IN[wp._id]!=null)
                        IN[wp._id].Update(lastAddedPoint.wp, weight);
                    if (weight < smallestWeight)//this weight is new smallest weight:
                    {
                        if (smallestWeightID != wp._id)
                        { nxtSmallestWeight = smallestWeight; nxtSmallestWeightID = smallestWeightID; }
                        smallestWeight = weight; smallestWeightID = wp._id;
                    }
                    else if (weight < nxtSmallestWeight)
                    {
                        if (smallestWeightID != wp._id)
                        { nxtSmallestWeight = weight; nxtSmallestWeightID = wp._id; }
                    }
                }
                #endregion

                //2. Ways are updates, now it's time to choose way will smallest weight to get into:
                if(smallestWeightID>=0)
                  moveToOutList(IN[smallestWeightID]);
                if (goThroughAllWays == true)//generate shortestWay everytime new way was added
                {
                    generateShortestWay();
                    ShortestWaysTable.addShortestWay(result);
                }
                smallestWeight = nxtSmallestWeight;
                smallestWeightID = nxtSmallestWeightID;
                nxtSmallestWeight = uint.MaxValue; nxtSmallestWeightID = -1;
            }
            // OK, so now we have all needed informations it's time 
            // to create wayDirectionStack and then shortestWay object and add it to shortestWayTable
            // TODO: implement checking if aroute from lastAddedPoint to dstPoint already occurs if true, build new
            // shortestWay and wayDir.Stack with use of it.
            generateShortestWay();
        }
        private ShortestWay generateShortestWay()
        {
            result = new ShortestWay();
            if (lastAddedPoint.wp._id == 2)
            {
                int a = 2; if (a == 2) a++;
            }
            wayOutInfo wO = lastAddedPoint;
            result.weight = lastAddedPoint.addWeight;
            while(true)
            {
                result.wpList.Insert(0, wO.wp);
                if (wO.elder == null) break;
                wO = OUT[wO.elder._id];
            }
            result.generateDirectionStack();
            return result;
        }
        private void findCurrentSmallestWeigth()
        {
            for (int i = 0; i < wnet.Count; i++)
            {
                if (IN[i] != null)
                {
                    if (IN[i].smallestWeight < smallestWeight)
                    {
                        nxtSmallestWeight = smallestWeight; nxtSmallestWeightID = smallestWeightID;
                        smallestWeight = IN[i].smallestWeight;
                        smallestWeightID = i;
                    }
                }
            }
        }
        private void moveToOutList(wayInInfo wi)
        {
            if (wi == null) return;
            wayOutInfo _out = new wayOutInfo(wi.wp,wi.elder,wi.smallestWeight);
            IN[wi.wp._id] = null;
            OUT[_out.wp._id] = _out;
            lastAddedPoint = _out;
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    class Way
    {
        public uint weight{get; private set;}//distance between waypoints in grid units (right now: 48pixels per grid unit)
        public Waypoint begin{get; private set;}
        public Waypoint end{get; private set;} 
        public enum eWayDir {LR,RL,UD,DU}
        eWayDir direction;
        public Way(Waypoint beg, Waypoint e, uint wgth, eWayDir dir)
        {
            weight = wgth;
            direction = dir;
            begin = beg; end = e;

            if (direction == eWayDir.LR)
            {
                begin.Left = this;
                end.Right = this;
            }
            else if (direction == eWayDir.RL)
            {
                begin.Right = this;
                end.Left = this;
            }
            else if (direction == eWayDir.UD)
            {
                begin.Up = this;
                end.Down = this;
            }
            else if (direction == eWayDir.DU)
            {
                begin.Down = this;
                end.Up = this;
            }
        }

        /// <summary>
        /// Get way object connecting 2 waypoints
        /// </summary>
        /// <param name="wp1">waypoint 1</param>
        /// <param name="wp2">waypoint 2</param>
        /// <returns></returns>
        static public Way getWay(Waypoint wp1, Waypoint wp2)
        {
            if (wp1.upWP == wp2)
                return wp1.Up;
            else if (wp1.downWP == wp2)
                return wp1.Down;
            else if (wp1.leftWP == wp2)
                return wp1.Left;
            else if (wp1.rightWP == wp2)
                return wp1.Right;
            else
                return null;
        }
    }
}
using System;
using System.Collections.Generic;

using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    class Waynet
    {
        Waypoint[] wpArray;           // waypoints are hashed into array by x,y pos
        public Waypoint[] waypointsArray { get { return wpArray; } }
        const uint wpArraySize = 200; // 200 should be quite enough
        List<byte> wpPositions;
        public bool renderWaynet;
        public GameMap map { get; private set; }
        public Waynet(GameMap m)
        {
            First = null;
            Waypoint.lastid = 0; // reset's id's
            Waypoint.wnet = this;
            shortestWayAlgoritm.wnet = this;
            wpArray = new Waypoint[wpArraySize];
            wpPositions = new List<byte>();
            renderWaynet = false;
            map = m;
        }
        public uint generateHash(Waypoint wp)
        {
            return generateHash((uint)wp.x, (uint)wp.y);
        }
        public uint generateHash(uint x, uint y)
        {
            uint hash = (uint)(x * 5 + y * 9 + ((y - x) * (-2)));
            if (y > x) hash += 2 * y;
            else hash -= 4 * x;
            hash %= wpArraySize;
            return hash;
        }
        public Waypoint getWPAt(uint x, uint y)
        {
            uint i = generateHash(x, y), beg = i;
            if (wpArray[i] == null) return null;
            while ((wpArray[i].x != x) || (wpArray[i].y != y))
            {
                i = (i + 1) % wpArraySize;
                if (i == beg) return null;//wp not found,oh by the way whole array is filled :(
                if (wpArray[i] == null) return null; // there is no such waypoint in this array
            }
            return wpArray[i];
        }
        public void addWaypoint(Waypoint wp)
        {
            uint hash = generateHash(wp), i = hash;

            while (wpArray[i] != null)
            {
                i = (i + 1) % wpArraySize;
                if (i == hash) { new DebugMsg("wpArray overflowed!", DebugLVL.fault); return; }
            }
            wpArray[i] = wp;
            wpPositions.Add((byte)i);

            if (First == null) First = wp;
            Last = wp;
        }
        /// <summary>
        /// for debug propouses renders waypoints on map
        /// </summary>
        public void Render()
        {
            if (renderWaynet == true)
            {
                int gridS = GameManager.gridSize;
                for (int i = 0; i < wpPositions.Count; i++)
                {
                    int ways = 0; Obj o;
                    Waypoint wp = wpArray[wpPositions[i]];
                    if (wp.Down != null) ways++;
                    if (wp.Up != null) ways++;
                    if (wp.Left != null) ways++;
                    if (wp.Right != null) ways++;
                    if (ways == 1)
                        o = new Obj("../data/Textures/HLP_WP.jpg", wp.x * gridS + gridS / 2, wp.y * gridS + gridS / 2, Obj.align.CENTER_BOTH);
                    else if (ways == 2)
                        o = new Obj("../data/Textures/HLP_WP_2.jpg", wp.x * gridS + gridS / 2, wp.y * gridS + gridS / 2, Obj.align.CENTER_BOTH);
                    else if (ways == 3)
                        o = new Obj("../data/Textures/HLP_WP_3.jpg", wp.x * gridS + gridS / 2, wp.y * gridS + gridS / 2, Obj.align.CENTER_BOTH);
                    else
                        o = new Obj("../data/Textures/HLP_WP_4.jpg", wp.x * gridS + gridS / 2, wp.y * gridS + gridS / 2, Obj.align.CENTER_BOTH);

                    o.setRenderOnce();
                }
            }
        }
        /// <summary>
        /// Generate ways for each waypoint in waynet
        /// (if waynet is threaten
        /// </summary>
        public void generateWays()
        {
            for (int i = 0; i < wpPositions.Count; i++)
            {
                wpArray[wpPositions[i]].generateWays();
            }
        }
        /// <summary>
        /// indexer = index value means waypoint id, and it will
        /// return wp with that index
        /// </summary>
        /// <param name="number"></param>
        /// <returns></returns>
        public Waypoint this[int idx]
        {
            get
            {
                //check if idx is out of bounds:
                if ((idx < 0) || (idx > Last._id))
                    return null;
                else
                    return wpArray[wpPositions[idx]];

            }
        }
        public Waypoint Last { get; private set; }
        public Waypoint First { get; private set; }

        /// <summary>
        /// Gets count of current waynet Waypoints
        /// </summary>
        public int Count { get { return wpPositions.Count; } }
    }
}
using System;
using System.Collections.Generic;

using System.Text;
using System.Drawing;

namespace CookieMonster.CookieMonster_Objects
{
    class Waypoint
    {
        static public int lastid = 0;
        static public Waynet wnet;
        //position: (x,y are grid-scaled coords)
        int _x, _y;
        public int x { get { return _x; } }
        public int y { get { return _y; } }

        //Connected ways:
        private Way U, R, D, L;
        public Way Up    { get { return U; } set { if (U == null)U = value; } }
        public Way Right { get { return R; } set { if (R == null)R = value; } }
        public Way Down  { get { return D; } set { if (D == null)D = value; } }
        public Way Left  { get { return L; } set { if (L == null)L = value; } }

        //Connected waypoints (on other side of way)
        public Waypoint upWP    { get { if(U != null){if(U.begin==this)return U.end; else return U.begin;} return null; } }
        public Waypoint rightWP { get { if(R != null){if(R.begin==this)return R.end; else return R.begin;} return null; } }
        public Waypoint downWP  { get { if(D != null){if(D.begin==this)return D.end; else return D.begin;} return null; } }
        public Waypoint leftWP  { get { if(L != null){if(L.begin==this)return L.end; else return L.begin;} return null; } }

        private int id; public int _id { get { return id; } }
        public Waypoint(int x, int y)
        {
            id = lastid++;
            _x = x; _y = y;
        }
        public void generateWays()
        {
            GameMap map = wnet.map;
            uint steps = 0; int lastStepOnPortal = -1;
            Point curPos = new Point(x, y);

            if ((x == 21) && (y == 5))
            {
                bool doAfuckingBreakpointWitAFlip = true;
                if (doAfuckingBreakpointWitAFlip == true)
                {
                    doAfuckingBreakpointWitAFlip=false; //lol will it work now?
                }
            }

            //Direction: UP
            if(Up==null) //there is no way connected to up of waypoint
                while ( (map.getObjTypeFromPixel(curPos.X, curPos.Y) & GameMap.objType.COLLIDEABLE) != GameMap.objType.COLLIDEABLE)
                {
                    if (steps > 0)//don't check in first loop cuz it will be same wp as begining
                    {
                        //is there an waypoint?
                        Waypoint wp = wnet.getWPAt((uint)curPos.X, (uint)curPos.Y);
                        if (wp != null) { new Way(this, wp, steps, Way.eWayDir.UD); break; }
                    }
                    //not found an waypoint go to futher pos
                    if ((steps>lastStepOnPortal+1)&&((map.getObjTypeFromPixel(curPos.X, curPos.Y) & GameMap.objType.PORTAL) == GameMap.objType.PORTAL))
                    {//current point is passing through portal, find other side pos:
                        Point newPos = map.tryGoThroughPortal(curPos);
                        if (newPos == curPos) curPos.Y -= 1;
                        else
                        {
                            lastStepOnPortal = (int)steps;
                            curPos = newPos;
                        }
                    }
                    else if ((curPos.X >= 0) && (curPos.Y >= 0) && (curPos.Y < map.mapHeight) && (curPos.X < map.mapWidth))
                        curPos.Y -= 1;
                    else break;//end of map reached
                    steps=steps+1;
                }

            //Direction: Down
            steps = 0; lastStepOnPortal = -1; //comeback to wp Pos
            curPos.X = x; curPos.Y = y;
            if (Down == null) //there is no way connected to up of waypoint
                while ((map.getObjTypeFromPixel(curPos.X, curPos.Y) & GameMap.objType.COLLIDEABLE) != GameMap.objType.COLLIDEABLE)
                {
                    if (steps > 0)//don't check in first loop cuz it will be same wp as begining
                    {
                        //is there an waypoint?
                        Waypoint wp = wnet.getWPAt((uint)curPos.X, (uint)curPos.Y);
                        if (wp != null) { new Way(this, wp, steps, Way.eWayDir.DU); break; }
                    }
                    //not found an waypoint go to futher pos
                    if ((steps > lastStepOnPortal + 1) && ((map.getObjTypeFromPixel(curPos.X, curPos.Y) & GameMap.objType.PORTAL) == GameMap.objType.PORTAL))
                    {//current point is passing through portal, find other side pos:
                        Point newPos = map.tryGoThroughPortal(curPos);
                        if (newPos == curPos) curPos.Y += 1;
                        else
                        {
                            lastStepOnPortal = (int)steps;
                            curPos = newPos;
                        }
                    }
                    else if ((curPos.X >= 0) && (curPos.Y >= 0) && (curPos.Y < map.mapHeight) && (curPos.X < map.mapWidth))
                        curPos.Y += 1;
                    else break;//end of map reached
                    steps++;
                }

            //Direction: Left
            steps = 0; lastStepOnPortal = -1; //comeback to wp Pos
            curPos.X = x; curPos.Y = y;
            if (Left == null) //there is no way connected to up of waypoint
                while (!((map.getObjTypeFromPixel(curPos.X, curPos.Y) & GameMap.objType.COLLIDEABLE) == GameMap.objType.COLLIDEABLE))
                {
                    if (steps > 0)//don't check in first loop cuz it will be same wp as begining
                    {
                        //is there an waypoint?
                        Waypoint wp = wnet.getWPAt((uint)curPos.X, (uint)curPos.Y);
                        if (wp != null) { new Way(this, wp, steps, Way.eWayDir.LR); break; }
                    }
                    //not found an waypoint go to futher pos
                    if ((steps > lastStepOnPortal + 1) && ((map.getObjTypeFromPixel(curPos.X, curPos.Y) & GameMap.objType.PORTAL) == GameMap.objType.PORTAL))
                    {//current point is passing through portal, find other side pos:
                        Point newPos = map.tryGoThroughPortal(curPos);
                        if (newPos == curPos) curPos.X -= 1;
                        else
                        {
                            lastStepOnPortal = (int)steps;
                            curPos = newPos;
                        }
                    }
                    else if ((curPos.X >= 0) && (curPos.Y >= 0) && (curPos.Y < map.mapHeight) && (curPos.X < map.mapWidth))
                        curPos.X -= 1;
                    else break;//end of map reached
                    steps++;
                }

            //Direction: Right
            steps = 0; lastStepOnPortal = -1;//comeback to wp Pos
            curPos.X = x; curPos.Y = y;
            if (Right == null) //there is no way connected to up of waypoint
                while (!((map.getObjTypeFromPixel(curPos.X, curPos.Y) & GameMap.objType.COLLIDEABLE) == GameMap.objType.COLLIDEABLE))
                {
                    if (steps > 0)//don't check in first loop cuz it will be same wp as begining
                    {
                        //is there an waypoint?
                        Waypoint wp = wnet.getWPAt((uint)curPos.X, (uint)curPos.Y);
                        if (wp != null) { new Way(this, wp, steps, Way.eWayDir.RL); break; }
                    }
                    //not found an waypoint go to futher pos
                    if ((steps > lastStepOnPortal + 1) && ((map.getObjTypeFromPixel(curPos.X, curPos.Y) & GameMap.objType.PORTAL) == GameMap.objType.PORTAL))
                    {//current point is passing through portal, find other side pos:
                        Point newPos = map.tryGoThroughPortal(curPos);
                        if (newPos == curPos) curPos.X += 1;//nope, this wasn't a portal
                        else
                        {
                            lastStepOnPortal = (int)steps;
                            curPos = newPos;
                        }
                    }
                    else if ((curPos.X >= 0) && (curPos.Y >= 0) && (curPos.Y < map.mapHeight) && (curPos.X < map.mapWidth))
                        curPos.X += 1;
                    else break;//end of map reached
                    steps++;
                }

        }

        public Waypoint getWPAtDirection(MOB.eDir dir)
        {
            if (dir == MOB.eDir.U)
                return upWP;
            else if (dir == MOB.eDir.R)
                return rightWP;
            else if (dir == MOB.eDir.D)
                return downWP;
            else
                return leftWP;
        }
        public override string ToString()
        {
            return "WP" + _id.ToString() + "(" + x.ToString() + "," + y.ToString() + ")";
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using OpenTK.Input;

namespace CookieMonster.CookieMonster_Objects
{
    static class InputManager
    {
        private static bool _inputLogging;

        /// <summary>
        /// if flag is set to true
        /// Key press events will be handled and appended
        /// to buffer (setting bufer to FALSE clears it contents)
        /// </summary>
        public static bool inputLogging
        {
            get { return _inputLogging; }
            set
            {
                if (value == true) //clear only on setting to true
                    buffer.Clear();//clear buffer (new input text will be entered)

                _inputLogging = value;
            }
        }


        public static List<char> buffer = new List<char>();
        internal static void KeyDown(object sender, KeyboardKeyEventArgs k)
        {
          //  if (k.Key == Key.ShiftLeft || k.Key == Key.ShiftRight)
          //      shiftON = true;
          if (k.Key == Key.BackSpace && buffer.Count>0)
                buffer.RemoveAt(buffer.Count - 1);
        }

        internal static void KeyUp(object sender, KeyboardKeyEventArgs k)
        {
          //  if (k.Key == Key.ShiftLeft || k.Key == Key.ShiftRight)
          //      shiftON = false;
            
        }

        internal static void KeyPress(object sender, OpenTK.KeyPressEventArgs p)
        {
            // Don't let Win filename illegal characters in:
            if((p.KeyChar == '\b')
             ||(p.KeyChar == '\r')
             ||(p.KeyChar == '\\')
             ||(p.KeyChar == '/')
             ||(p.KeyChar == '?')
             ||(p.KeyChar == ':')
             ||(p.KeyChar == '"')
             ||(p.KeyChar == '|') )
                return;
            // TODO: ShowMenuTip("illegal character!");
            buffer.Add(p.KeyChar);
        }
        /// <summary>
        /// Pops input buffer, simply clearing it
        /// and putting his contents to returned string
        /// </summary>
        /// <returns></returns>
        public static string getInputBuffer()
        {
            string ret = new string(buffer.ToArray());
            //buffer.Clear();
            return ret;
        }
        public static void sendTobuffer(string param)
        {
            for (int i = 0; i < param.Length; i++)
                buffer.Add(param[i]);
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    class Lang
    {
        public enum language { PL, EN }
        public static Lang cur;

        #region the whole lang
        public string Nie, Tak;
        public string Wybierz_Profil;
        public string Usun_Profil;
        public string OK;
        public string stworz_nowy;
        public string Usunieto_Profil_n;
        public string Blad_Odczytu_profilu_o_nazwie;
        public string Komunikat_Bledu;
        public string Usuwam_Powyzszy_Profil;
        public string Dopalacze;
        public string umiejetnosci;
        public string punkty_0;
        public string punkty;
        public string Latwy;
        public string Normalny;
        public string Trudny;
        public string Hardcore;
        public string Wroc;
        public string Ile_Poziomow_w_GrzeDK;
        public string Tunel_NrDOT;
        public string CzasDDSpace;
        public string PoziomDDSpace;
        public string PktDDSpace;
        public string PktDTalentuDDSpace;
        public string ZyciaDDSpace;
        public string WczytajEXCL;
        public string Grafika;
        public string Dzwiek;
        public string Efekty;
        public string Muzyka;
        public string Rozdzieczlosc;
        public string Renderuj_Sciezki;
        public string POZIOM_FIRST;
        public string POZIOM_REST;
        public string PKT_TALENTU__P;
        public string PKT_TALENTU__T;
        public string KT_ALENTU;
        public string ATRYBUTY__A;
        public string TRYBUTY;
        public string SZYBKOSC;
        public string MAXDOT_ILDOT_ZYC;
        public string UMIEJETNOSCI__U;
        public string MIEJETNOSCI;
        public string TRAMPY_MOCY;
        public string LODOWY_POCISK;
        public string Inicjuje_Game_Menagera;
        public string Inicjuje_system_kolizji;
        public string wczytuje_poziom;
        public string tworze_GUI;
        public string alokuje_pamiec_tekstur;
        public string inicjalizuje_obiekty_poziomu;
        public string inicjuje_odtwarzacz_muzyki;
        public string Ustaw_Rozdzielczosc;
        #endregion

        public Lang(language l)
        {
            if (l == language.PL)
            {
                //profile:
                Wybierz_Profil                  = "Wybierz Profil:";
                Usun_Profil                     = "Usun Profil";
                OK                              = "OK";
                stworz_nowy                     = "(swtorz nowy)";
                Usunieto_Profil_n               = "Usunieto profil:\n";
                Blad_Odczytu_profilu_o_nazwie   = "Blad oczytu profilu o nazwie: ";
                Komunikat_Bledu                 = "Komunikat bledu:";
                Usuwam_Powyzszy_Profil          = "Usuwam powyzszy profil :(";
                //GUI:
                Dopalacze       = "dopalacze";
                umiejetnosci    = "umiejetnosci";
                punkty_0        = "punkty: 0";
                punkty          = "punkty: ";
                //Menu_Instances:
                Latwy                 = "Latwy";
                Normalny              = "Normalny";
                Trudny                = "Trudny";
                Hardcore              = "Hardcore";
                Wroc                  = "Wrc";
                Ile_Poziomow_w_GrzeDK = "Ile Poziomw w grze?";
                Tunel_NrDOT           = "Tunel nr.";
                CzasDDSpace           = "Czas: ";
                PoziomDDSpace         = "Poziom: ";
                PktDDSpace            = "Pkt: ";
                PktDTalentuDDSpace    = "Pkt. Talentu: ";
                ZyciaDDSpace          = "Zycia: ";
                WczytajEXCL           = "Wczytaj!";
                Grafika               = "Grafika";
                Dzwiek                = "Dzwiek";
                Efekty                = "Efekty";
                Muzyka                = "Muzyka";
                Rozdzieczlosc         = "Rozdzielczosc";
                Ustaw_Rozdzielczosc   = "(Ustaw rozdzielczosc)";
                Renderuj_Sciezki      = "Renderuj Sciezki";
                //Status screen:
                POZIOM_FIRST    = "P";
                POZIOM_REST     = "OZIOM";
                PKT_TALENTU__P  = "P";
                PKT_TALENTU__T  = "T";
                KT_ALENTU       = "KT.  ALENTU";
                ATRYBUTY__A     = "A";
                TRYBUTY         = "TRYBUTY";
                SZYBKOSC        = "SZYBKOSC";
                MAXDOT_ILDOT_ZYC= "MAX. IL. ZYC";
                UMIEJETNOSCI__U = "U";
                MIEJETNOSCI     = "MIEJETNOSCI";
                TRAMPY_MOCY     = "TRAMPY MOCY";
                LODOWY_POCISK   = "LODOWY POCISK";
                //Loading screen:
                Inicjuje_Game_Menagera       = "inicjuje Game Managera";
                Inicjuje_system_kolizji      = "inicjuje System Kolizji";
                wczytuje_poziom              = "wczytuje poziom";
                tworze_GUI                   = "tworze GUI";
                alokuje_pamiec_tekstur       = "alokuje pamiec tekstur";
                inicjalizuje_obiekty_poziomu = "inicjalizuje obiekty poziomu";
                inicjuje_odtwarzacz_muzyki   = "inicjuje odtwarzacz muzyki";

            }
            else if(l == language.EN)
            {
                //profile:
                Wybierz_Profil = "Choose Profile:";
                Usun_Profil = "Delete Profile";
                OK = "OK";
                stworz_nowy = "(Create new)";
                Usunieto_Profil_n = "Profile removed:\n";
                Blad_Odczytu_profilu_o_nazwie = "Error reading profile: ";
                Komunikat_Bledu = "Error Message:";
                Usuwam_Powyzszy_Profil = "I must delete this profile :(";
                //GUI:
                Dopalacze = "boosters";
                umiejetnosci = "   skills";
                punkty_0 = "points: 0";
                punkty = "points: ";
                //Menu_Instances:
                Latwy = "Easy";
                Normalny = "Normal";
                Trudny = "Hard";
                Hardcore = "Hardcore";
                Wroc = "Back";
                Ile_Poziomow_w_GrzeDK = "Levels to beat:";
                Tunel_NrDOT = "Tunnel nr.";
                CzasDDSpace = "Time: ";
                PoziomDDSpace = "Difficult Level: ";
                PktDDSpace = "Pts: ";
                PktDTalentuDDSpace = "Talent Pts: ";
                ZyciaDDSpace = "Lives: ";
                WczytajEXCL = "Load!";
                Grafika = "Graphics";
                Dzwiek = "Sound";
                Efekty = "Effects";
                Muzyka = "Music";
                Rozdzieczlosc = "Resolution";
                Ustaw_Rozdzielczosc = "(apply resolutiom)";
                Renderuj_Sciezki = "Render Paths";
                //Status screen:
                POZIOM_FIRST = "L";
                POZIOM_REST = "EVEL";
                PKT_TALENTU__P = "T";
                PKT_TALENTU__T = "";
                KT_ALENTU = "ALENT PTS.";
                ATRYBUTY__A = "A";
                TRYBUTY = "TRIBUTES";
                SZYBKOSC = "SPEED";
                MAXDOT_ILDOT_ZYC = "MAX. LIVES";
                UMIEJETNOSCI__U = "S";
                MIEJETNOSCI = "KILLS";
                TRAMPY_MOCY = "CHUCKS OF POWER";
                LODOWY_POCISK = "ICE BOLT";
                //Loading screen:
                Inicjuje_Game_Menagera = "initializing Game Managera";
                Inicjuje_system_kolizji = "initializing Collide System";
                wczytuje_poziom = "loading level";
                tworze_GUI = "creating GUI";
                alokuje_pamiec_tekstur = "allocating textures memory";
                inicjalizuje_obiekty_poziomu = "initializing level objects";
                inicjuje_odtwarzacz_muzyki = "initializing music player";

            }
            cur = this;
        }



    }
}
using System;
using System.Collections.Generic;
using System.Text;
using OpenTK;
using System.Drawing;

namespace CookieMonster.CookieMonster_Objects
{
    class lightAniData
    {
        public enum eLightDataType {undef, pos, scale, color };

        private List<int> keyframeData;

        public eLightDataType type;

        /// <summary>
        /// Returns number of keyframes in this Data
        /// </summary>
        public int Count
        {
            get { if (keyframeData != null)return keyframeData.Count; return 0; }
        }
        /// <summary>
        /// If lightData is scale type
        /// it will return scale of this object
        /// or set based on float scale
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public float this[int index]
        {
            get
            {
                if (type == eLightDataType.scale && index < Count)
                    return keyframeData[index] / 1000f;
                else
                    return float.NaN;
            }
            private set
            {
                if (type == eLightDataType.undef)
                    type = eLightDataType.scale;
                if (type != eLightDataType.scale) return;

                if (index == Count) keyframeData.Add((int)(value * 1000));
                else if (index < Count) keyframeData[index] = (int)(value * 1000);
            }
        }
        /// <summary>
        /// If lightData is pos type
        /// it will return point of this index
        /// or set Data based on passed point
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public Point this[int index]
        { // X(16)| Y(16) <- data structure
            get
            {
                if (type == eLightDataType.pos && index < Count)
                {
                    return new Point((keyframeData[index] & 0xFFFF) - 0xFFFF/2,
                                    ((keyframeData[index] >> 16) & 0xFFFF) - 0xFFFF/2);
                }
                else
                    return Point.Empty;
            }
            private set
            {
                if (type == eLightDataType.undef)
                    type = eLightDataType.pos;
                if (type != eLightDataType.pos) return;
               
                int x   = value.X + 0xFFFF / 2;
                int y   = value.Y + 0xFFFF / 2;
                int dat = (x & 0xFFFF);
                dat = (int)(dat & ~(0xFFFFu << 16)) | (y & 0xFFFF);
                if (index == Count) keyframeData.Add(dat);
                else if (index < Count) keyframeData[index] = dat;
            }
        }
    }
    class Light
    {
        public enum eLightType { STATIC, DYNAMIC };
        /// <summary>
        /// List of gradients that make up this Light
        /// </summary>
        List<radialGradient> gradsComposition;

        // Size,Positon,shape
        OpenTK.Vector2 centerPos;
        float size;

        public eLightType type { get; private set; }
        /// <summary>
        /// Creates Light base on passed radialGradient
        /// (then add it to the List of gradsComposition)
        /// </summary>
        /// <param name="grad"></param>
        public Light(eLightType typ, radialGradient grad)
        {
            type = typ;
            addLightToLightingEngine();
            size = grad.radius;
            centerPos = grad.centerPos;

            gradsComposition = new List<radialGradient>();
            gradsComposition.Add(grad);

            //correct position by current position of camera:
            move(new Vector2(EngineApp.Game.self.gameCamera.camOffsetX, EngineApp.Game.self.gameCamera.camOffsetY));
        }
        /// <summary>
        /// Creates Light base on passed radialGradient
        /// (then add it to the List of gradsComposition)
        /// </summary>
        /// <param name="grad"></param>
        /// <param name="pos">Light center position</param>
        public Light(eLightType typ, radialGradient grad, Vector2 pos)
            : this(typ,grad)
        {
            centerPos = pos;
            grad.Move(pos);//move gradient to pos passed as parameter
        }


        /// <summary>
        /// Creates Light based on list of passed radialGradients
        /// and for sure, adding them to composition of grads in this light.
        /// </summary>
        /// <param name="gradList"></param>
        public Light(eLightType typ, List<radialGradient> gradList)
        {
            type = typ;
            addLightToLightingEngine();
            if(gradList==null)
                throw new ArgumentNullException("radialGradient List passed to Light constructor is null!");
            if(gradList.Count==0)
                throw new Exception("radialGradient List passed to Light doesn't contain any radialGradients!");
            size = gradList[0].radius;
            centerPos = gradList[0].centerPos;

            //correct position by current position of camera:
            move(new Vector2(EngineApp.Game.self.gameCamera.camOffsetX, EngineApp.Game.self.gameCamera.camOffsetY));
        }
        /// <summary>
        /// Creates Light based on list of passed radialGradients
        /// and for sure, adding them to composition of grads in this light.
        /// </summary>
        /// <param name="gradList"></param>
        public Light(eLightType typ, List<radialGradient> gradList, Vector2 pos)
            : this(typ,gradList)
        {
            centerPos = pos;
            for (int i = 0; i < gradList.Count; i++)
                gradList[i].Move(pos);
        }
        /// <summary>
        /// Rendering a light to the buffer
        /// (it just render all radialGradients on list...
        /// </summary>
        public void Render()
        {
            for (int i = 0; i < gradsComposition.Count; i++)
                gradsComposition[i].drawGradientToBuffer();
        }
        public void setPos(Vector2 pos)
        {
            centerPos = pos;
            for (int i = 0; i < gradsComposition.Count; i++)
                gradsComposition[i].Move(pos);
        }
        public void move(Vector2 pos)
        {
            centerPos.Add(pos);
            for (int i = 0; i < gradsComposition.Count; i++)
                gradsComposition[i].moveRelatively(pos);
        }

        private void addLightToLightingEngine()
        {
            if (EngineApp.Game.self.lightEngine == null)
                throw new Exception("Light Engine is null!");
            EngineApp.Game.self.lightEngine.addLight(this);
        }

    }
}
using System;
using System.Collections.Generic;
using System.Text;
using OpenTK.Graphics;
using Engine;
using EngineApp;

namespace CookieMonster.CookieMonster_Objects
{
    class lightingEngine
    {
        List<Light> activeStaticLights = new List<Light>();
        List<Light> activeDynamicLights = new List<Light>();
        Color4 ambientLightColor = new Color4(10, 10, 10, 255);
        int lightMapBuffer;
        int lightMapTexture;
        int lightMapGrayTexture;
        /// <summary>
        /// How strong shadows are rendered
        /// </summary>
        public float lightMulStrength   = 0.1f;
        public float lightAddStrength   = 0.75f;
        public float lightColorStrength = 0f;

        /// <summary>
        /// if value is true static Lights lightmap need to be recalculated
        /// </summary>
        public bool staticLightsChanged { get; private set; }
        /// <summary>
        /// Flag is true when Render() method was already called
        /// in this frame.
        /// (It will be set to false at every rendering of static Lightmaps
        ///  - which is called at the begining of rendering frame)
        /// </summary>
        public bool lightsRendered { get; private set; }
        public void renderStaticLightmaps()
        {
            lightsRendered = false;
            // No changes in static lightning - no re-rendering
            if (!staticLightsChanged) return;

            if (activeStaticLights.Count==0) return; // no Lights, no ligthmaps!
            //Clear buffer to ambientLightColor:
            GL.ClearColor  (ambientLightColor.R, 
                            ambientLightColor.G, 
                            ambientLightColor.B, 
                            ambientLightColor.A);
            GL.Clear(ClearBufferMask.ColorBufferBit);
            //Render all lightmaps:
            for (int i = 0; i < activeStaticLights.Count; i++)
                activeStaticLights[i].Render();

            //Store rendered Lightmap to texture:
            //GL.Viewport(0, 0, 1024, 1024);
            //GL.DrawBuffer(DrawBufferMode.Back);
            GL.ReadBuffer(ReadBufferMode.Back);

            //Create Color lightmap:
            if(lightMapTexture == 0)
                GL.GenTextures(1,out lightMapTexture);
            GL.BindTexture(TextureTarget.Texture2D, lightMapTexture);
            //GL.CopyTexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, 0, 0, 1024, 1024,0);
            GL.CopyTexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, 0, 0, Game.self.Width, Game.self.Height, 0);
            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);

            // Create Inverted Grayscale Lightmap:
            if (lightMapGrayTexture== 0)
                GL.GenTextures(1, out lightMapGrayTexture);

            // save buffer to texture:
            GL.BindTexture(TextureTarget.Texture2D, lightMapGrayTexture);
            GL.CopyTexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Luminance,0, 0, Game.self.Width, Game.self.Height, 0);
            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Linear);
            
            // Clear back to black:
            GL.ClearColor(0,0,0,1);
            GL.Clear(ClearBufferMask.ColorBufferBit|ClearBufferMask.DepthBufferBit);

            // Rendered lightmap is most actual so we changing staticLightsChanged bool to false:
            staticLightsChanged = false;
        }
        public void clearAllLights()
        {
            activeStaticLights.Clear();
        }
        internal void addLight(Light light)
        {
            if (light.type == Light.eLightType.STATIC)
            {
                activeStaticLights.Add(light);
                staticLightsChanged = true;
            }
        }

        internal void Render()
        {
            // Light are render once per frame
            if (lightsRendered==true) return;
            lightsRendered = true;

            if (activeStaticLights.Count == 0) return; // no Lights, no ligthmaps!
            //BLENDING "ADD" Lightmaps rendering:
            if (lightAddStrength > 0f)
                renderLightMapsTexture(lightAddStrength, BlendingFactorSrc.One, BlendingFactorDest.One);
            //BLENDING "MULTIPLY" Lightmaps rendering:
            if (lightMulStrength > 0f)
                renderLightMapsTextureMultiply(lightMulStrength);

            //BLENDING "Color" Lightmaps rendering:
            if(lightColorStrength>0f)
                renderLightMapsTexture(lightColorStrength, BlendingFactorSrc.One, BlendingFactorDest.OneMinusSrcAlpha);

            // Back to old blend function:
            GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);


        }
        public void moveLights(OpenTK.Vector2 pos)
        {
            if (pos.Length > 0)//we really have some movement?
            {
                for (int i = 0; i < activeStaticLights.Count; i++)
                    activeStaticLights[i].move(pos);
            }
        }

        private void renderLightMapsTexture(float opacity, BlendingFactorSrc src, BlendingFactorDest dst)
        {
            int width = Game.self.Width, height = Game.self.Height;
            GL.Enable(EnableCap.Blend);
            GL.BlendFunc(src, dst);
            GL.Color4(opacity, opacity, opacity, opacity);
            GL.BindTexture(TextureTarget.Texture2D, lightMapTexture);
            GL.BlendColor(0f, 0f, 0f, 1f);
            GL.Begin(BeginMode.Quads);
                GL.TexCoord2(0, 1);
                GL.Vertex2(0, 0);
                GL.TexCoord2(1, 1);
                GL.Vertex2(width, 0);
                GL.TexCoord2(1, 0);
                GL.Vertex2(width, height);
                GL.TexCoord2(0, 0);
                GL.Vertex2(0, height);
            GL.End();
            //GL.Disable(EnableCap.Blend);
        }
        private void renderLightMapsTextureMultiply(float opacity)
        {
            int width = Game.self.Width, height = Game.self.Height;
            GL.Enable(EnableCap.Blend);
            GL.BlendFunc(BlendingFactorSrc.DstColor, BlendingFactorDest.OneMinusSrcAlpha);
            GL.Color4(opacity, opacity, opacity, opacity);
            GL.BindTexture(TextureTarget.Texture2D, lightMapGrayTexture);
            GL.BlendColor(0f, 0f, 0f, 1f);
            GL.Begin(BeginMode.Quads);
                GL.TexCoord2(0, 1);
                GL.Vertex2(0, 0);
                GL.TexCoord2(1, 1);
                GL.Vertex2(width, 0);
                GL.TexCoord2(1, 0);
                GL.Vertex2(width, height);
                GL.TexCoord2(0, 0);
                GL.Vertex2(0, height);
            GL.End();
            //GL.Disable(EnableCap.Blend);
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using EngineApp;
using OpenTK.Input;
using QuickFont;
using OpenTK.Graphics;

namespace CookieMonster.CookieMonster_Objects
{
    
    class Menu
    {
        public string name { get; private set; }
        private bool clearViewportOnOpen;
        public delegate void funcOnOpen();
        funcOnOpen onOpen;
        public delegate void funcOnUpdate();
        funcOnUpdate onUpdate;
        public delegate void funcOnRender();
        funcOnRender onRender;
        private bool opened;
        private bool menuFadeIn;
        private bool menuFadeOut;
        private bool fadeWithBlack;
        public string menuName{ get {return name;}}

        private List<Menu_Item> items;
        public Menu_Input_Item inputItem { get; private set; }
        private bool menuDisabled;
        private Timer fadeOutTimer; public bool fadingOut { get { return fadeOutTimer.enabled; } }
        private Timer fadeInTimer;
        public Timer submenuTimer { get; private set; }//enabled when adding submenu
        public Timer submenuCloseTimer { get; private set; }

        #region static fonts
        //Static fonts: (template)
        private const int fontSize = 26;
        public static QFont font = TextManager.newQFont("CheriPL.ttf", fontSize, FontStyle.Regular, false,      new Color4(210, 225, 250, 245));
        public static QFont font_Hover = TextManager.newQFont("CheriPL.ttf", fontSize, FontStyle.Regular, true, new Color4(70, 120, 255, 255));
        public static QFont font_Click = TextManager.newQFont("CheriPL.ttf", fontSize, FontStyle.Regular, true, new Color4(240, 240, 240, 245));

        private const int fontSizeSmall = 19;
        public static QFont fontSmall = TextManager.newQFont("CheriPL.ttf", fontSizeSmall, FontStyle.Regular, true,       new Color4(210, 225, 250, 245));
        public static QFont fontSmall_Hover = TextManager.newQFont("CheriPL.ttf", fontSizeSmall, FontStyle.Regular, true, new Color4(50, 150, 255, 255));
        public static QFont fontSmall_Click = TextManager.newQFont("CheriPL.ttf", fontSizeSmall, FontStyle.Regular, true, new Color4(255, 255, 255, 255));
        public static QFont fontSmall_Disabled = TextManager.newQFont("CheriPL.ttf", fontSizeSmall, FontStyle.Regular, true, new Color4(125, 125, 125, 255));
        
        private const int fontSizeSmallAlt = 25;
        public static QFont fontSmallAlt = TextManager.newQFont("Rumpelstiltskin.ttf", fontSizeSmallAlt, FontStyle.Regular, true,       new Color4(240, 240, 240, 245));
        public static QFont fontSmallAlt_Hover = TextManager.newQFont("Rumpelstiltskin.ttf", fontSizeSmallAlt, FontStyle.Regular, true, new Color4(50, 150, 255, 255));
        public static QFont fontSmallAlt_Click = TextManager.newQFont("Rumpelstiltskin.ttf", fontSizeSmallAlt, FontStyle.Regular, true, new Color4(255, 255, 255, 255));
        #endregion

        static Menu()
        {
            // There was a setting of colours of static QFont objects, it's no longer needed
            // plus it would be invaild (color need to be known at calling of TextMan.newQFont;
        }

        public Menu(string n, funcOnOpen _onOpen)
        {
            name = n;
            onOpen = _onOpen;
            opened = false;
            menuFadeIn = menuFadeOut = fadeWithBlack = false;
            clearViewportOnOpen = true;
            fadeOutTimer = new Timer(Timer.eUnits.MSEC, 200, 0, true, false);
            fadeInTimer = new Timer(Timer.eUnits.MSEC, 400, 0, true, false);
            submenuTimer = new Timer(Timer.eUnits.MSEC, 300, 0, true, false);
            submenuCloseTimer = new Timer(Timer.eUnits.MSEC, 190, 0, true, false);

            items = new List<Menu_Item>();
        }
        public Menu(string n, funcOnOpen _onOpen, Obj cur) : this(n,_onOpen)
        {
            Menu_Manager.cursor = cur;
        }
        public Menu(string n, funcOnOpen _onOpen,funcOnUpdate _onUpdate, Obj cur) : this(n, _onOpen, cur)
        {
            onUpdate = _onUpdate;
        }
        public Menu(string n, funcOnOpen _onOpen,funcOnUpdate _onUpdate, funcOnRender _onRender, Obj cur) : this(n, _onOpen,_onUpdate, cur)
        {
            onRender = _onRender;
        }
        private bool mouseWasPresed;
        private bool fadeInTimerWasActive;
        private bool fadeOutTimerWasActive;
        private bool submenuTimerWasActive;
        private bool submenuCloseTimerWasActive;
        public void Update() 
        {
            if (!opened)
            {
                if(onOpen!=null)
                onOpen();
                opened = true;
            }
            else
            {//update & stuff:
                Obj cursor = Menu_Manager.cursor;
                if(onUpdate!=null) onUpdate();
                
                if (!menuDisabled)
                {
                    bool somewhereCursorIn = false;
                    //Checks for mouse state:
                    bool triggerItemClick = false; //if flags is sat to true, it will trigger Click event on first item that mouse is in
                    if (Game.self.menuManager.getButtonState(MouseButton.Left))
                    {
                        mouseWasPresed = true;
                    }
                    else if (mouseWasPresed && Game.self.menuManager.getButtonState(MouseButton.Left) == false)
                    { //mouse was pressed, and now released ->trigger onClick event
                        triggerItemClick = true;
                        mouseWasPresed = false;
                    }
                    else
                        mouseWasPresed = false;
                               

                    //update input Item first:
                    if (inputItem != null)
                    {
                        inputItem.Update();
                        //checks if cursor is in area of input-item:
                        if (inputItem.CursorIn(cursor.x, cursor.y))
                        {
                            somewhereCursorIn = true;
                            if (triggerItemClick) inputItem._onMouseClick();
                        }
                    }

                    //last items == last rendered(On Top) -> so they're more important
                    for (int i = items.Count-1; i >= 0; i--)
                    {
                        if ((!somewhereCursorIn)&&(items[i].CursorIn(cursor.x, cursor.y)))
                        {
                            if (triggerItemClick) items[i]._onMouseClick();
                            items[i]._onMouseIn();
                            somewhereCursorIn = true;
                        }
                        else
                            items[i]._onMouseOut();
                    }
                }

                //check for fades
                if (fadeInTimer.enabled)
                {
                    fadeInTimerWasActive = true;
                    for (int i = 0; i < items.Count; i++)
                        items[i].fadeIn(fadeInTimer);
                    if (inputItem!=null) inputItem.fadeIn(fadeInTimer);
                }
                else if (fadeInTimerWasActive)
                { // BUGFIX: when timer was last hit not on ideal 0 value till-the end it will leave some alpha
                  // so we need to call fadeIn once again when .enabled is no longer true
                    fadeInTimerWasActive = false;
                    for (int i = 0; i < items.Count; i++)
                        items[i].fadeIn(Timer.zeroTimer);
                    if (inputItem != null) inputItem.fadeIn(Timer.zeroTimer);
                }
                if (fadeOutTimer.enabled)
                {
                    fadeOutTimerWasActive = true;
                    for (int i = 0; i < items.Count; i++)
                        items[i].fadeOut(fadeOutTimer);//push fadeInTimer so item will be able to 
                    if (inputItem != null) inputItem.fadeOut(fadeOutTimer);
                }
                else if (fadeOutTimerWasActive)
                { // BUGFIX: when timer was last hit not on ideal 0 value till-the end it will leave some alpha
                    // so we need to call fadeIn once again when .enabled is no longer true
                    fadeOutTimerWasActive = false;
                    for (int i = 0; i < items.Count; i++)
                        items[i].fadeOut(Timer.zeroTimer);
                    if (inputItem != null) inputItem.fadeOut(Timer.zeroTimer);
                }
                //check for submenu fades:
                if (submenuTimer.enabled)
                {
                    submenuTimerWasActive = true;
                    for (int i = 0; i < items.Count; i++)
                        items[i].submenu(submenuTimer);//push fadeInTimer so item will be able to 
                    if (inputItem != null) inputItem.submenu(submenuTimer);
                }
                else if (submenuTimerWasActive == true)
                {//BUGFIX:
                    submenuTimerWasActive = false;
                    for (int i = 0; i < items.Count; i++)
                        items[i].submenu(Timer.zeroTimer);//push fadeInTimer so item will be able to 
                    if (inputItem != null) inputItem.submenu(Timer.zeroTimer);
                }
                if (submenuCloseTimer.enabled)
                {
                    submenuCloseTimerWasActive = true;
                    for (int i = 0; i < items.Count; i++)
                        items[i].submenuClose(submenuCloseTimer);//push fadeInTimer so item will be able to 
                    if (inputItem != null) inputItem.submenuClose(submenuCloseTimer);
                }
                else if (submenuCloseTimerWasActive == true)
                {//BUGFIX:
                    submenuCloseTimerWasActive = false;
                    for (int i = 0; i < items.Count; i++)
                        items[i].submenuClose(Timer.zeroTimer);//push fadeInTimer so item will be able to 
                    if (inputItem != null) inputItem.submenuClose(Timer.zeroTimer);
                }
                   
            };
        }
        public void Render()
        {
            //first render items without mouse over:
            for (int i = 0; i < items.Count; i++)
            {
                if(!items[i].inHover)
                items[i].Render();
            }   
            //ther render hovered item:
            for (int i = 0; i < items.Count; i++)
            {
                if(items[i].inHover)
                items[i].Render();
            }
            //at least render input items:
            if (inputItem != null) inputItem.Render();

            if(onRender!=null) onRender(); //if there is any onRender function, call it
            //render cursor overlaying all rest: (but render it only once!)
            //if (cursor != null) { cursor.Render(); Game.self.menuManager.cursorRendered = true; }
        }
        public void addItem(Menu_Item itm)
        {
            itm.setOwner(this);
            items.Add(itm);
        }
        public void addInputItem(Menu_Input_Item inputItm)
        {
            ((Menu_Item)inputItm).setOwner(this);
            inputItem = inputItm;
        }
        public void clearMenuItems()
        {
            items.Clear();
        }
        public void removeMenuItem(Menu_Item itm)
        {
            items.Remove(itm);
        }
        public Menu_Item getItem(int index)
        {
            if (index < items.Count)
                return items[index];
            else
                return null;
        }
        public Menu_Item getItemByName(string Name)
        {
            for (int i = 0; i < items.Count; i++)
                if (items[i].name == Name)
                    return items[i];
            return null;
        }
        public void clearOpenedFlag()
        {
            opened = false;
        }

        public void fadeOut()
        {
            fadeOutTimer.start();
        }

        public void fadeIn()
        {
            fadeInTimer.start();
        }

        internal void addedSubmenu()
        {
            submenuTimer.start();
        }

        internal void closeSubmenu()
        {
            submenuCloseTimer.start();
        }
        public override string ToString()
        {
            return menuName;
        }
        /// <summary>
        /// Disabling menu causes menu_items are no longer
        /// hover-able
        /// </summary>
        public void Disable()
        {
            menuDisabled = true;
        }
        /// <summary>
        /// Back to default Menu state (now you can hover menu items)
        /// </summary>
        public void Enable()
        {
            menuDisabled = false;
        }

    }
}
using System;
using System.Collections.Generic;
using System.Text;
using QuickFont;

namespace CookieMonster.CookieMonster_Objects
{
    class Menu_Input_Item : Menu_Item
    {
        Obj BG;//cursor - that "blinking" line
        private Timer cursorON;
        private Timer cursorOFF;
        private bool lastCursorWasON = false;
        private int frameLenght;
        private bool active;
        public string defaultValue { get; private set; }
        public bool sendDefaultValueToBuffer;

        public Menu_Input_Item( float x, float y, QFont _font) : base( "",x,y,_font)
        {
            cursorON = new Timer(Timer.eUnits.MSEC, 500, 0, true, false);
            cursorOFF = new Timer(Timer.eUnits.MSEC, 500, 0, true, false);
            frameLenght = int.MaxValue;
        }
        public Menu_Input_Item(float x, float y, QFont _font,Obj bg)
            : this( x, y, _font)
        {
            BG = bg;
        }
        public Menu_Input_Item(float x, float y, QFont _font, Obj bg, string defaultVal, bool sendTobuffer)
            : base(defaultVal, x, y, _font)
        {
            cursorON = new Timer(Timer.eUnits.MSEC, 500, 0, true, false);
            cursorOFF = new Timer(Timer.eUnits.MSEC, 500, 0, true, false);
            frameLenght = int.MaxValue;
            BG = bg;
            defaultValue = defaultVal;
            sendDefaultValueToBuffer = sendTobuffer;
        }
        public Menu_Input_Item(float x, float y, QFont _font,QFont _fontHover, Obj bg, string defaultVal, bool sendTobuffer)
            : base(defaultVal, x, y, _font, _fontHover)
        {
            cursorON = new Timer(Timer.eUnits.MSEC, 500, 0, true, false);
            cursorOFF = new Timer(Timer.eUnits.MSEC, 500, 0, true, false);
            frameLenght = int.MaxValue;
            BG = bg;
            defaultValue = defaultVal;
            sendDefaultValueToBuffer = sendTobuffer;
        }
        public Menu_Input_Item(float x, float y, QFont _font, QFont _fontHover, Obj bg, string defaultVal, bool sendTobuffer, mouseEvt click)
            : base(defaultVal, x, y, _font, _fontHover,_fontHover,click)
        {
            cursorON = new Timer(Timer.eUnits.MSEC, 500, 0, true, false);
            cursorOFF = new Timer(Timer.eUnits.MSEC, 500, 0, true, false);
            frameLenght = int.MaxValue;
            BG = bg;
            defaultValue = defaultVal;
            sendDefaultValueToBuffer = sendTobuffer;
        }
        public void _onMouseClick()
        {
            InputManager.inputLogging = true;
            base._onMouseClick();
            active = true;
            if (sendDefaultValueToBuffer)
                InputManager.sendTobuffer(defaultValue);
        }
        public void Update()
        {
            if (!active) return;

            int start = InputManager.getInputBuffer().Length - frameLenght;
            if (start < 0) start = 0;
            base.value = InputManager.getInputBuffer().Substring(start);

            if (lastCursorWasON && !cursorON.enabled)
            {
                lastCursorWasON = false;
                cursorOFF.start();
            }
            else if (!lastCursorWasON && !cursorOFF.enabled)
            {
                lastCursorWasON = true;
                cursorON.start();
            }
            if (lastCursorWasON)
                base.value += "|";
        }
        public void Render()
        {
            if (BG != null)
                BG.Render();

            base.Render();
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using EngineApp;
using OpenTK;
using OpenTK;
using QuickFont;
using System.Drawing;
using OpenTK.Graphics;

namespace CookieMonster.CookieMonster_Objects
{
    static public class Menu_Instances
    {
        public static void Menu_Nothing()
        {
            //YAAY!
        }
        public static void MENU_COOKIE_EYEBLINK()
        {
            Sound blink = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BLINK.ogg", false, true);
        }
        static public void Menu_InitializeBackground()
        {
            Viewport mViewport = Game.self.menuViewport;

            Obj Clouds = new Obj("../data/Textures/MENU/menu_clouds.dds", 0.5, 0.5, Obj.align.CENTER_BOTH, true);
            Obj Clouds2 = new Obj("../data/Textures/MENU/menu_clouds.dds", 0.5, 0.5, Obj.align.CENTER_BOTH, true);
            Clouds2.x -= Viewport.guiBase_width; // so it will ends where first one starts

            //Obj Sun = new Obj("../data/Textures/MENU/menu_sun.dds", 0.20, 0.34, Obj.align.CENTER_BOTH, true);
            //Obj_Animation sunAni = new Obj_Animation(Sun, Sun.x, Sun.y, 0.01);
            //sunAni.addKeyframe(Sun.x, Sun.y+100, 0.01);
            //Sun.addAni(sunAni);

            mViewport.addObject(new Obj("../data/Textures/MENU/menu_sky.dds", 0.5, 0.5, Obj.align.CENTER_BOTH, true));
            //mViewport.addObject(Sun);
            mViewport.addObject(Clouds);
            mViewport.addObject(Clouds2);
            Clouds.addAni(new Obj_Animation(Clouds, Clouds.x + Viewport.guiBase_width, Clouds.y, 0.202, 1.0, true));
            // Clouds.addAniKeyframe(Clouds.x - Clouds.width, Clouds.y, 9999);

            Clouds2.addAni(new Obj_Animation(Clouds2, Clouds2.x + Viewport.guiBase_width, Clouds2.y, 0.202, 1.0, true));
            // Clouds2.addAniKeyframe(Clouds2.x - Clouds2.width, Clouds2.y, 9999);

            mViewport.addObject(new Obj("../data/Textures/MENU/menu_landscape.dds", 0.5, 0.5, Obj.align.CENTER_BOTH, true));


            Obj cookie = new Obj("../data/Textures/MENU/COOKIE_MENU_A0.dds", 0.1448, 0.6074, Obj.align.CENTER_BOTH, true);
            cookie.setTexAniLoopType(Obj_texAni.eLoopType.REWIND);
            cookie.setTexAniFPS(18);
            mViewport.addObject(cookie);

            Obj tree = new Obj("../data/Textures/MENU/MENU_TREE_A0.dds", 0.58, 0.28, Obj.align.CENTER_BOTH, true);
            tree.setTexAniLoopType(Obj_texAni.eLoopType.REWIND);
            tree.setTexAniFPS(6);
            mViewport.addObject(tree);

            Obj cookieEyes = new Obj("../data/Textures/MENU/MENU_COOKIE_EYESBLINK.dds", 0.1175, 0.532, Obj.align.LEFT, true);
            Obj cookieEyesHlp = new Obj("../data/Textures/HLP_FullAlpha.dds", 0.0, 0.0, Obj.align.RIGHT, false);
            cookieEyesHlp.setIdleAni(cookieEyes, new Timer(Timer.eUnits.MSEC, 7 * 1000, 6 * 1000, true, false), new Timer(Timer.eUnits.FPS, 3, 2, true, false), Menu_Instances.MENU_COOKIE_EYEBLINK);
            mViewport.addObject(cookieEyesHlp);

            Obj fire = new Obj("../data/Textures/MENU/MENU_FIRE_A0.dds", 0.2905, 0.402, Obj.align.CENTER_BOTH, true);
            fire.setTexAniLoopType(Obj_texAni.eLoopType.DEFAULT);
            fire.setTexAniFPS(20);
            fire.ScaleAbs = 2.5;
            mViewport.addObject(fire);

            Obj fireLens = new Obj("../data/Textures/MENU/MENU_FIRE_LENS.dds", 0.285, 0.595, Obj.align.CENTER_BOTH, true);
            mViewport.addObject(fireLens);

            Obj logo = new Obj("../data/Textures/MENU/MENU_LOGO.dds", 0.960, 0.905, Obj.align.CENTER_BOTH, false);
            mViewport.addObject(logo);

            //"Sun" light:
            Game.self.lightEngine.clearAllLights();
            new Light(Light.eLightType.STATIC,new radialGradient(new Vector2(200f,260f),600f,
                                         new Vector4(1f,0.5f,0.0f,0.95f),
                                         new Vector4(1f,0f,0f,0f)));


        }
        static public void Menu_Profile_Open()
        {
            Menu_InitializeBackground();
            Menu_StartBGMusic();

            Menu profile = Game.self.menuManager.getMenuByName("MENU_PROFILE");
            profile.clearMenuItems();            

            Profile.Menu_GenerateProfileMenu();
        }
        private static void Menu_StartBGMusic()
        {
            //start bg music:
            Sound bg_music = new Sound(Sound.eSndType.MUSIC, "../data/Sounds/MENU_THEME.ogg", true, true);
            bg_music.volume = 0.87;
            if (Game.self.SoundMan.getSoundByFilename("../data/Sounds/MENU_BIRDS_BG.ogg") == null)
            {
                Sound bg_birds = new Sound(Sound.eSndType.MUSIC, "../data/Sounds/MENU_BIRDS_BG.ogg", true, true);
                bg_birds.volume = 0.15;
            }
        }
        static public void Main_OnLoad()
        {
            // IF MENU_STATUS is already created it means that
            // Game was already started, then player went to status screen and come back to main menu
            // to recreate it so we doing it:
            if (Game.self.menuManager.getMenuByName("MENU_STATUS") != null)
            {
                Menu_InitializeBackground();
                Menu_StartBGMusic();
            }
            // Turn on ability to enter "theather mode":
            Game.self.menuManager.canEnterIdleMode = true;

            // add menu items:
            // NOTE: Obj.align got to be LEFT!!! (Default)
            Menu main = Game.self.menuManager.getMenuByName("MENU_MAIN");
            main.clearMenuItems();
            Obj item,itemH,itemC;
            double hoverscale = 1.2;
            //NEW GAME:
            item = new Obj("../data/Textures/MENU/MENU_ITEM_NEWGAME.dds", 0.6, 0.3, Obj.align.LEFT, true);
            itemH = new Obj("../data/Textures/MENU/MENU_ITEM_NEWGAME_A.dds", 0.6, 0.3, Obj.align.LEFT, true);
            itemH.x -= (int)(0.05 * itemH.orginalWidth); itemH.y -= (int)(0.1 * itemH.orginalHeight); itemH.ScaleAbs = 1.2;
            //itemH.addAni(new Obj_Animation(itemH, itemH.x - 18, itemH.y - 6, 18.0, hoverscale,true));
            //itemH.getObjAnimation().setLoopType(Obj_Animation.eLoopType.None);
            main.addItem(new Menu_Item("MAIN_NEWGAME",item,itemH,null,null,null,Menu_NewGame_Click));
            
            //CONTINUE:
            item = new Obj("../data/Textures/MENU/MENU_ITEM_CONTINUE.dds", 0.6, 0.345, Obj.align.LEFT, true);
            itemH = new Obj("../data/Textures/MENU/MENU_ITEM_CONTINUE_A.dds", 0.6, 0.345, Obj.align.LEFT, true);
            itemH.x -= (int)(0.05 * itemH.orginalWidth); itemH.y -= (int)(0.1 * itemH.orginalHeight); itemH.ScaleAbs = 1.2;
            Obj itemDisabled = new Obj("../data/Textures/MENU/MENU_ITEM_CONTINUE_D.dds", 0.6, 0.345, Obj.align.LEFT, true);
            //itemH.addAni(new Obj_Animation(itemH, itemH.x - 18, itemH.y - 6, 18.0, hoverscale,true));
            //itemH.getObjAnimation().setLoopType(Obj_Animation.eLoopType.None);
            if(Profile.currentProfile.save!=null)
                main.addItem(new Menu_Item("MAIN_CONTINUE", item, itemH, null, null, null, Menu_LoadGame_Click));
            else//TODO: Disabled Continue button
                main.addItem(new Menu_Item("MAIN_CONTINUE", itemDisabled, itemDisabled, null, Menu_Nothing, null, null));

            //OPTIONS:
            item = new Obj("../data/Textures/MENU/MENU_ITEM_OPTIONS.dds", 0.6, 0.408, Obj.align.LEFT, true);
            itemH = new Obj("../data/Textures/MENU/MENU_ITEM_OPTIONS_A.dds", 0.6, 0.408, Obj.align.LEFT, true);
            itemH.x -= (int)(0.05 * itemH.orginalWidth); itemH.y -= (int)(0.1 * itemH.orginalHeight); itemH.ScaleAbs = 1.2;
            //itemH.addAni(new Obj_Animation(itemH, itemH.x - 18, itemH.y - 6, 18.0, hoverscale,true));
            //itemH.getObjAnimation().setLoopType(Obj_Animation.eLoopType.None);
            main.addItem(new Menu_Item("MAIN_OPTIONS", item, itemH, null, null, null, Menu_Options_Click));
            
            //CREDITS:
            item = new Obj("../data/Textures/MENU/MENU_ITEM_CREDITS.dds", 0.6, 0.46, Obj.align.LEFT, true);
            itemH = new Obj("../data/Textures/MENU/MENU_ITEM_CREDITS_A.dds", 0.6, 0.46, Obj.align.LEFT, true);
            itemH.x -= (int)(0.05 * itemH.orginalWidth); itemH.y -= (int)(0.1 * itemH.orginalHeight); itemH.ScaleAbs = 1.2;
            //itemH.addAni(new Obj_Animation(itemH, itemH.x - 18, itemH.y - 6, 18.0, hoverscale,true));
            //itemH.getObjAnimation().setLoopType(Obj_Animation.eLoopType.None);
            main.addItem(new Menu_Item("MAIN_CREDITS", item, itemH, null, null, null, Menu_Credits_Click));

            //QUIT:
            item = new Obj("../data/Textures/MENU/MENU_ITEM_QUIT.dds", 0.6, 0.52, Obj.align.LEFT, true);
            itemH = new Obj("../data/Textures/MENU/MENU_ITEM_QUIT_A.dds", 0.6, 0.52, Obj.align.LEFT, true);
            itemH.x -= (int)(0.05 * itemH.orginalWidth); itemH.y -= (int)(0.1 * itemH.orginalHeight); itemH.ScaleAbs = 1.2;
            //itemH.addAni(new Obj_Animation(itemH, itemH.x - 18, itemH.y - 6, 18.0, hoverscale,true));
            //itemH.getObjAnimation().setLoopType(Obj_Animation.eLoopType.None);
            main.addItem(new Menu_Item("MAIN_EXIT", item, itemH, null, null, null, Menu_Exit_Click));
        }
        public static void Menu_NewGame_Click()
        {
            Menu selectLvl = Game.self.menuManager.getMenuByName("MENU_NEWGAME_1");
            if (selectLvl == null) selectLvl = new Menu("MENU_NEWGAME_1", null);
            selectLvl.clearMenuItems();

            float pX = 700f, pY = 230f;
            Obj BG = new Obj("../data/Textures/MENU/MENU_SUBMENU_SHADOW.dds", 0.52, 0.22, Obj.align.LEFT, true);
            selectLvl.addItem(new Menu_Item("BG", BG, null, null, null, null, null));

            selectLvl.addItem(new Menu_Item(Lang.cur.Latwy, pX, pY, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_NewGame_Easy));
            selectLvl.addItem(new Menu_Item(Lang.cur.Normalny, pX, pY + 50f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_NewGame_Normal));
            selectLvl.addItem(new Menu_Item(Lang.cur.Trudny, pX, pY + 100f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_NewGame_Hard));
            selectLvl.addItem(new Menu_Item(Lang.cur.Hardcore, pX, pY + 150f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_NewGame_Hardcore));
            selectLvl.addItem(new Menu_Item(Lang.cur.Wroc, pX, pY + 200f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_NewGame_Back));

            Game.self.menuManager.openAsSubmenu(selectLvl);
        }
        public static void Menu_NewGame_Easy()
        {
            Profile.currentProfile.config.gameplay.level = gameplay.eDifficultyLevel.EASY;
            Menu_NewGame2();
        }
        public static void Menu_NewGame_Normal()
        {
            Profile.currentProfile.config.gameplay.level = gameplay.eDifficultyLevel.NORMAL;
            Menu_NewGame2();
        }
        public static void Menu_NewGame_Hard()
        {
            Profile.currentProfile.config.gameplay.level = gameplay.eDifficultyLevel.HARD;
            Menu_NewGame2();
        }
        public static void Menu_NewGame_Hardcore()
        {
            Profile.currentProfile.config.gameplay.level = gameplay.eDifficultyLevel.HARDCORE;
            Menu_NewGame2();
        }
        public static void Menu_NewGame2()
        {
            Menu selectMapCount = Game.self.menuManager.getMenuByName("MENU_NEWGAME_2");
            if (selectMapCount == null) selectMapCount = new Menu("MENU_NEWGAME_2", null);
            selectMapCount.clearMenuItems();

            float pX = 700f, pY = 180f;
            //CLose old shadow:
            Menu selectLvl = Game.self.menuManager.getMenuByName("MENU_NEWGAME_1");
            Menu_Item oldBG = selectLvl.getItemByName("BG");
            if (oldBG != null) selectLvl.removeMenuItem(oldBG);
            //then create new one:
            Obj BG = new Obj("../data/Textures/MENU/MENU_SUBMENU_SHADOW.dds", 0.52, 0.22, Obj.align.LEFT, true);
            selectMapCount.addItem(new Menu_Item("BG", BG, null, null, null, null, null));
            selectMapCount.addItem(new Menu_Item(Lang.cur.Ile_Poziomow_w_GrzeDK, pX, pY, Menu.font_Click, Menu.font_Click, Menu.font_Click));
            selectMapCount.addItem(new Menu_Item("10", pX, pY + 50f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_NewGame_Maps10));
            selectMapCount.addItem(new Menu_Item("20", pX, pY + 100f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_NewGame_Maps20));
            selectMapCount.addItem(new Menu_Item("30", pX, pY + 150f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_NewGame_Maps30));
            selectMapCount.addItem(new Menu_Item("40", pX, pY + 200f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_NewGame_Maps35));

            Game.self.menuManager.openAsSubSubmenu(selectMapCount);
        }
        public static void Menu_NewGame_Maps10()
        {
            Profile.currentProfile.config.gameplay.maps = 10;
            Menu_NewGame_Back();
            Menu_NewGame_StartGame();
        }
        public static void Menu_NewGame_Maps20()
        {
            Profile.currentProfile.config.gameplay.maps = 20;
            Menu_NewGame_Back();
            Menu_NewGame_StartGame();
        }
        public static void Menu_NewGame_Maps30()
        {
            Profile.currentProfile.config.gameplay.maps = 30;
            Menu_NewGame_Back();
            Menu_NewGame_StartGame();
        }
        public static void Menu_NewGame_Maps35()
        {
            Profile.currentProfile.config.gameplay.maps = 35;
            Menu_NewGame_Back();
            Menu_NewGame_StartGame();
        }
        public static void Menu_NewGame_Back()
        {
            Game.self.menuViewport.removeObjectByFilePath("../data/Textures/MENU/MENU_SUBMENU_SHADOW.dds");
            Game.self.menuManager.closeSubmenu(Game.self.menuManager.getMenuByName("MENU_NEWGAME_1"));
        }

        public static void Menu_NewGame_StartGame()
        {
            if (!((Game.self.gameState & Game.game_state.Game) == Game.game_state.Game))
            {
                Game.self.startGame();
            }

        }

        //------------------------------------
        //  L O A D   G A M E
        public static void Menu_LoadGame_Click()
        {

            Menu loadGame = Game.self.menuManager.getMenuByName("MENU_LOADGAME");
            if (loadGame == null) loadGame = new Menu("MENU_LOADGAME", null);
            loadGame.clearMenuItems();

            float pX = 700f, pY = 280f;
            Obj BG = new Obj("../data/Textures/MENU/MENU_SUBMENU_SHADOW.dds", 0.52, 0.22, Obj.align.LEFT, true);
            loadGame.addItem(new Menu_Item("BG", BG, null, null, null, null, null));
            String miscInfos = "";
            String miscInfos2 = "";
            QFont miscFont = TextManager.newQFont("CheriPL.ttf", 20, FontStyle.Regular, false, new Color4(80, 150, 230, 255));
            QFont miscFont2 = TextManager.newQFont("Rumpelstiltskin.ttf", 22, FontStyle.Regular, false,new Color4(80, 150, 230, 255));

            Savegame sav = Profile.currentProfile.save;
            miscInfos += Lang.cur.Tunel_NrDOT + (sav.maps.Count + 1) + "\n";
            if (sav.player.difficultLevel == 0)
                miscInfos += Lang.cur.Latwy;
            else if (sav.player.difficultLevel == 1)
                miscInfos += Lang.cur.Normalny;
            else if (sav.player.difficultLevel == 2)
                miscInfos += Lang.cur.Trudny;
            else if (sav.player.difficultLevel == 3)
                miscInfos += Lang.cur.Hardcore;
            else
                miscInfos += "???";
            miscInfos += "\n";
            miscInfos += Lang.cur.CzasDDSpace;
            uint sec = (sav.player.gameDuration % (60 * 1000)) / 1000;
            uint min = (sav.player.gameDuration % (3600 * 1000)) / (60 * 1000);
            uint hr =  (sav.player.gameDuration / (3600 * 1000));
            if (hr > 0) miscInfos += hr + ":";
            if (min > 0) miscInfos += min + ":";
            miscInfos += sec + "\n";
            miscInfos += "...\n";
            miscInfos += Lang.cur.PoziomDDSpace + sav.player.level + "\n";
            miscInfos += Lang.cur.PktDDSpace + sav.player.exp + "\n";
            miscInfos += Lang.cur.ZyciaDDSpace + sav.player.lives + "\n";
            miscInfos += Lang.cur.PktDTalentuDDSpace + sav.player.talentPts + "\n";

            loadGame.addItem(new Menu_Item(miscInfos, pX, pY, miscFont, miscFont, miscFont, null, null, Menu_Nothing));
            
            miscInfos2 = "(" + (sav.maps.Count * 100) / sav.player.mapsCount + "%" + ")";
            loadGame.addItem(new Menu_Item(miscInfos2, pX+ 150f, pY, miscFont2, miscFont2, miscFont2, null, null, Menu_Nothing));
            
            loadGame.addItem(new Menu_Item(Lang.cur.WczytajEXCL, pX + 250f, pY + 250f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_LoadGame_Load));
            loadGame.addItem(new Menu_Item(Lang.cur.Wroc, pX, pY + 250f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_LoadGame_Close));

            Game.self.menuManager.openAsSubmenu(loadGame);
        }
        public static void Menu_LoadGame_Load()
        {
            Game.self.menuViewport.removeObjectByFilePath("../data/Textures/MENU/MENU_SUBMENU_SHADOW.dds");
            Menu_Manager mgr = Game.self.menuManager;
            mgr.closeSubmenu(mgr.getMenuByName("MENU_LOADGAME"));
            Game.self.loadGame(Profile.currentProfile.save);
        }
        public static void Menu_LoadGame_Close()
        {
            Game.self.menuViewport.removeObjectByFilePath("../data/Textures/MENU/MENU_SUBMENU_SHADOW.dds");
            Menu_Manager mgr = Game.self.menuManager;
            mgr.closeSubmenu(mgr.getMenuByName("MENU_LOADGAME"));
        }
        //------------------------------------
        //  O P T I O N S
        public static void Menu_Options_Click()
        {
            
            Menu options = Game.self.menuManager.getMenuByName("MENU_OPTIONS");
            if (options == null) options = new Menu("MENU_OPTIONS", null);
            options.clearMenuItems();

            float pX = 700f, pY = 280f;
            Obj BG = new Obj("../data/Textures/MENU/MENU_SUBMENU_SHADOW.dds", 0.52, 0.22, Obj.align.LEFT, true);
            options.addItem(new Menu_Item("BG", BG, null, null, null, null, null));
            options.addItem(new Menu_Item(Lang.cur.Grafika, pX, pY, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_Options_GFX_Click));
            options.addItem(new Menu_Item(Lang.cur.Dzwiek, pX, pY + 50f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_Options_Sound_Click));
            options.addItem(new Menu_Item(Lang.cur.Wroc, pX, pY + 100f, Menu.font, Menu.font_Hover, Menu.font_Click, Menu_Options_Close));
           
            Game.self.menuManager.openAsSubmenu(options);
        }
        public static void Menu_Options_Sound_Click()
        {
            Menu_Manager mgr = Game.self.menuManager;
            Menu options_snd = mgr.getMenuByName("MENU_OPTIONS_SOUND");
            if (options_snd == null) options_snd = new Menu("MENU_OPTIONS_SOUND", null);
            //if this is already submenu, skip this operation!
            if (options_snd.Equals( Game.self.menuManager.subSubMenu)) return;
            options_snd.clearMenuItems();

            float pX = 700f, pY = 305f;
            //CLose old shadow:
            Menu options = Game.self.menuManager.getMenuByName("MENU_OPTIONS");
            Menu_Item oldBG = options.getItemByName("BG");
            if (oldBG != null) options.removeMenuItem(oldBG);
            //then create new one:
            Obj BG = new Obj("../data/Textures/MENU/MENU_SUBMENU_SHADOW.dds", 0.52, 0.22, Obj.align.LEFT, true);
            options_snd.addItem(new Menu_Item("BG", BG, null, null, null, null, null));

            
            options_snd.addItem(new Menu_Item(Lang.cur.Efekty+": ", pX, pY, Menu.fontSmall, Menu.fontSmall, Menu.fontSmall));
            options_snd.addItem(new Menu_Item(" - ", pX + 110f, pY, Menu.fontSmallAlt, Menu.fontSmallAlt_Hover, Menu.fontSmallAlt_Click, Menu_Options_Sound_SFX_Minus));
            options_snd.addItem(new Menu_Item("  +  ", pX + 165f, pY, Menu.fontSmallAlt, Menu.fontSmallAlt_Hover, Menu.fontSmallAlt_Click, Menu_Options_Sound_SFX_Add));
            options_snd.addItem(new Menu_Item(Math.Round(Profile.currentProfile.config.options.sound.sfxVol, 2).ToString(), pX + 140f, pY, Menu.fontSmall, null, null));

            pY += 30f;
            options_snd.addItem(new Menu_Item(Lang.cur.Muzyka+": ", pX, pY, Menu.fontSmall, Menu.fontSmall, Menu.fontSmall));
            options_snd.addItem(new Menu_Item(" - ", pX + 110f, pY, Menu.fontSmallAlt, Menu.fontSmallAlt_Hover, Menu.fontSmallAlt_Click, Menu_Options_Sound_Music_Minus));
            options_snd.addItem(new Menu_Item("  +  ", pX + 165f, pY, Menu.fontSmallAlt, Menu.fontSmallAlt_Hover, Menu.fontSmallAlt_Click, Menu_Options_Sound_Music_Add));
            options_snd.addItem(new Menu_Item(Math.Round(Profile.currentProfile.config.options.sound.musicVol, 2).ToString(), pX + 140f, pY, Menu.fontSmall, null, null));
 
            mgr.openAsSubSubmenu(options_snd);
            
        }
        public static void Menu_Options_Sound_SFX_Minus()
        {
            Configuration.prevDouble(ref Profile.currentProfile.config.options.sound.sfxVol);
            Menu options_snd = Game.self.menuManager.getMenuByName("MENU_OPTIONS_SOUND");
            options_snd.getItem(4).value = Math.Round(Profile.currentProfile.config.options.sound.sfxVol, 2).ToString();
            Game.self.SoundMan.recalculateSFX();
        }
        public static void Menu_Options_Sound_SFX_Add()
        {
            Configuration.nextDouble(ref Profile.currentProfile.config.options.sound.sfxVol);
            Menu options_snd = Game.self.menuManager.getMenuByName("MENU_OPTIONS_SOUND");
            options_snd.getItem(4).value = Math.Round(Profile.currentProfile.config.options.sound.sfxVol, 2).ToString();
            Game.self.SoundMan.recalculateSFX();
        }
        public static void Menu_Options_Sound_Music_Minus()
        {
            Configuration.prevDouble(ref Profile.currentProfile.config.options.sound.musicVol);
            Menu options_snd = Game.self.menuManager.getMenuByName("MENU_OPTIONS_SOUND");
            options_snd.getItem(8).value = Math.Round(Profile.currentProfile.config.options.sound.musicVol, 2).ToString();
            Game.self.SoundMan.recalculateMusic();
        }
        public static void Menu_Options_Sound_Music_Add()
        {
            Configuration.nextDouble(ref Profile.currentProfile.config.options.sound.musicVol);
            Menu options_snd = Game.self.menuManager.getMenuByName("MENU_OPTIONS_SOUND");
            options_snd.getItem(8).value = Math.Round(Profile.currentProfile.config.options.sound.musicVol, 2).ToString();
            Game.self.SoundMan.recalculateMusic();
        }
        public static void Menu_Options_GFX_Click()
        {
            Menu options_gfx = Game.self.menuManager.getMenuByName("MENU_OPTIONS_GFX");
            if (options_gfx == null) options_gfx = new Menu("MENU_OPTIONS_GFX", null);
            //if this is already submenu, skip this operation!
            //if (options_gfx.Equals(Game.self.menuManager.subSubMenu)) return;
            options_gfx.clearMenuItems();

            float pX = 700f, pY = 305f;

            //CLose old shadow:
            Menu options = Game.self.menuManager.getMenuByName("MENU_OPTIONS");
            Menu_Item oldBG = options.getItemByName("BG");
            if (oldBG != null) options.removeMenuItem(oldBG);
            //then create new one:
            Obj BG = new Obj("../data/Textures/MENU/MENU_SUBMENU_SHADOW.dds", 0.52, 0.22, Obj.align.LEFT, true);
            options_gfx.addItem(new Menu_Item("BG", BG, null, null, null, null, null));

            string resolutionStr = Profile.currentProfile.config.getResolutionString();
            options_gfx.addItem(new Menu_Item(Lang.cur.Rozdzieczlosc + ": " + resolutionStr, pX, pY, Menu.fontSmall, Menu.fontSmall_Hover, Menu.fontSmall_Click, Menu_Options_GFX_Resolution_Click));
            if (Profile.currentProfile.config.resolutionsAreTheSame(Profile.currentProfile.config.options.graphics.resIdx,Profile.currentProfile.config.options.graphics.newResolutionIdx))
            {
                options_gfx.addItem(new Menu_Item(Lang.cur.Ustaw_Rozdzielczosc, pX, pY + 30f, Menu.fontSmall_Disabled));
            }
            else
            {
                options_gfx.addItem(new Menu_Item(Lang.cur.Ustaw_Rozdzielczosc, pX, pY + 30f, Menu.fontSmall, Menu.fontSmall_Hover, Menu.fontSmall_Click, Menu_Options_GFX_ResolutionApply_Click));
            }
            options_gfx.addItem(new Menu_Item(Lang.cur.Renderuj_Sciezki + ": " + Configuration.boolToString(Profile.currentProfile.config.options.graphics.renderPaths), pX, pY + 60f, Menu.fontSmall, Menu.fontSmall_Hover, Menu.fontSmall_Click, Menu_Options_GFX_RPaths_Click));
          
            Game.self.menuManager.openAsSubSubmenu(options_gfx);
        }
        public static void Menu_Options_GFX_Resolution_Click()
        {
            Profile.currentProfile.config.getNextResolution();
            Menu_Options_GFX_Click();//rebuild whole menu
        }
        public static void Menu_Options_GFX_ResolutionApply_Click()
        {
            Profile.currentProfile.config.applyResolution();
        }
        public static void Menu_Options_GFX_RPaths_Click()
        {
            Profile.currentProfile.config.options.graphics.renderPaths = !Profile.currentProfile.config.options.graphics.renderPaths;
            Game.self.menuManager.getMenuByName("MENU_OPTIONS_GFX").getItem(2).value = Lang.cur.Renderuj_Sciezki+": " + Configuration.boolToString(Profile.currentProfile.config.options.graphics.renderPaths);
        }
        
        public static void Menu_Options_Close()
        {
            Profile.currentProfile.config.restoreResolutionValue();

            Game.self.menuViewport.removeObjectByFilePath("../data/Textures/MENU/MENU_SUBMENU_SHADOW.dds");
            Menu_Manager mgr = Game.self.menuManager;
            mgr.closeSubmenu(mgr.getMenuByName("MENU_OPTIONS"));
        }
        public static void Menu_Credits_Click()
        {
            Game.self.videoPlayer.playVideo("../data/videos/outro.bik");
        }
        public static void Menu_Exit_Click()
        {
            Profile.currentProfile.encryptToFile();
            Game.self.Exit();
        }

        //---------------------------------
        // END OF MENU MAIN STUFF
        // --------------------------------

        // --------------------------------
        // S T A T U S   S C R E E N
        // --------------------------------
        public static void Status_OnLoad()
        {
            //generate all things there:
            //(render them at onRender func)
            //(store them in statusScreen class)
            Game.self.gameManager.statusScr.generateContents();
        }
        public static void Status_OnRender()
        {
            Game.self.gameManager.statusScr.renderContents();
        }
        public static void Status_ButtonOnHover()
        {
            Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP_SHORT.ogg", false, false);
            beep.volume = 0.82;
            beep.Play();
        }
        public static void Status_AtrBoostClick()
        {
            if (Game.self.gameManager.PC.riseSpeed())
            {
                Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP_LONG.ogg", false, false);
                beep.volume = 0.82;
                beep.Play();
                Game.self.gameManager.statusScr.generateContents();//refresh contents
            }
            else
            {
                Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP_FAIL.ogg", false, false);
                beep.volume = 0.82;
                beep.Play();
            }
        }
        public static void Status_AtrMaxLivesClick()
        {
            if (Game.self.gameManager.PC.riseMaxLives())
            {
                Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP_LONG.ogg", false, false);
                beep.volume = 0.82;
                beep.Play();
                Game.self.gameManager.statusScr.generateContents();//refresh contents
            }
            else
            {
                Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP_FAIL.ogg", false, false);
                beep.volume = 0.82;
                beep.Play();
            }
        }
        public static void Status_SkillBoost()
        {
            if (Game.self.gameManager.PC.riseSkill(Skill.skillNames.Boost))
            {
                Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP_LONG.ogg", false, false);
                beep.volume = 0.82;
                beep.Play();
                Game.self.gameManager.statusScr.generateContents();//refresh contents
            }
            else
            {
                Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP_FAIL.ogg", false, false);
                beep.volume = 0.82;
                beep.Play();
            }
        }
        public static void Status_SkillIceBolt()
        {
            if (Game.self.gameManager.PC.riseSkill(Skill.skillNames.IceBolt))
            {
                Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP_LONG.ogg", false, false);
                beep.volume = 0.82;
                beep.Play();
                Game.self.gameManager.statusScr.generateContents();//refresh contents
            }
            else
            {
                Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP_FAIL.ogg", false, false);
                beep.volume = 0.82;
                beep.Play();
            }
        }
        
        public static void Status_exitToMenuClick()
        {
            Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP_LONG.ogg", false, false);
            beep.volume = 0.82;
            beep.Play();
            Menu_Manager mgr = Game.self.menuManager;
            mgr.setCurrentMenu(mgr.getMenuByName("MENU_MAIN"));
            Game.self.closeGameManagerSession();
        }

    }
}using System;
using System.Collections.Generic;
using System.Text;
using QuickFont;
using System.Drawing;
using EngineApp;

namespace CookieMonster.CookieMonster_Objects
{
    /// <summary>
    /// Menu items aren't added to viewport, do sth with that!
    /// </summary>
    class Menu_Item
    {
        private Menu owner; //owner of this menu item
        public string name { get; private set; }
        //Obj based menu item:
        private Obj visual;
        private Obj visualOnHover;
        private Obj visualOnClick;
        private Obj renderedVisual;

        //Text based menu item:
        private string _value;
        public string value { get { return _value; } set { _value = value; itemText.changeText(value); } }
        Text itemText; //rendered Text class item
        public QFont font;
        QFont fontOnHover;
        QFont fontOnClick; 
        private bool _inHover;
        public bool inHover { get { return _inHover; } }
        private Rectangle _bbox;
        public Rectangle bbox
        {
            get { return _bbox; }
        }
        public delegate void mouseEvt();
        private mouseEvt onMouseIn;
        private mouseEvt onMouseOut;
        private mouseEvt onClick;

        //--------------
        // Item based on TEXTs
        public Menu_Item(string text, float x, float y, QFont _font)
        {
            _value = text;
            name = text;
            TextManager txtMan = Game.self.textMenager;
            font = _font;
            itemText = txtMan.produceText(font, text, x, y, QFontAlignment.Left);
        }
        public Menu_Item(string text, float x, float y, QFont _font, QFont _fontOnHover)
            : this(text, x, y, _font)
        {
            fontOnHover = _fontOnHover;
        }
        public Menu_Item(string text, float x, float y, QFont _font, QFont _fontOnHover, QFont _fontOnClick)
            : this(text, x, y, _font, _fontOnHover)
        {
            fontOnClick = _fontOnClick;
        }
        public Menu_Item(string text, float x, float y, QFont _font, QFont _fontOnHover, QFont _fontOnClick, mouseEvt click)
            : this(text, x, y, _font, _fontOnHover, _fontOnClick)
        {
            onClick = click;
        }
        public Menu_Item(string text, float x, float y, QFont _font, QFont _fontOnHover, QFont _fontOnClick, mouseEvt _in, mouseEvt _out, mouseEvt click)
            : this(text, x, y, _font, _fontOnHover, _fontOnClick, click)
        {
            onMouseIn = _in;
            onMouseOut = _out;
        }
        //--------------
        // Item based on OBJects
        public Menu_Item(string n, Obj v, Obj vH, Obj vC, mouseEvt _in, mouseEvt _out, mouseEvt c)
        {
            name = n;
            renderedVisual = visual = v;
            visualOnHover = vH;
            visualOnClick = vC;
            onMouseIn = _in;
            onMouseOut = _out;
            onClick = c;
            _bbox = new Rectangle(v.x, v.y, v.width, v.height);
        }
        public void _onMouseClick()
        {
            if (onClick != null)
                onClick();
            _inHover = false;//not true, it's onClick rite now!
            if (visualOnClick != null)
                renderedVisual = visualOnClick;
            if (fontOnClick != null && owner.submenuTimer.enabled == false)//BUGFIX: Don't change visuals during submenu ani!
                itemText.changeFont(fontOnClick);
        }
        public void _onMouseIn()
        {
            // NOTHING TO DO IN HERE!
            if (onMouseIn == null && visualOnHover == null && fontOnHover == null) return;

            if (!inHover)
            {
                _inHover = true;
                if (visualOnHover != null)
                {
                    renderedVisual = visualOnHover;

                    if (onMouseIn == null)//then play default beep:
                    {
                        Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP.ogg", false, false);
                        beep.volume = 0.52;
                        beep.Play();
                    }
                    else
                        onMouseIn();//call customized onHover function
                }
                else if (fontOnHover != null)
                {
                    if (owner.submenuTimer.enabled == false)//BUGFIX: Don't change visuals during submenu ani!
                        itemText.changeFont(fontOnHover);
                    if (onMouseIn == null)//then play default beep:
                    {
                        Sound beep = new Sound(Sound.eSndType.SFX, "../data/Sounds/MENU_BEEP_SHORT.ogg", false, false);
                        beep.volume = 0.62;
                        beep.Play();
                    }
                    else
                        onMouseIn();//call customized onHover function
                }
            }
        }
        public void _onMouseOut()
        {
            if (inHover)
            {
                _inHover = false;
                if (visualOnHover != null && visualOnHover.getObjAnimation() != null)
                {
                    visualOnHover.getObjAnimation().gotoKeyframe(0);
                }
                renderedVisual = visual;
                if (font != null && owner.submenuTimer.enabled == false)//BUGFIX: Don't change visuals during submenu ani!
                    itemText.changeFont(font);
            }
        }
        public bool CursorIn(int x, int y)
        {
            int itemX, itemY;
            int itemWidth, itemHeight; 
            // bugfix: cursor obj itself is in lil different
            // position than win.cursor, so we moving it back there:
            x += 10; y += 10;
            if (visual != null)
            {//Cursor intersection check for Obj based menu:
                itemX = visual.x; itemY = visual.y;
                int maxX = itemX + visual.width, maxY = itemY + visual.height;
                //If there is some child, count them too!
                if (visual.childObj != null)
                {
                    for (int i = 0; i < visual.childObj.Count; i++)
                    {
                        Obj tmp = visual.childObj[i];
                        if (visual.x + tmp.x + tmp.width > maxX)
                            maxX = visual.x + tmp.x + tmp.width;
                        if (visual.y + tmp.y + tmp.height > maxX)
                            maxY = visual.y + tmp.y + tmp.height;
                    }
                }
                itemWidth = maxX - itemX; itemHeight = maxY - itemY;
            }
            else if (itemText != null)
            {//Cursor intersection check for Text type Menu item:

                itemX = (int)itemText.x; itemY = (int)itemText.y;
                SizeF size = font.Measure(value);
                itemWidth = (int)size.Width; itemHeight = (int)size.Height;

            }
            else
                return false; //No obj, no Text ->Item is blank so how u could hover that?
            int tolerance_x = itemWidth / 15, tolerance_y = itemHeight / 15;


            if (((x > itemX - tolerance_x) && (x + tolerance_x < itemX + itemWidth))
            && ((y > itemY + tolerance_y) && (y - tolerance_y < itemY + itemHeight)))
            {
                return true;
            }
            else
                return false;
        }
        public void Render()
        {// menu items aren't added to viewport they rendered byself
            if (renderedVisual != null)
            {
                renderedVisual.Render();
                if (renderedVisual == visualOnClick)
                    renderedVisual = visualOnHover;
            }
            else if (itemText != null)
                itemText.Print();
        }

        internal void fadeOut(Timer fadeOutTimer)
        {
            double multi = ((double)fadeOutTimer.currentTime / (double)fadeOutTimer.totalTime);
            //if (multi < 0.0) multi = 0.0;
            if (visual != null)
                visual.setAllTexsAlpha((byte)(255 * multi));
            if (visualOnHover != null)
                visualOnHover.setAllTexsAlpha((byte)(255 * multi));
            if (itemText != null)
            {
                QFont ftmp = itemText.fontFace;
                ftmp.Options.Colour.A = (float)multi;
                itemText.changeFont(ftmp);
            }
        }

        internal void fadeIn(Timer fadeInTimer)
        {
            double multi = 1.0 - ((double)fadeInTimer.currentTime / (double)fadeInTimer.totalTime);
            //if (multi < 0.0) multi = 0.0;
            if (visual != null)
                visual.setAllTexsAlpha((byte)(255 * multi));
            if (visualOnHover != null)
                visualOnHover.setAllTexsAlpha((byte)(255 * multi));
            if (itemText != null)
            {
                QFont ftmp = itemText.fontFace;
                if (fontOnHover != null) fontOnHover.Options.Colour.A = 1f;
                if (fontOnClick != null) fontOnClick.Options.Colour.A = 1f;
                font.Options.Colour.A = 1f;
                ftmp.Options.Colour.A = (float)multi;
                itemText.changeFont(ftmp);
            }
        }

        internal void setOwner(Menu menu)
        {
            owner = menu;
        }

        internal void submenu(Timer submenuTimer)
        {
            double moveLenght = 450.0;
            double startAddLenght = 0.0;
            Menu_Manager mgr = Game.self.menuManager;
            if (this.owner.Equals(mgr.current_menu) && mgr.subSubMenu != null)
            {
                startAddLenght = moveLenght;
                moveLenght = 225.0;
            }
            else if (this.owner.Equals(mgr.subMenu))
            {
                moveLenght = 250.0;
            }
            double multi = 1.0 - ((double)submenuTimer.currentTime / (double)submenuTimer.totalTime);
            //if (multi < 0.0) multi = 0.0;
            if (visual != null)
                visual.x = (int)(visual.orgX - startAddLenght - multi * moveLenght);
            if (visualOnHover != null)
                visualOnHover.x = (int)(visualOnHover.orgX - startAddLenght - multi * moveLenght);
            if (itemText != null)
                itemText.MoveAbs((int)(itemText.orgX - startAddLenght - multi * moveLenght), (int)itemText.orgY);
        }

        internal void submenuClose(Timer submenuCloseTimer)
        {
            double moveLenght = 450.0;
            double startAddLenght = 0.0;
            Menu_Manager mgr = Game.self.menuManager;
            if (this.owner.Equals(mgr.current_menu) && mgr.closingSubmenusLevel == 2)
            {//this is moving current menu when closing subSubMenu
                startAddLenght = moveLenght;
                moveLenght = 225.0;
            }
            else if (this.owner.Equals(mgr.subMenu))
            {//this is moving subMenu when closing subSubmenu
                //startAddLenght = moveLenght;
                moveLenght = 250.0;
            }
            double multi = ((double)submenuCloseTimer.currentTime / (double)submenuCloseTimer.totalTime);
            //if (multi < 0.0) multi = 0.0;
            if (visual != null)
                visual.x = (int)(visual.orgX - startAddLenght - multi * moveLenght);
            if (visualOnHover != null)
                visualOnHover.x = (int)(visualOnHover.orgX - startAddLenght - multi * moveLenght);
            if (itemText != null)
                itemText.MoveAbs((int)(itemText.orgX - startAddLenght - startAddLenght - multi * moveLenght), (int)itemText.orgY);
        }

    }
}
using System;
using System.Collections.Generic;
using System.Text;
using EngineApp;
using OpenTK.Input;
using System.Drawing;

namespace CookieMonster.CookieMonster_Objects
{
    class Menu_Manager
    {
        public static Obj cursor{get; set;}
        private List<Menu> Menus_List = new List<Menu>();
        private bool menus_crossfading;
        private Menu fadingInMenu;
        private bool[] buttons_state = new bool[(int)MouseButton.LastButton + 1];
        private Menu _current_menu;
        public Menu current_menu { get { return _current_menu; }
            set
            {   //disable input loging (so if it's used in next menu it will start with blank buffer)
                InputManager.inputLogging = false;
                //if some menu was sat, clear opened flag from it.
                if (current_menu != null)
                    current_menu.clearOpenedFlag();
                _current_menu = value;
                _current_menu.Enable();
                addMenu(_current_menu);
            }
        }
        public Menu subMenu { get; private set; }
        public Menu subSubMenu { get; private set; }

        private Timer inputIdleCheck = new Timer(Timer.eUnits.MSEC, 1 * 500, 0, true, false);
        private int inputIdleChecksCount; private const int mouseIdleRange = 10;
        private Point mouseIdleLastPos = new Point(0,0);

        private bool _canEnterIdleMode = false;
        /// <summary>
        /// If value is true, menu gui can dispear and enter "theather mode"
        /// if it's set to false, it simply can't + setting (even to the same value
        /// as the last one will reset timer and count of "idle time".
        /// </summary>
        public bool canEnterIdleMode { get { return _canEnterIdleMode;}
            set
            { 
                inputIdleChecksCount = 0;
                inputIdleCheck.restart();
                _canEnterIdleMode = value;
            }
        }
        public bool cursorRendered;
        public Menu_Manager()
        {
            cursor = new Obj("../data/Textures/MENU/MENU_CURSOR.dds", 0.5, 0.5, Obj.align.LEFT);
            cursor.isGUIObjectButUnscaled = true;
        }
        public void setCurrentMenu(Menu m)
        {            
            current_menu = m;
        }
        public void addMenu(Menu m)
        {
            if(getMenuByName(m.name)==null)//if there is no menu with this name on list, add it
            Menus_List.Add(m);
        }

        public void onUpdate()
        {
            if (current_menu == null) return;
            if ((Game.self.gameState & Game.game_state.Menu) == Game.game_state.Menu)
            {

                Menu_Manager.cursor.x = Game.self.Mouse.X - 0;//12
                Menu_Manager.cursor.y = Game.self.Mouse.Y - 12;
                //handle alert window:
                if (alert != null)
                {//if there is alert wnd, update alert window only
                    alert.Update();
                    return;
                }


                if (subMenu != null)
                    subMenu.Update();
                //Now it's handled by menuDisabled
                //if(subMenu == null || current_menu.submenuTimer.enabled || current_menu.submenuCloseTimer.enabled)
                    current_menu.Update();//update main only if there is no sub's (or there is sub-ani todo)
                if (subSubMenu != null)
                    subSubMenu.Update();
            }
            if(menus_crossfading && !current_menu.fadingOut)
            {
                menus_crossfading = false;
                setCurrentMenu(fadingInMenu);
                current_menu.fadeIn();
            }
            if (closingSubmenusLevel > 0)
            {
                if (closingSubmenusLevel == 2 && current_menu.submenuCloseTimer.enabled == false)
                { //Start II Phase:
                    subMenu = null;
                    closingSubmenusLevel--;
                    current_menu.closeSubmenu();
                    current_menu.Disable();
                }
                else if (closingSubmenusLevel == 1 && current_menu.submenuCloseTimer.enabled == false)
                {//All is done:
                    closingSubmenusLevel--;
                    current_menu.Enable();//re-enable menu items hovering
                }
            }

            checkInputIdle();
        }
        // NOTE: 19.09 - added keyboard idle checking
        // keypressing will disturb going into theather mode simply by handling event of keystroke
        // and reseting inputIndleChecksCount to 0
        internal void KeyPress(object sender, OpenTK.KeyPressEventArgs p)
        {
            inputIdleChecksCount = 0;
            toggleTheatherMode(0);
        }
        private void checkInputIdle()
        { 
            if (!inputIdleCheck.enabled)
            {
                inputIdleCheck.start();
                Point curCursor = new Point(Game.self.Mouse.X, Game.self.Mouse.Y);
                if ((Math.Abs(mouseIdleLastPos.X - curCursor.X) < mouseIdleRange)
                && (Math.Abs(mouseIdleLastPos.Y - curCursor.Y) < mouseIdleRange))
                {
                    inputIdleChecksCount++;
                    if (inputIdleChecksCount > 6 * 2)
                        toggleTheatherMode(1);
                }
                else
                {
                    inputIdleChecksCount = 0;
                    toggleTheatherMode(0);
                }
                mouseIdleLastPos = curCursor;
            }
        }
        private int theatherModeState = 2;//0-turning off theather mode; 1-setting To theather mode
                                          //2-Nothing happening;
        private void toggleTheatherMode(int state)
        {
            // Don't enter theather mode if flag is not set
            if((canEnterIdleMode==false)&&(state==1)) return;

            if ((Game.self.gameState & Game.game_state.Game) == Game.game_state.Game
            ||  (Game.self.gameState & Game.game_state.Menu) != Game.game_state.Menu)
                return; //INGAME MENU or not even in menu? well fuck it then.
            if (state == theatherModeState) return; //this state is already on
            if (state == 0 && theatherModeState == 2) return; //toggle off couldn't occur when theather was in just inited state;
            theatherModeState = state;
            if (state == 1)
            {
                if (current_menu != null) current_menu.fadeOut();
                if (subMenu != null) subMenu.fadeOut();
                if (subSubMenu != null) subSubMenu.fadeOut();
                cursor.setAllTexsAlpha(0);
            }
            else if (state == 0)
            {
                if (current_menu != null) current_menu.fadeIn();
                if (subMenu != null) subMenu.fadeIn();
                if (subSubMenu != null) subSubMenu.fadeIn();
                cursor.setAllTexsAlpha(255);
            }
        }

        public void onRender()
        {
            if (current_menu == null) return;
            if ((Game.self.gameState & Game.game_state.Menu) == Game.game_state.Menu)
            {
                current_menu.Render();
                if (subMenu != null && (current_menu.submenuTimer.enabled == false || subMenu.submenuTimer.enabled == true))
                    subMenu.Render();
                if (subSubMenu != null && subMenu.submenuTimer.enabled == false)
                    subSubMenu.Render();

                if (alert != null) alert.Render();
                cursor.Render();
            }

        }
        public Menu getMenuByName(string n)
        {
            if (Menus_List.Count == 0) return null;

            int i = 0;
            while ((!Menus_List[i].menuName.Equals(n)) && (i < Menus_List.Count))
            {
                i++;
                if (i == Menus_List.Count) return null;
            }
            return Menus_List[i];
        }

        public bool getButtonState(MouseButton mb)
        {
            if (mb <= MouseButton.LastButton) return buttons_state[(int)mb];
            return false;
        }
        public void setButtonState( MouseButton mb, bool value)
        {
            if (mb <= MouseButton.LastButton) buttons_state[(int)mb] = value;

            //Avoid of getting into theather-mode:
            inputIdleChecksCount = 0;
            toggleTheatherMode(0);
        }
        /// <summary>
        /// Fade out - current menu
        /// (set current menu to new one)
        /// Fade in - new menu
        /// </summary>
        /// <param name="newMenu"></param>
        public void changeMenuWithCrossfade(Menu newMenu)
        {
            current_menu.fadeOut();
            menus_crossfading = true;
            fadingInMenu = newMenu;
        }

        public void openAsSubmenu(Menu sub)
        {
            addMenu(sub);
            if (subMenu == null)
            {
                current_menu.Disable();//disable hovering items
                current_menu.addedSubmenu();//whis function will handle "moving away" animation of menu
            }
            subMenu = sub;
            subMenu.Enable();//make sure opened menu will be enabled
        }

        internal void openAsSubSubmenu(Menu subSub)
        {
            addMenu(subSub);
            if (subSubMenu == null)
            {
                subMenu.addedSubmenu();//whis function will handle "moving away" animation of menu
                current_menu.addedSubmenu();
            }
            subSubMenu = subSub;
            subSubMenu.Enable();//make sure opened menu will be enabled
        }
        public int closingSubmenusLevel { get; private set; }
        internal void closeSubmenu(Menu sub)
        {
            if (subSubMenu != null)//subsub to close
            {
                if (sub == subMenu) { closingSubmenusLevel = 2; }
                else closingSubmenusLevel = 1;//it shouldn't happen, anyhow whatever...
                subSubMenu = null;
                subMenu.closeSubmenu();
                current_menu.closeSubmenu();
                subMenu.Disable();
            }
            else if (subMenu != null)
            {
                closingSubmenusLevel = 1;
                subMenu = null;
                current_menu.closeSubmenu();
                current_menu.Disable();
            }
        }
        /// <summary>
        /// Close all menus in one step
        /// (closing animations etc. not included)
        /// </summary>
        public void close()
        {
            if (subSubMenu != null) subSubMenu = null;
            if (subMenu != null) subMenu = null;
            current_menu = null;
        }
        /// <summary>
        /// this function shows small alert window on top of menu that will 
        /// need to get back control on anything under it
        /// </summary>
        /// <param name="msg"></param>
        private Menu alert;
        private QuickFont.QFont alertOK,alertOKHover; 
        public void showAlert(string msg)
        {
            alert = getMenuByName("ALERT");
            if (alert == null)
            {
                if (alertOK == null)
                {//init alert fonts:
                    alertOK = TextManager.newQFont("CheriPL.ttf", 35, false, new OpenTK.Graphics.Color4(210, 225, 250, 245));
                    alertOKHover = TextManager.newQFont("CheriPL.ttf", 35, false, new OpenTK.Graphics.Color4(70, 120, 255, 255));
                }
        
                Obj BG = new Obj("../data/Textures/MENU/MENU_ALERT_BG.dds", 0.5, 0.5, Obj.align.CENTER_BOTH, false);
                BG.isGUIObjectButUnscaled = true;

                float x = Game.self.activeViewport.width / 2 - Menu.fontSmallAlt.Measure(msg).Width / 2;
                float y = Game.self.activeViewport.height * 3 / 10;
                alert = new Menu("ALERT", null);
                alert.addItem(new Menu_Item("BG", BG, null, null, null, null, null));
                alert.addItem(new Menu_Item(msg, x, y, Menu.fontSmallAlt,Menu.fontSmallAlt,Menu.fontSmallAlt,Menu_Instances.Menu_Nothing,null,null));
                alert.addItem(new Menu_Item(Lang.cur.OK, x, y + 300f, alertOK, alertOKHover, Menu.font_Click, closeAlert));
            }
        }
        public void closeAlert()
        {
            alert = null;
        }
    }
}using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using EngineApp;

namespace CookieMonster.CookieMonster_Objects
{


    class Obj
    {
        #region Obj_fields
        static Random variatonizer = new Random((int)DateTime.Now.Ticks & 0x0000FFFF);
        static Game parentGame;
        static private UInt32 id_ctr = 1;
        private UInt32 id = 0;
        private double vposx, vposy;//0-0px 1.0-x/y size of screen
        private int posx, posy; //actual position on screen
        private double _orginalWidth, _orginalHeight;
        public double orginalWidth { get { return _orginalWidth; } }
        public double orginalHeight { get { return _orginalHeight; } }

        private double scaleX = 1.0, scaleY = 1.0;
        public enum align { LEFT, CENTER_X, CENTER_Y, CENTER_BOTH, RIGHT };
        private align _align; public align objAlign { get { return _align; } }
        
        Engine.Image tex;

        public Obj parentObj { get; private set; }//parent obj that this obj will be relatively positioned to
        public List<Obj> childObj { get; private set; }//u can add child objects there that will be rendered next to this main
                                   //object, note that they pos will be threaten relatively, not absolute
        private Obj_texAni texAni = null;
        private Obj_Animation ani = null;

        public string texturePath { get { return tex.bitmapPath; } }

        #region IdleAni struct
        idleAni idleAnimation;
        public delegate void funcOnIdle();
        private class idleAni
        {
            public bool objInIdleAni;
            public Obj idleObj;
            public Timer delayTimer;   // time that will need to be passed before idle obj will be rendered
            public Timer idleAniTimer; // duration of idleAni
            public funcOnIdle  runOnIdle;
        }
        #endregion
        private bool visible = true;
        #endregion

        #region Obj_Get/Set
        public double vx
        {
            get {return vposx;}
            set { vposx = value; posx = (int)((double)parentGame.activeViewportOrAny.width * value); }
        }
        public double vy
        {
            get { return vposy; }
            set { vposy = value; posy = (int)((double)parentGame.activeViewportOrAny.height * value); }
        }
        public int x
        {
            get {return posx;}
            set { posx = value; if (value == 0)vposx = 0.0; else vposx = (double)(parentGame.activeViewportOrAny.width / value); }
        }
        public int y
        {
            get {return posy;}
            set { posy = value; if (value == 0)vposy = 0.0; else vposy = (double)(parentGame.activeViewportOrAny.height / value); }
        }
        //positions used when creating object:
        public int orgX { get; private set; }
        public int orgY { get; private set; }
        public int width
        {
            get
            {
                if (!texAni.enabled) return tex.w;
                else return texAni[texAni.currentFrame].w;
            }
            set
            {
                int oldW = width;
                //re-centerize Obj by moving positon by proper value:
                if ((_align == align.CENTER_BOTH) || (_align == align.CENTER_X))
                {
                    x -= (value - oldW) / 2;
                }
                else if (_align == align.RIGHT)
                {
                    x -= (value - oldW);
                }
                if (!texAni.enabled)
                {

                    tex.SetSize(value, tex.h);
                }
                else
                {
                    for (int i = 0; i < texAni.Count; i++)
                    {
                        
                        texAni[i].SetSize(value, texAni[i].h);
                    }
                }
            }
        }
        public int height
        {
            get
            {
                if (!texAni.enabled) return tex.h;
                else return texAni[texAni.currentFrame].h;
            } 
            set
            {
                int oldH = height;
                //re-centerize Obj by moving positon by proper value:
                if ((_align == align.CENTER_BOTH) || (_align == align.CENTER_Y))
                {
                    y -= (value - oldH) / 2;
                }

                if (!texAni.enabled)
                {
                    tex.SetSize(tex.w, value);
                }
                else
                {
                    for (int i = 0; i < texAni.Count; i++)
                    {
                        texAni[i].SetSize(texAni[i].w, value);
                    }
                }
            }
        }
        private double[] _scale; 
        public double[] scale
        {   
            get 
            {
                /*
                Double[] ret = new Double[2];
                if (!texAni.enabled)
                {
                    ret[0] = scaleX;
                    ret[1] = scaleY;
                }
                else
                {
                    ret[0] = width / orginalWidth; 
                    ret[1] = height/ orginalHeight;
                }
                */
                if (_scale == null)
                {
                    _scale = new double[2];
                    _scale[0] = _scale[1] = 1.0;
                }
                return _scale;
            }
            set
            {
                if (_scale == null) _scale = new double[2];
                _scale = value;
                width = (int)(orginalWidth * value[0]);
                height = (int)(orginalHeight*value[1]);
                scaleX = value[0]; scaleY = value[1];     
            }
        }
        /// <summary>
        /// This scale is based on scale[2]
        /// so f.e.: Scale = 2.0 is the same as
        /// scale = {2.0,2.0} (pseudo)
        /// ---
        /// Scale will be set Relatively (multipiled by current scale value)
        /// </summary>
        public double ScaleRel
        {
            get { return Math.Max(scale[0], scale[1]); }
            set { double[] s = new double[2]; s[0] = scale[0] * value; s[1] = scale[1] * value; scale = s; }
        }
        /// <summary>
        /// This scale is based on scale[2]
        /// so f.e.: Scale = 2.0 is the same as
        /// scale = {2.0,2.0} (pseudo)
        /// ---
        /// Scale will be set Absolute (multipiled by orginal width/height values)
        /// </summary>
        public double ScaleAbs
        {
            get { return Math.Max(scale[0], scale[1]); }
            set { double[] s = new double[2]; s[0] = value; s[1] = value; scale = s; }
        }
        /// <summary>
        /// Returns id of currently used openGL texture (for binding and other usesful stuff)
        /// </summary>
        public int glTexID
        {
            get { return (int)tex.texture; }
        }
        #endregion

        #region Obj_Constructors
        /// <summary>
        /// blank constructor
        /// </summary>
        public Obj()
        {
            texAni = new Obj_texAni(this, "");
        }
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="ipath">Path to image</param>
        /// <param name="vx">virtual x (0.0-1.0) of screen</param>
        /// <param name="vy">virtual y</param>
        /// <param name="algn">align of object</param>
        public Obj(string ipath, double _vx, double _vy,align algn)
        {
            parentGame = Game.self;
            id = id_ctr;
            id_ctr++;
            tex = new Engine.Image();
            tex.Load(ipath);
            tex.SetBlending();
            
            vx = _vx; vy = _vy;
            orgX = x; orgY = y;
            texAni = new Obj_texAni(this, ipath);

            _align = algn;
            applyAlignCorrection();
            _orginalWidth = width;
            _orginalHeight = height;
        }
        public Obj(string ipath, double _vx, double _vy, align algn, bool isGUIObj) : this(ipath,_vx,_vy,algn)
        {
            _isGUIObject = isGUIObj;
            guiObjRescale();
        }
        public Obj(string ipath, int _x, int _y, align algn)
        {
            ipath = variableTexture(ipath);//if texture has "V0" in name it will random name from V0-Vn
            tex = new Engine.Image();
            tex.Load(ipath);
            tex.SetBlending();

            x = _x; y = _y;
            orgX = x; orgY = y;
            texAni = new Obj_texAni(this, ipath);

            _align = algn;
            applyAlignCorrection();
            _orginalWidth = tex.w;
            _orginalHeight = tex.h;
        }
        public Obj(string ipath, int _x, int _y, align algn, bool isGUIObj) : this(ipath,_x,_y,algn)
        {
            _isGUIObject = isGUIObj;
            guiObjRescale();
        }
        #endregion
        public void addChildObj(Obj child)
        {
            if (childObj == null)
                childObj = new List<Obj>();
            childObj.Add(child);
            child.setParent(this);
        }
        public void setParent(Obj parent)
        {
            parentObj = parent;
        }
        public void Render()
        {
            int oldX = x, oldY = y;
            if (parentObj != null) //Obj has a parent, so we need to recalculate position of this Obj
            {
                x += parentObj.x; y += parentObj.y;
            }
            Camera activeCam = Game.self.gameCamera;
            if (isGUIObject) activeCam = new Camera(Camera.eType.STATIC);
            //if(!objInViewport(activeCam)) return;
            //compute animation frame:
            if (ani != null && (Game.self.gameManager ==null || !Game.self.gameManager.gamePaused || !ani.isIngameAnimation))
                ani.computeFrame();

            if (!texAni.Render(x, y)) // method will take care of all by self
            {
                if (idleAnimation != null)
                {
                    if (((idleAnimation.delayTimer <= 0)||(!idleAnimation.delayTimer.enabled)) && (!idleAnimation.objInIdleAni))
                    {// object has to be turned into idle ani:
                        idleAnimation.idleAniTimer.start();
                        idleAnimation.objInIdleAni = true;
                        idleAnimation.idleObj.Render();

                        if(idleAnimation.runOnIdle!=null)
                        idleAnimation.runOnIdle();
                    }
                    else if (idleAnimation.objInIdleAni)
                    {
                        if ((idleAnimation.idleAniTimer > 0)&&(idleAnimation.idleAniTimer.enabled))
                        {
                            idleAnimation.idleObj.Render();
                        }
                        else // goes back to default ani + reset timer:
                        {
                            idleAnimation.delayTimer.start();
                            idleAnimation.objInIdleAni = false;
                            tex.Draw(x + activeCam.camOffsetX, y + activeCam.camOffsetY);
                        };
                    };
                }
                else
                    tex.Draw(x + activeCam.camOffsetX, y + activeCam.camOffsetY); // draw static tex if there is no any tex animation
            }
            //renders childs if there is some of them
            if(childObj!=null)
                for (int i = 0; i < childObj.Count; i++)
                    childObj[i].Render();
            x = oldX; y = oldY;
        }

        private bool objInViewport(Camera activeCam)
        {
            if( (x + activeCam.camOffsetX > parentGame.activeViewport.width)
            &&  (x+width  + activeCam.camOffsetX > parentGame.activeViewport.width))
                return false;
            if ((y + activeCam.camOffsetY > parentGame.activeViewport.height)
            && (y + height + activeCam.camOffsetY > parentGame.activeViewport.height))
                return false;
            return true;
        }
        public void Free()
        {
            if (tex != null)
                tex.Free();
            if (texAni != null)
                for (int i = 0; i < texAni.Count; i++)
                    texAni[i].Free();
        }

        // Animation of manipulations of pos and scale TODO: opacity manipulations
        #region Ani methods
        public void addAni(Obj_Animation a)
        {
            ani = a;
        }
        public void addAniKeyframe(int tX, int tY, double tS)
        {
            ani.addKeyframe(tX, tY, tS);
        }
        public Obj_Animation getObjAnimation()
        {
            return ani;
        }
        #endregion

        // Classic animation of changing textures (gif-alike) generated automatically 
        // if there is _A0 as name prefix
        #region texAni methods
        public void setTexAniLoopType(Obj_texAni.eLoopType typ)
        {
        if(texAni!=null)
            texAni.loopType = typ;
        }
        public void setTexAniFPS(int fps)
        {
            if (texAni != null)
                texAni.FPS = fps;
        }

        public bool texAniFinished() 
        { 
            if ((texAni.loopType == Obj_texAni.eLoopType.NONE) && (texAni.currentFrame == texAni.Count-1))
                return true; 
            else
                return false; 
        }
        /// <summary>
        /// setting current frame of animation to first(0)
        /// </summary>
        public void restartTexAni()
        {
            texAni.currentFrame = 0;
        }
        public void setTexAniFrame(int frame)
        {
            if(frame<texAni.Count)
            texAni.currentFrame = frame;
        }
        public int getTexAniFrame()
        {
            return texAni.currentFrame;
        }
        public void setTexAniControlledExternal()
        {
            texAni.isControlledExternal = true; // so it willn't calculate frames by self, but render current frame
                                                // till it's value will change externally.
        }
        #endregion
        public void setIdleAni(Obj iObj, Timer idleAniAfter, Timer idleAniTime,funcOnIdle runOnIdle)
        {
            idleAnimation = new idleAni();
            idleAnimation.objInIdleAni = false;
            idleAnimation.idleObj = iObj;
            idleAnimation.delayTimer = idleAniAfter;
            idleAnimation.idleAniTimer = idleAniTime;
            idleAnimation.delayTimer.start();
            idleAnimation.runOnIdle = runOnIdle;
        }
        /// <summary>
        /// Swaps current image with new one, returining old
        /// </summary>
        /// <param name="_new"></param>
        /// <returns></returns>
        public Engine.Image swapTexture(string _newPath)
        {
            Engine.Image _new = new Engine.Image();
            Engine.Image old = tex;
            tex = _new;
            tex.Load(_newPath);
            tex.SetBlending();

            texAni = new Obj_texAni(this, _newPath);
            return old;
        }
        public void afterResize()
        {

        }
        public void setCurrentTexAlpha(byte alpha)
        {
            if (!texAni.enabled)
            {
                tex.SetBlending(alpha);
            }
            else
            {
                texAni[texAni.currentFrame].SetBlending(alpha);
            }
        }
        public byte getCurrentTexAlpha()
        {
            if (!texAni.enabled)
            {
                return tex.a;
            }
            else
            {
                return texAni[texAni.currentFrame].a;
            }
        }
        public void setAllTexsAlpha(byte alpha)
        {
            if (!texAni.enabled)
            {
                tex.SetBlending(alpha);
            }
            else
            {
                for(int i =0;i<texAni.Count;i++)
                texAni[i].SetBlending(alpha);
            }
        }

        private string variableTexture(string path)
        {
            List<string> varNames = new List<string>();
            string hlp = "";
            hlp = (string)path.Clone();
            //NO A0 in name? so this got to be static textureg
            if (hlp.LastIndexOf("V0") <= 0)
                return path;
            else
            {
                int idx = hlp.LastIndexOf("V0");
                varNames.Add(hlp);//adds V0
                string hlp2 = "";
                hlp2 = hlp.Remove(idx + 1, 1); hlp2 = hlp2.Insert(idx + 1, "1");
                int i = 1;
                while (System.IO.File.Exists(hlp2))
                {
                    i++;
                    varNames.Add(hlp2);
                    hlp2 = hlp.Remove(idx + 1, 1); hlp2 = hlp2.Insert(idx + 1, i.ToString());
                    
                };
                //get random name from list:
                return varNames[variatonizer.Next(i)];
            }
        }

            // if flag is true, after rendering it will be removed from viewport
            // + it will be renderedFrom separate onceRenderedObj List (to clear after each render
            private bool _renderOnce; public bool renderOnce{get{return _renderOnce;}}
            /// <summary>
            /// It's automatically add's Obj to viewport render queue
            /// </summary>
            public void setRenderOnce()
            {
                _renderOnce = true;
                Game.self.activeViewport.addObject(this);
            }
        /// <summary>
        /// Changes current frame of animation to some random number from ani range
        /// </summary>
            public void Desynchronize()
            {
                if (texAni != null)
                    texAni.currentFrame = variatonizer.Next(texAni.Count);
            }

        //GUI Objects: Dont give a fuck of camera position caues it's always on screen at exact position

            private bool _isGUIObject;
            public void guiObjRescale()
            {
                if (!_isGUIObject) return;
                //store old resolution
                int oResX=Profile.currentProfile.config.options.graphics.oldResolution.Width;
                int oResY=Profile.currentProfile.config.options.graphics.oldResolution.Height;
                //get new resolution
                int nResX=Profile.currentProfile.config.options.graphics.resolution.Width;
                int nResY=Profile.currentProfile.config.options.graphics.resolution.Height;

                // Scaling:
                //first, scale to multipiler
                ScaleAbs = ScaleAbs; //it's based on orginalHeight/Width and' yep this should do the job ;) trust me!
                //set scale to resolution
                int w = width, h = height;
                width = (int)(width * ((double)nResX / Viewport.guiBase_width));
                if (parentGame.activeViewport.GetHashCode() == parentGame.menuViewport.GetHashCode())
                    height = (int)(height * ((double)nResY / Viewport.guiBase_height_MENUOVERRIDE));
                else
                    height = (int)(height * ((double)nResY / Viewport.guiBase_height));
                //repositioning:
                posx = (int)((float)orgX / Viewport.guiBase_width * nResX);
                posy = (int)((float)orgY / Viewport.guiBase_width * nResX);                
                applyAlignCorrection();
                
                string line = "Obj:" + tex.bitmapPath.Substring(17) + ":: Scale(" + w.ToString() + "x" + h.ToString() + ")>>(" + width.ToString() + "," + height.ToString() + ")";
                line += " || Pos(" + orgX + "," + orgY + ")>>(" + posx + "," + posy + ")";
                Viewport.scaleLog.WriteLine(line);
            }
            public bool isGUIObject
            {
                get { return _isGUIObject; }
                set
                {
                    if ((_isGUIObject == false) && (value == true))
                    {
                        guiObjRescale();
                    }
                    _isGUIObject = value;
                }
            }
            public bool isGUIObjectButUnscaled
            {
                set { _isGUIObject = value; }
            }

            public void Rotate(float deg)
            {
                //tex.setRotationOrgin(width / 2, height / 2);
                tex.rotation = deg;

                for (int i = 0; i < texAni.Count; i++)
                    texAni[i].rotation = deg;
            }
            public Obj shallowCopy()
            {
                return (Obj)this.MemberwiseClone();
            }
            public void changeVisual(string newPath)
            {
                Engine.Image img = new Engine.Image();
                img.Load(newPath);
                if (img != null)
                {
                    img.SetBlending(255);
                    tex.Free();
                    tex = img;
                }
            }
        /// <summary>
        /// Used when creating object, when need to move object depend of position
        /// *RIGHT: (the "first" pixel will be the last so move whole object by (-width,-height)
        /// *CENTER(X/Y) (the "first" pixel will be in the middle, so move whole object by (-width/2,-height/2)
        /// </summary>
            public void applyAlignCorrection()
            {

                //correct position from align:
                if ((_align == align.CENTER_BOTH) || (_align == align.CENTER_X))
                    x -= (width / 2);
                else if (_align == align.RIGHT)
                    x -= width;

                if ((_align == align.CENTER_BOTH) || (_align == align.CENTER_Y))
                    y -= (height / 2);
                else if (_align == align.RIGHT)
                    y -= height;
            }
            /// <summary>
            /// try to sets destroyed visual(for object like bridges, etc
            /// </summary>
            /// <returns>return true if destroyed visual was found and set</returns>
            public bool setDestroyed()
            {
                String destPath = new String(tex.bitmapPath.ToCharArray());
                int insert = destPath.LastIndexOf(".");
                destPath = destPath.Insert(insert,"_DESTROYED");
                if (System.IO.File.Exists(destPath) == true)
                {
                    changeVisual(destPath);
                    return true;
                }
                return false;
            }
    }

    class Obj_texAni // this class is more like a struct by public fields
    {                // but whateva' if texAni field in Obj class is private ;)
        private List<Engine.Image> textures;
        public enum eLoopType { NONE, DEFAULT, REWIND, DISPOSE };
        public bool enabled = false;
        public int _fps = 5;
        public int currentFrame = 0;
        public eLoopType loopType = eLoopType.DEFAULT;
        public bool isRewinding = false;
        public bool isControlledExternal;
        public int FPS
        {
            get { return _fps; }
            set { if (value > 0) _fps = value; }
        }
        public int Count
        {
            get { if (textures == null)return 0; return textures.Count; }
        }
        private Obj owner = null;
        public Obj_texAni(Obj o, string texPath)
        {
            owner = o;
            FPS = 5;
            List<string> texNames = extractTextureAniFrames(texPath);
            if (texNames != null)
            {
                textures = new List<Engine.Image>();
                currentFrame = 0;
                enabled = true;
                for (int i = 0; i < texNames.Count; i++)
                {
                    textures.Add(new Engine.Image());
                    textures[i].Load(texNames[i]);
                    textures[i].SetBlending();
                }
            };
        }
        public bool Render(int px, int py)
        {
            if (enabled)
            {
                int x, y;
                Camera activeCam = Game.self.gameCamera;
                if (owner.isGUIObject) activeCam = new Camera(Camera.eType.STATIC);

                    x = px + activeCam.camOffsetX;
                    y = py + activeCam.camOffsetY;
                    if ((textures[0].w != textures[currentFrame].w) || (textures[0].h != textures[currentFrame].h))
                    {
                        if ((owner.objAlign == Obj.align.CENTER_BOTH) || (owner.objAlign == Obj.align.CENTER_X))
                        {   //centering 9                       obj by first frame is evil, recalculate offset always!
                            x = px + (int)owner.orginalWidth / 2 + activeCam.camOffsetX - textures[currentFrame].w / 2;
                        }
                        else if (owner.objAlign == Obj.align.RIGHT)
                        {
                            x = px + (int)owner.orginalWidth + activeCam.camOffsetX - textures[currentFrame].w;
                        }
                        if ((owner.objAlign == Obj.align.CENTER_BOTH) || (owner.objAlign == Obj.align.CENTER_Y))
                        {
                            y = py + (int)owner.orginalHeight / 2 + activeCam.camOffsetY - textures[currentFrame].h / 2;
                        }
                    }
                // Calculate next tex frame to render:
                if (isControlledExternal == false)
                {
                    int curframe = Game.self.getFrame();
                    int gameFPS = (int)Game.self.RenderFrequency;//TODO: PRECISE ..hmm.. (int)Game.self.RenderFrequency;
                    this._fps = FPS;
                    int hlp = gameFPS / FPS; if (hlp <= 0) hlp = 1;
                    //todo: correct !!!
                    if (curframe % hlp == 0)//time to draw further tex frame
                    {
                        if (currentFrame + 1 == textures.Count) //last frame reached, time to do sth
                        {
                            if (loopType == eLoopType.DEFAULT)
                                currentFrame = 0;
                            else if (loopType == eLoopType.DISPOSE)
                                owner.setRenderOnce();//<- this simple trick does job of removing whole obj
                            else if (loopType == eLoopType.REWIND)
                            {
                                isRewinding = true;
                                currentFrame--;
                            }
                        }
                        else if (!isRewinding) currentFrame++;
                        if (isRewinding) // texAni is rewinding back:
                        {
                            if (currentFrame > 0) // still not first frame, continue rewinding
                                currentFrame--;
                            else // first frame reached, stop rewinding
                            {
                                isRewinding = false;
                                currentFrame++;
                            }
                        } // texAni goes forward as usual:
                        // else currentFrame = (currentFrame + 1) % textures.Count;
                    }
                }

                textures[currentFrame].Draw(x, y);
                return true;
            };
            return false;
        }
        public Engine.Image this[int index]
        {
            get { return textures[index]; }
        }

        public void reScale(double w, double h)
        {
                for (int i = 0; i < textures.Count; i++)
                {
                    textures[i].scaleX *= (float)w;
                    textures[i].scaleY *= (float)h;
                }
        }
        // private methods:
        private List<string> extractTextureAniFrames(string f)
        {
            List<string> ret = new List<string>();
            string hlp = "";
            hlp = (string)f.Clone();
            //NO A0 in name? so this got to be static textureg
            if (hlp.LastIndexOf("_A0") <= 0)
                return null;
            else
            {
                int idx = hlp.LastIndexOf("_A0");
                ret.Add(hlp);
                string hlp2 = "";
                hlp2 = hlp.Remove(idx + 2, 1); hlp2 = hlp2.Insert(idx + 2, "1");
                int i = 2;
                while (System.IO.File.Exists(hlp2))
                {
                    ret.Add(hlp2);
                    hlp2 = hlp.Remove(idx + 2, 1); hlp2 = hlp2.Insert(idx + 2, i.ToString());
                    i++;
                };
                return ret;
            };

        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using EngineApp;

namespace CookieMonster.CookieMonster_Objects
{
    class Obj_Animation
    {
        #region fields
        private const double DEFAULT_SPEED = 1.0;
        public enum eAniType { PointToPoint, Random };
        public enum eLoopType { ToOrginStep, ToFirst, Rewind, None };
        public enum eAffectionFlags { NONE = 0, affectPos = 1, affectScale = 2, affectOpacity = 4 }
        private eAniType type;
        private eLoopType loop;
        public eAffectionFlags affectionFlags;

        private int orginPosX, orginPosY;
        private int frames; //frames that passed from the begining
        private List<int> keyframePosX = new List<int>();
        private List<int> keyframePosY = new List<int>();
        private List<double> keyframeScale = new List<double>(); double scaleStep;
        private List<double> keyframeOpacity = new List<double>();
        private List<double> keyframeSpeed = new List<double>(); //pixels/frame
        /// <summary>
        /// if KeyframeDuration is present animation steps will be generated based on duration of next keyframe
        /// </summary>
        private List<Timer> keyframeDuration = new List<Timer>();
        private int currentKeyframe, nextKeyframe;
        private double currentPosX, currentPosY; // it need to be stored double cuz there is able to move
        private Obj owner = null;               // obj by 0.1px per frame etc. this value is always
        private bool relativeMovement;
        private double scaleLastPartDone;
        public bool isIngameAnimation { get; private set; }
        // rounded for Obj coordinates
        #endregion
        /// <summary>
        /// creating Obj_Animation but without frames,
        /// they need to be added by addKeyframe method
        /// </summary>
        /// <param name="aniObj"></param>
        public Obj_Animation(Obj aniObj)
        {
            orginPosX = aniObj.x; orginPosY = aniObj.y;
            owner = aniObj;
            type = eAniType.PointToPoint;
            loop = eLoopType.ToOrginStep;
            currentKeyframe = 0; nextKeyframe = 1;
            currentPosX = (double)orginPosX;
            currentPosY = (double)orginPosY;
            frames = 0;
            affectionFlags = eAffectionFlags.affectOpacity | eAffectionFlags.affectPos | eAffectionFlags.affectScale;


            if (Game.self.gameManager==null || !((Game.self.gameState & Game.game_state.Game) == Game.game_state.Game) || Game.self.gameManager.gamePaused)
                isIngameAnimation = false;
            else
                isIngameAnimation = true;
        }
        /// <summary>
        /// Creates Obj_Animation, getting orgin positions from current obj positions
        /// </summary>
        /// <param name="aniObj"></param>
        /// <param name="tX"></param>
        /// <param name="tY"></param>
        public Obj_Animation(Obj aniObj, int tX, int tY)
            : this(aniObj)
        {
            keyframePosX.Add(tX); keyframePosY.Add(tY);
        }
        /// <summary>
        /// Creates Obj_Animation, getting orgin positions from current obj positions
        /// </summary>
        /// <param name="aniObj"></param>
        /// <param name="tX"></param>
        /// <param name="tY"></param>
        /// <param name="tS"></param>
        public Obj_Animation(Obj aniObj, int tX, int tY, double tS)
            : this(aniObj, tX, tY)
        {
            keyframeSpeed.Add(tS); keyframeSpeed.Add(tS);
        }
        public Obj_Animation(Obj aniObj, int tX, int tY, double tSpeed, double tScale)
            : this (aniObj,tX,tY,tSpeed)
        {
            keyframeScale.Add(tScale);
        }
        public Obj_Animation(Obj aniObj, int tX, int tY, double tSpeed, double tScale,bool createKeyframeFromOrginObj)
            : this(aniObj, tX, tY, tSpeed,tScale)
        {
            if (createKeyframeFromOrginObj)
            {
                keyframePosX.Insert(0, aniObj.x);
                keyframePosY.Insert(0, aniObj.y);
                keyframeScale.Insert(0, Math.Max(aniObj.scale[0], aniObj.scale[1]));
            }
        }

        public void computeFrame()
        {
            if (nextKeyframe == -1) return;
            double stepx = 0.0, stepy = 0.0;
            if (frames == 0)
            {
                if (keyframeScale.Count > 0)
                {
                    if(keyframeDurationIsBasedOnTimer())
                        if (keyframeDuration[nextKeyframe] != null)
                            keyframeDuration[nextKeyframe].start();

                    if ((affectionFlags & eAffectionFlags.affectScale) == eAffectionFlags.affectScale)
                        owner.ScaleAbs = keyframeScale[0];
                }
            }

            if ((affectionFlags & eAffectionFlags.affectPos) == eAffectionFlags.affectPos)
            {
                computeXYstep(ref stepx, ref stepy);

                if (!keyframeReached(stepx, 0.0))//check for x only:
                    currentPosX += stepx;
                if (!keyframeReached(0.0, stepy))//check for y only:
                    currentPosY += stepy;
            }

            if ((affectionFlags & eAffectionFlags.affectScale) == eAffectionFlags.affectScale)
            {
                computeScaleStep();
            }


            // check if keyframe target pos was reached:
            if (keyframeReached(stepx, stepy))
            {
                correctTransforms();
                if (type == eAniType.PointToPoint)
                {
                    proceedToNextKeyframe();                    
                }
            }

            if ((affectionFlags & eAffectionFlags.affectPos) == eAffectionFlags.affectPos)
            {
                owner.x = (int)Math.Floor(currentPosX); owner.y = (int)Math.Floor(currentPosY);
            }

            //sets new scale (only if scale is not time-based
            if ((nextKeyframe < keyframeScale.Count)&& (keyframeDuration.Count < nextKeyframe)&&((affectionFlags & eAffectionFlags.affectScale) == eAffectionFlags.affectScale))
            { 
                double[] scale = new double[2];
                scale = owner.scale;
                scale[0] += scaleStep;
                scale[1] += scaleStep;
                owner.scale = scale;
            };
            frames++;
        }

        private bool keyframeReached(double stepx, double stepy)
        {
            //keyframe duration is present
            if ( keyframeDurationIsBasedOnTimer() &&
                (keyframeDuration[nextKeyframe].enabled == false))
            {
                return true;
            }
            else if (!keyframeDurationIsBasedOnTimer())
            {
                //movement absolute:
                if (relativeMovement == false &&
                    (((stepx > 0.0) && (currentPosX >= keyframePosX[nextKeyframe]))
                      || ((stepx < 0.0) && (currentPosX <= keyframePosX[nextKeyframe])) || (stepx == 0.0))
                 && (((stepy > 0.0) && (currentPosY >= keyframePosY[nextKeyframe]))
                   || ((stepy < 0.0) && (currentPosY <= keyframePosY[nextKeyframe])) || (stepy == 0.0))
                   )
                {
                    return true;
                }
                else if (relativeMovement &&
                    (((stepx > 0.0) && (currentPosX - orginPosX >= keyframePosX[nextKeyframe]))
                      || ((stepx < 0.0) && (currentPosX - orginPosX <= keyframePosX[nextKeyframe])) || (stepx == 0.0))
                 && (((stepy > 0.0) && (currentPosY - orginPosY >= keyframePosY[nextKeyframe]))
                   || ((stepy < 0.0) && (currentPosY - orginPosY <= keyframePosY[nextKeyframe])) || (stepy == 0.0))
                        )
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }

        private bool keyframeDurationIsBasedOnTimer()
        {
            return (keyframeDuration.Count > nextKeyframe) && (keyframeDuration[nextKeyframe] != null);
        }

        private void computeXYstep(ref double stepx, ref double stepy)
        {
            double speed;
            double oldCurrentPosX = currentPosX;
            double oldCurrentPosY = currentPosY;
            if (keyframeDuration.Count > nextKeyframe) // compute base on keyframe duration
            { //TODO: obivously...

            }
            else //computations will be based on keyframe Speed:
            {
                if (keyframeSpeed.Count > nextKeyframe)
                    speed = keyframeSpeed[nextKeyframe];
                else
                    speed = DEFAULT_SPEED;

                if (keyframePosX[currentKeyframe] < keyframePosX[nextKeyframe])
                    stepx = speed;
                else if (keyframePosX[currentKeyframe] > keyframePosX[nextKeyframe])
                    stepx = (-1.0) * speed;

                if (keyframePosY[currentKeyframe] < keyframePosY[nextKeyframe])
                    stepy = speed;
                else if (keyframePosY[currentKeyframe] > keyframePosY[nextKeyframe])
                    stepy = (-1.0) * speed;
            }
        }
        private void computeScaleStep()
        {
            if (keyframeDuration.Count > nextKeyframe) // compute base on keyframe duration
            {
                double scaleDifference = keyframeScale[nextKeyframe] - keyframeScale[currentKeyframe];
                Timer keyTimer = keyframeDuration[nextKeyframe];
                double partDone = keyTimer.totalTime - keyTimer.currentTime;
                partDone /= keyframeDuration[nextKeyframe].totalTime;
                double thisStepProgress = partDone - scaleLastPartDone;

                //sets new scale:
                double[] scale = new double[2];
                scale = owner.scale;
                scale[0] = keyframeScale[currentKeyframe] + scaleDifference * partDone;
                scale[1] = keyframeScale[currentKeyframe] + scaleDifference * partDone;
                owner.scale = scale;

                scaleLastPartDone = partDone;
            }
            else
            {
                if ((nextKeyframe != -1) && (nextKeyframe < keyframeScale.Count))
                {
                    double predictedFrames = Math.Max(Math.Abs(keyframePosX[currentKeyframe] - keyframePosX[nextKeyframe]), Math.Abs(keyframePosY[currentKeyframe] - keyframePosY[nextKeyframe])) / keyframeSpeed[nextKeyframe];
                    if (predictedFrames != 0.0)
                        scaleStep = Math.Abs(keyframeScale[nextKeyframe] - keyframeScale[currentKeyframe]) / predictedFrames;
                    else
                        scaleStep = keyframeScale[nextKeyframe];
                }
            }
        }
        /// <summary>
        /// Corrects positions and scale to be just the same
        /// as specified in nextKeyframe Lists
        /// </summary>
        private void correctTransforms()
        {
            //correct position:
            if (((affectionFlags & eAffectionFlags.affectPos) == eAffectionFlags.affectPos))
            {
                if (!relativeMovement)
                {
                    currentPosX = keyframePosX[nextKeyframe];
                    currentPosY = keyframePosY[nextKeyframe];
                }
                else
                {
                    currentPosX = orginPosX + keyframePosX[nextKeyframe];
                    currentPosY = orginPosY + keyframePosY[nextKeyframe];

                }
            }
            //correct scale:
            if ((affectionFlags & eAffectionFlags.affectScale) == eAffectionFlags.affectScale)
            {
                double[] scale = new double[2];
                if (keyframeScale.Count >= nextKeyframe)
                {
                    scale[1] = scale[0] = keyframeScale[nextKeyframe];
                    owner.scale = scale;
                }
            }
        }

        private void proceedToNextKeyframe()
        {
            if (loop == eLoopType.ToOrginStep)
            {
                currentPosX = (double)orginPosX;
                currentPosY = (double)orginPosY;
                currentKeyframe = 0;
                nextKeyframe = 1 % keyframePosX.Count;
            }
            if (loop == eLoopType.ToFirst)
            {
                currentKeyframe = nextKeyframe;
                nextKeyframe = (nextKeyframe + 1) % keyframePosX.Count;
            }
            else if (loop == eLoopType.Rewind)
            {
                //toDo: rewind whole list instead
                nextKeyframe = currentKeyframe;
                currentKeyframe = (nextKeyframe - 1) % keyframePosX.Count;
            }
            else if (loop == eLoopType.None)
            {
                if (nextKeyframe < keyframePosX.Count - 1)
                {
                    //toDo: remove whole list instead
                    currentKeyframe = nextKeyframe;
                    nextKeyframe++;
                }
            }
            //curent frame/ next frame calculated, start keyframeDuration timer if it's present
            if (nextKeyframe < keyframeDuration.Count)
                if (keyframeDuration[nextKeyframe] != null)
                    keyframeDuration[nextKeyframe].start();

        }



        public void addKeyframe(int tX, int tY, double tS)
        {
            keyframePosX.Add(tX); keyframePosY.Add(tY);
            keyframeSpeed.Add(tS);
        }
        public void addKeyframe(int tX, int tY, double tSpeed,double tScale)
        {
            addKeyframe(tX, tY, tSpeed);
            keyframeScale.Add(tScale);
        }
        public void addKeyframe(int tX, int tY, double tSpeed, double tScale, Timer duration)
        {
            addKeyframe(tX, tY, tSpeed,tScale);
            keyframeDuration.Add(duration);

        }
        public void setLoopType(eLoopType l)
        {
            loop = l;
        }
        public void gotoKeyframe(int f)
        {
            if ((f >= 0) && (f + 1 < keyframePosX.Count))
            {
                if ((affectionFlags & eAffectionFlags.affectPos) == eAffectionFlags.affectPos)
                {
                    if (!relativeMovement)
                    {
                        currentPosX = owner.x = keyframePosX[f];
                        currentPosY = owner.y = keyframePosY[f];
                    }
                    else
                    {
                        currentPosX = orginPosX;
                        currentPosY = orginPosY;
                    }
                }
                if ((affectionFlags & eAffectionFlags.affectScale) == eAffectionFlags.affectScale)
                {
                    //double predictedFrames = Math.Max(Math.Abs(keyframePosX[f] - keyframePosX[f + 1]), Math.Abs(keyframePosY[f] - keyframePosY[f + 1])) / keyframeSpeed[f + 1];
                    //scaleStep = Math.Abs(keyframeScale[f + 1] - keyframeScale[f]) / predictedFrames;
                    scaleLastPartDone = 0.0;
                    //rescale:
                    double[] scale = new double[2];
                    scale[1] = scale[0] = keyframeScale[f];
                    owner.scale = scale;
                }
                currentKeyframe = f;
                nextKeyframe = f + 1;
            }
        }
        public void setRelativeMovement()
        {
            relativeMovement = true;
        }
        public void setAbsoluteMovement()
        {
            relativeMovement = false;
        }
    }

}
using System;
using System.Collections.Generic;
using System.Text;
using EngineApp;
using QuickFont;
using OpenTK.Graphics;

namespace CookieMonster.CookieMonster_Objects
{
    [Serializable]
    class Profile
    {
        static private string profileExt = ".CMprofile";
        static private Profile hlpProfile;
        static private Profile _current;
        static public Profile currentProfile { 
            get {
                if (_current == null) return hlpProfile;
                else return _current;
                }
            private set { _current = value; value.applyCurrentProfile(); }
        }
        static public List<Profile> profilesList { get; private set; }
        static public int menuSelectedProfile { get; private set; }
        public string name { get; private set; }
        public Configuration config { get; private set; }
        public Savegame save { get; private set; }
        
        static Profile()
        {
            profilesList = new List<Profile>();
            menuSelectedProfile = -1;
        }
        /// <summary>
        /// loads profile from hard drive
        /// + any other initialization stuff
        /// </summary>
        static public void Initialize()
        {
            hlpProfile = new Profile("");

            string[] profiles = System.IO.Directory.GetFiles("../data/User Profiles/", "*" + profileExt);
            for(int i=0;i<profiles.Length;i++)
                decryptFromFile(profiles[i]);

            //default selected profile:
            if (profilesList.Count > 0)
                menuSelectedProfile = 1; //first at list
            else
                menuSelectedProfile = 0;//(create profile)
        }
        /// <summary>
        /// Creates new profille, adds it to static profilesList
        /// </summary>
        /// <param name="n">name of profile</param>
        public Profile(String n)
        {
            name = n;
            config = new Configuration();
            if (n != "")//blank - helper profile
                profilesList.Add(this);
        }
        /// <summary>
        /// Auto-save game state
        /// </summary>
        public void autoSave()
        {
            if(save == null)
                save = new Savegame();
            save.Update();
            //update profile file:
            encryptToFile();
        }
        //TODO: apply resolution 
        public void applyCurrentProfile()
        {
            Game.self.SoundMan.recalculateMusic();
            Game.self.SoundMan.recalculateSFX();
        }
        public static void Menu_GenerateProfileMenu()
        {
            //remove items (those used for creating/selecting profile)
            Menu profile = Game.self.menuManager.getMenuByName("MENU_PROFILE");
            //profile.removeMenuItem(profile.getItemByName("ArrL"));
            //profile.removeMenuItem(profile.getItemByName("ArrR"));


            generateStaticObjs(profile);

            generateArrowLeft(profile);
            genrateArrowRight(profile);
            generateProfileName(profile);
            generateOKButton(profile);
            genereateDeleteButton(profile);

        }

        private static void generateStaticObjs(Menu profile)
        {
            Obj profileLoginFrame = new Obj("../data/Textures/MENU/MENU_PROFILE.dds", 0.5, 0.43, Obj.align.CENTER_BOTH, false);
            profileLoginFrame.isGUIObjectButUnscaled = true;
            profile.addItem(new Menu_Item("BG", profileLoginFrame, null, null, null, null, null));

            QFont heading1 = TextManager.newQFont("KOMIKAX.ttf", 22, true, new OpenTK.Graphics.Color4(0, 112, 186, 255));
            

            float x = Game.self.activeViewport.width / 2 - heading1.Measure(Lang.cur.Wybierz_Profil).Width / 2;
            float y = Game.self.activeViewport.height * 4 / 10 + 10f;
            profile.addItem(new Menu_Item(Lang.cur.Wybierz_Profil, x, y, heading1));
        }

        private static void genereateDeleteButton(Menu profile)
        {
            QFont DeleteProf = TextManager.newQFont("Rumpelstiltskin.ttf", 32, false, new Color4(0, 112, 186, 255));              
            float x = Game.self.activeViewport.width / 2 - DeleteProf.Measure(Lang.cur.Usun_Profil).Width / 2 - 120f;
            float y = Game.self.activeViewport.height / 2 + 75f; 
                if (menuSelectedProfile > 0)
                {//some profile is selected, can delete it:
                    //DeleteProf = TextManager.newQFont("Rumpelstiltskin.ttf", 32, false, new Color4(0, 112, 186, 255));
                    QFont DeleteProfhover = TextManager.newQFont("Rumpelstiltskin.ttf", 32, true, new Color4(0, 112, 186, 255));
                    profile.addItem(new Menu_Item(Lang.cur.Usun_Profil, x, y, DeleteProf, DeleteProfhover, DeleteProf, Profile.Menu_DeleteProfile));
                }
                else
                {//can't delete profile
                    DeleteProf = TextManager.newQFont("Rumpelstiltskin.ttf", 32, false, new Color4(120, 120, 120, 255));                   
                    profile.addItem(new Menu_Item(Lang.cur.Usun_Profil, x, y, DeleteProf));
                }
        }
        private static void generateOKButton(Menu profile)
        {
            QFont OK = TextManager.newQFont("Rumpelstiltskin.ttf", 32, false, new Color4(40, 100, 133, 255));
            
            string tmp = InputManager.getInputBuffer();

            float x = Game.self.activeViewport.width / 2 - OK.Measure(Lang.cur.OK).Width / 2 + 200f;
            float y = Game.self.activeViewport.height / 2 + 75f;
            if (menuSelectedProfile > 0 || (menuSelectedProfile == 0 && tmp.Length > 0 && profile.inputItem.value != profile.inputItem.defaultValue))
            {//OK Active:
                QFont OKhover = TextManager.newQFont("Rumpelstiltskin.ttf", 32, true, new Color4(0, 112, 186, 255));
                profile.addItem(new Menu_Item(Lang.cur.OK, x, y, OK, OKhover, OK, Profile.Menu_CreateProfile));
            }
            else
            {//OK Inactive:
                OK = TextManager.newQFont("Rumpelstiltskin.ttf", 32, false, new Color4(120, 120, 120, 255));
                profile.addItem(new Menu_Item(Lang.cur.OK, x, y, OK));
            }
        }

        private static void generateProfileName(Menu profile)
        {
            //Profile name (or input) text:

            QFont profileName = TextManager.newQFont("Rumpelstiltskin.ttf", 24, false, new Color4(220, 220, 220, 255));
            QFont profileName_hover = TextManager.newQFont("Rumpelstiltskin.ttf", 24, false, new Color4(255, 255, 255, 255));

            float y = Game.self.activeViewport.height / 2 - 18f;

            float x;
            if (menuSelectedProfile == 0)//create profile:
            {
                x = Game.self.activeViewport.width / 2 - profileName.Measure(Lang.cur.stworz_nowy).Width / 2;
                profile.addInputItem(new Menu_Input_Item(x, y, profileName, profileName_hover, null, Lang.cur.stworz_nowy, false));
            }
            else if (menuSelectedProfile > 0)
            {
                string pName = profilesList[menuSelectedProfile - 1].name;
                x = Game.self.activeViewport.width / 2 - profileName.Measure(pName).Width / 2;
                profile.addInputItem(new Menu_Input_Item(x, y,profileName,null,pName,true));
            }
        }

        private static void genrateArrowRight(Menu profile)
        {
            Obj arrRight;
            if (menuSelectedProfile < profilesList.Count)
            {
                arrRight = new Obj("../data/Textures/MENU/MENU_ARROW_RIGHT.dds", 0.5, 0.5, Obj.align.CENTER_BOTH, false);
                profile.addItem(new Menu_Item("ArrR", arrRight, null, null, null, null, Menu_RightProfile));
            }
            else
            {
                arrRight = new Obj("../data/Textures/MENU/MENU_ARROW_RIGHT_DISABLED.dds", 0.5, 0.5, Obj.align.CENTER_BOTH, false);
                profile.addItem(new Menu_Item("ArrR", arrRight, null, null, null, null, null));
            }

            arrRight.isGUIObjectButUnscaled = true;
            arrRight.x += 125;
        }
        public static void Menu_RightProfile()
        {
            Menu profile = Game.self.menuManager.getMenuByName("MENU_PROFILE");
            profile.clearMenuItems();
            menuSelectedProfile++;
            Menu_GenerateProfileMenu();
        }

        private static void generateArrowLeft(Menu profile)
        {
            Obj arrLeft;
            if (menuSelectedProfile > 0)
            {
                arrLeft = new Obj("../data/Textures/MENU/MENU_ARROW_LEFT.dds", 0.5, 0.5, Obj.align.CENTER_BOTH, false);
                profile.addItem(new Menu_Item("ArrL", arrLeft, null, null, null, null, Menu_LeftProfile));
            }
            else
            {
                arrLeft = new Obj("../data/Textures/MENU/MENU_ARROW_LEFT_DISABLED.dds", 0.5, 0.5, Obj.align.CENTER_BOTH, false);
                profile.addItem(new Menu_Item("ArrL", arrLeft, null, null, null, null, null));
            }
            arrLeft.isGUIObjectButUnscaled = true;
            arrLeft.x -= 125;
        }
        public static void Menu_LeftProfile()
        {
            Menu profile = Game.self.menuManager.getMenuByName("MENU_PROFILE");
            profile.clearMenuItems();
            menuSelectedProfile--;
            Menu_GenerateProfileMenu();
        }
        public static void Profile_KeyStroke(object sender, OpenTK.Input.KeyboardKeyEventArgs p)
        {
            if (Game.self.menuManager == null) return;
            Menu profile = Game.self.menuManager.getMenuByName("MENU_PROFILE");
            if (Game.self.menuManager.current_menu != profile) return; //current menu isnot profile, break func
            if (InputManager.inputLogging == false) return; //no input loging, break

            profile.removeMenuItem(profile.getItemByName("OK"));
            generateOKButton(profile);

        }

        public static void Menu_CreateProfile()
        {
            if (menuSelectedProfile == 0)
            { //new profile was created:
                currentProfile = new Profile(InputManager.getInputBuffer());
                currentProfile.encryptToFile();
            }
            else
            {
                currentProfile = profilesList[menuSelectedProfile - 1];
            }
            //goto main menu:
            Game.self.menuManager.current_menu = new Menu("MENU_MAIN", Menu_Instances.Main_OnLoad, Menu_Manager.cursor);
            
        }
        public static void Menu_DeleteProfile()
        {
            string name = profilesList[menuSelectedProfile - 1].name;
            System.IO.File.Delete("../data/User Profiles/"+name+profileExt);
            profilesList.RemoveAt(menuSelectedProfile - 1);
            Game.self.menuManager.showAlert(Lang.cur.Usunieto_Profil_n+name);
            menuSelectedProfile--;
            //redraw choose profile menu:
            Menu_GenerateProfileMenu();
        }
        public void encryptToFile()
        {
            string result = "";
            result += config.encrypt();
            result += "%";//%- end of block
            if(save!=null)
                result +=save.encrypt();
            //replace chars, to add some more confussion:
            //0 -> +
            //2 -> G
            //3 -> h
            //5 -> 2
            //8 -> _
            //C -> 0
            //F -> m
            result = result.Replace("0", "+");
            result = result.Replace("2", "G");
            result = result.Replace("3", "h");
            result = result.Replace("5", "2");
            result = result.Replace("8", "_");
            result = result.Replace("C", "0");
            result = result.Replace("F", "m");

            System.IO.File.WriteAllText("../data/User Profiles/" + name + profileExt, result);

        }
        private static void decryptFromFile(string filepath)
        {
            string name = "???";
            try
            {
                string result = System.IO.File.ReadAllText(filepath);
                Profile p;
                int b = filepath.LastIndexOf("/") + 1;
                name = filepath.Substring(b, filepath.LastIndexOf(profileExt) - b);
                p = new Profile(name);

                result = result.Replace("2", "5");
                result = result.Replace("G", "2");
                result = result.Replace("h", "3");
                result = result.Replace("_", "8");
                result = result.Replace("0", "C");
                result = result.Replace("+", "0");
                result = result.Replace("m", "F");
                string conf = result.Substring(0, result.IndexOf("%"));
                p.config.decrypt(conf);

                string save = result.Substring(result.IndexOf("%") + 1);
                if (save.Length > 0)
                {
                    p.save = new Savegame();
                    p.save.decrypt(save);
                }
            }
            catch (Exception e)
            {
                Game.self.menuManager.showAlert(Lang.cur.Blad_Odczytu_profilu_o_nazwie + name + "\n"+Lang.cur.Komunikat_Bledu+"\n\""+e.Message+"\"\n"+Lang.cur.Usuwam_Powyzszy_Profil);
                System.IO.File.Delete(filepath);
                //remove last created profile:
                profilesList.RemoveAt(profilesList.Count - 1);
            }
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using OpenTK;
using OpenTK.Graphics.OpenGL;
namespace CookieMonster.CookieMonster_Objects
{
    class radialGradient
    {

        //                                     //(src)x(dst)
        public enum blendingMode   {NORMAL,    // One x One
                                    ADD,       // SrcAlpha x One
                                    MULTIPLY}; // One x One (equation: multiply)
         
        
        static Vector4 defaultInnerColor = new Vector4(1f, 1f, 1f, 1f);
        static Vector4 defaultOuterColor = new Vector4(0f, 0f, 0f, 1f);
        static int defaultSlices = 7;
        // Size,Positon,shape
        private Vector2 cPos;
        public Vector2 centerPos { get { return cPos; } }
        public float radius { get; private set; }
        float orgRadius;//save it for scaling purposes
        int     slices; // start looking good from 8 slices or more

        // colors
        Vector4 innerColor, outerColor;

        // blendings
        public blendingMode blendMode { get; private set; }
        BlendingFactorSrc gradSrcBlending;
        BlendingFactorDest gradDestBlending;

        #region Constructors
        /// <summary>
        /// Creates radial gradient with default Colors(white in center, black on edges)
        /// and default blending and slices number(8)
        /// </summary>
        /// <param name="cP">Location of the midde of the gradient on screen</param>
        /// <param name="rad">Radius of the "circle" (in pixels)</param>
        public radialGradient(Vector2 cP,float rad)
        {
            cPos = cP;
            orgRadius = radius = rad;
            slices = defaultSlices;

            //pick default colors #FFFF in, #000F out:
            innerColor = defaultInnerColor;
            outerColor = defaultOuterColor;

            //pick default blending:
            gradSrcBlending  = BlendingFactorSrc.SrcAlpha;
            gradDestBlending = BlendingFactorDest.One;//currently buffer
        }
        /// <summary>
        /// Creates radial gradient with default blending and slices number(8)
        /// </summary>
        /// <param name="cP">Location of the midde of the gradient on screen</param>
        /// <param name="rad">Radius of the "circle" (in pixels)</param>
        /// <param name="iC">inner Color of gradient(0-1f)</param>
        /// <param name="oC">outter Color of gradient(0-1f)</param>
        public radialGradient(Vector2 cP, float rad, Vector4 iC, Vector4 oC) : this(cP,rad)
        {
            innerColor = iC; outerColor = oC;
        }
        /// <summary>
        /// Creates radial gradient with default slices number(8)
        /// </summary>
        /// <param name="cP">Location of the midde of the gradient on screen</param>
        /// <param name="rad">Radius of the "circle" (in pixels)</param>
        /// <param name="iC">inner Color of gradient(0-1f)</param>
        /// <param name="oC">outter Color of gradient(0-1f)</param>
        /// <param name="d">Destination blend func</param>
        /// <param name="s">Source blend func</param>
        public radialGradient(Vector2 cP, float rad, Vector4 iC, Vector4 oC,BlendingFactorSrc s,BlendingFactorDest d)
            : this(cP, rad,iC,oC)
        {
            gradSrcBlending = s; gradDestBlending = d;
        }
        /// <summary>
        /// Creates radial gradient.
        /// </summary>
        /// <param name="cP">Location of the midde of the gradient on screen</param>
        /// <param name="rad">Radius of the "circle" (in pixels)</param>
        /// <param name="iC">inner Color of gradient(0-1f)</param>
        /// <param name="oC">outter Color of gradient(0-1f)</param>
        /// <param name="d">Destination blend func</param>
        /// <param name="s">Source blend func</param>
        /// <param name="sl">Vert Fan slices count(more smoother it looks)</param>
        public radialGradient(Vector2 cP, float rad, Vector4 iC, Vector4 oC, BlendingFactorSrc s, BlendingFactorDest d,int sl)
            : this(cP, rad, iC, oC,s,d)
        {
            slices = sl;
        }
        #endregion
        /// <summary>
        /// Changes blending functions to those
        /// passed as parameters.
        /// </summary>
        /// <param name="s">New Source blending</param>
        /// <param name="d">New Destination blending</param>
        public void changeBlendFunc(BlendingFactorSrc s, BlendingFactorDest d)
        { gradSrcBlending = s; gradDestBlending = d; }
        /// <summary>
        /// Sets gradient colors to those passed as
        /// parameters
        /// </summary>
        /// <param name="iColor">inner</param>
        /// <param name="oColor">outer</param>
        public void changeColors(Vector4 iColor, Vector4 oColor)
        { innerColor = iColor; outerColor = oColor; }

        /// <summary>
        /// Scale gradien size(radius) by multipiler
        /// passed as argument (by orgRadius!!!)
        /// </summary>
        public void scale(float scale)
        {
            radius = orgRadius * scale;
        }
        /// <summary>
        /// Move center of gradient to new position
        /// </summary>
        /// <param name="newPos"></param>
        public void Move(Vector2 newPos)
        {
            cPos = newPos;
        }
        /// <summary>
        /// Move center of gradient to new position
        /// </summary>
        /// <param name="newPos"></param>
        public void moveRelatively(Vector2 newPos)
        {
            cPos.Add(newPos);
        }
        /// <summary>
        /// Draws this radialGradient To current openGL buffer.
        /// </summary>
        public void drawGradientToBuffer()
        {
            float incr = (float)(2 * Math.PI / slices);

            GL.BindTexture(TextureTarget.Texture2D, 0);//Unbind Texture2d

            //GL.BlendEquation(BlendEquationMode.FuncAdd);
            GL.BlendFunc(gradSrcBlending, gradDestBlending);
            GL.ShadeModel(ShadingModel.Smooth);
            GL.BlendEquation(BlendEquationMode.FuncAdd);
                GL.Begin(BeginMode.TriangleFan);
                GL.Color4(innerColor);
                GL.Vertex2(centerPos);
                GL.Color4(outerColor);

                // Generating fan verts:
                for (int i = 0; i < slices; i++)
                {
                    float angle = incr * i;
                    float x = (float)Math.Cos(angle) * radius;
                    float y = (float)Math.Sin(angle) * radius;
                    GL.Vertex2(centerPos.X + x, centerPos.Y + y);
                }

                GL.Vertex2(centerPos.X + radius, centerPos.Y);
            GL.End();
            //Back to old blend function:
            GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
            GL.ShadeModel(ShadingModel.Flat);
        }

    }
}
using System;
using System.Collections.Generic;
using System.Text;

namespace CookieMonster.CookieMonster_Objects
{
    class mapSave
    {
        internal uint data;
        internal uint data2;

        //public uint level : 8; (0-256)
        public uint level
        {
            get { return data & 0xFF; }
            set { data = (data & ~0xFFu) | (value & 0xFF); }//u at end of hex means unsigned
        }

        //public uint lives : 6 (64)
        public uint lives
        {
            get { return (uint)((data >> 8) & 0x3F); }
            set { data = (data & ~(0x3Fu << 8)) | (value & 0x3F) << 8; }
        }

        //public uint score : 12 (4096)
        public uint lvlScore
        {
            get { return (data >> 14) & 0xFFF; }
            set { data = (data & ~(0xFFFu << 14)) | (value & 0xFFF) << 14; }
        }
        //public uint checksum : 6 (64)
        public uint dataChecksum
        {
            get { return (data >> 26) & 0x3F; }
            set { data = (data & ~(0x3Fu << 26)) | (value & 0x3F) << 26; }
        }

        //public uint lvlDuration: 22(4194304)
        public uint lvlDuration
        {
            get { return (uint)(data2 & 0x3FFFFF); }
            set { data2 = (data2 & ~(0x3FFFFFu)) | (value & 0x3FFFFF); }
        }
        public uint data2Checksum1 //:4(16)
        {
            get { return (uint)((data2 >> 22) & 0xF); }
            set { data2 = (data2 & ~(0xFu << 22)) | (value & 0xF) << 22; }
        }
        public uint data2Checksum2 //:6(64)
        {
            get { return (uint)((data2 >> 26) & 0x3F); }
            set { data2 = (data2 & ~(0x3Fu << 26)) | (value & 0x3F) << 26; }
        }

    }
    class playerData
    {
        internal uint data;
        internal uint data2;
        internal UInt16 data3;
        internal uint data4;//gameDuration + checksum

        //public uint level : 8; (0-256)
        public uint level
        {
            get { return (data & 0xFF); }
            set { data = (data & ~0xFFu) | (value & 0xFF); }//u at end of hex means unsigned
        }

        //public uint  exp : 16; (0-65536)
        public uint exp
        {
            get { return ((data >> 8) & 0xFFFF); }
            set { data = (data & ~(0xFFFFu << 8)) | (value & 0xFFFF) << 8; }
        }//25

        //public uint lives : 6 (64)
        public uint lives
        {
            get { return ((data >> 24) & 0x3F); }
            set { data = (data & ~(0x3Fu << 24)) | (value & 0x3F) << 24; }
        }
        public uint zeroCheck
        {
            get { return ((data >> 30) & 0x1); }
        }
        //public uint maxLives : 6 (64)
        public uint maxLives
        {
            get { return (data2 & 0x3F); }
            set { data2 = (data2 & ~(0x3Fu)) | (value & 0x3F); }
        }
        //public uint tp : 6 (64)
        public uint talentPts
        {
            get { return ((data2 >> 6) & 0x3F); }
            set { data2 = (data2 & ~(0x3Fu << 6)) | (value & 0x3F) << 6; }
        }
        //public uint iceBoltLVL : 4 (16)
        public uint iceBoltLVL
        {
            get { return (uint)((data2 >> 12) & 0xF); }
            set { data2 = (data2 & ~(0xFu << 12)) | (value & 0xF) << 12; }
        }
        //public uint speedBoostLVL : 4 (16)
        public uint speedBoostLVL
        {
            get { return (uint)((data2 >> 16) & 0xF); }
            set { data2 = (data2 & ~(0xFu << 16)) | (value & 0xF) << 16; }
        }//52        
        //public uint invHasBomb : 1 (1)
        public uint invHasBomb
        {
            get { return (uint)((data2 >> 20) & 0x1); }
            set { data2 = (data2 & ~(0x1u << 20)) | (value & 0x1) << 20; }
        }//53        
        //public uint invHasTimeSlow : 1 (1)
        public uint invHasTimeSlow
        {
            get { return (uint)((data2 >> 21) & 0x1); }
            set { data2 = (data2 & ~(0x1u << 21)) | (value & 0x1) << 21; }
        }//54
        //public uint speed :  9(512)
        public uint movementSpeed
        {
            get { return (uint)((data2 >> 22) & 0x1FF); }
            set { data2 = (data2 & ~(0x1FFu << 22)) | (value & 0x1FF) << 22; }
        }

        //public uint difficultLevel: 3(8)
        public uint difficultLevel
        {
            get { return (uint)(data3 & 0x7); }
            set { data3 = (UInt16)((data3 & ~(0x7u)) | (value & 0x7)); }
        }
        //public uint maps: 7(128)
        public uint mapsCount
        {
            get { return (uint)((data3 >> 3) & 0x7F); }
            set { data3 = (UInt16)((data3 & ~(0x7Fu << 3)) | (value & 0x7F) << 3); }
        }
        //public uint data3Checksum: 6(64)
        public uint data123Checksum
        {
            get { return (uint)((data3 >> 10) & 0x3F); }
            set { data3 = (UInt16)((data3 & ~(0x3Fu << 10)) | (value & 0x3F) << 10); }
        }
        //public uint gameDuration: 26(67108864)
        public uint gameDuration
        {
            get { return (uint)(data4 & 0x3FFFFFF); }
            set { data4 = (data4 & ~(0x3FFFFFFu)) | (value & 0x3FFFFFF); }
        }
        public uint data4Checksum //:6(64)
        {
            get { return (uint)((data4 >> 26) & 0x3F); }
            set { data4 = (data4 & ~(0x3Fu << 26)) | (value & 0x3F) << 26; }
        }
        
        
    }
    class Savegame
    {
        public List<mapSave> maps { get; private set; }
        public playerData player { get; private set; }

        public Savegame()
        {
            maps = new List<mapSave>();
            player = new playerData();
        }
        public void Update()
        {
            updatePlayerData();
            addMapData();
        }
        /// <summary>
        /// initing GameManager using current Savegame data
        /// (Just loads game from save)
        /// </summary>
        public void Load()
        {
            EngineApp.Game.self.loadGame(this);
        }
        private void addMapData()
        {
          
           mapSave map = new mapSave();
           GameManager gm = EngineApp.Game.self.gameManager;
           map.level = (uint)gm.level;
           map.lives = (uint)gm.PC.lives;
           map.lvlScore = gm.statistics.lvlPoints;
           map.dataChecksum = (map.level * 3 + map.lvlScore) % 64;
           //data2
           map.lvlDuration = (uint)gm.levelDuration.currentTime;
           map.data2Checksum1 = map.lvlDuration%15;
           map.data2Checksum2 = (uint)(gm.Map.mapWidth % 11 + gm.Map.cookiesCount % 22 + gm.Map.wayNetwork.Count % 20 + gm.sortedEnemiesList.Count % 11);
           //BUGFIX: if level == first
           //recreate list of maps
           if (map.level == 1)
               maps = new List<mapSave>();
           maps.Add(map);
        }

        private void updatePlayerData()
        {
            Player pc = EngineApp.Game.self.gameManager.PC;
            player.level = (uint)pc.level;
            player.exp = (uint)pc.exp;
            player.lives = (uint)pc.lives;
            player.maxLives = (uint)pc.maxLives;
            player.talentPts = (uint)pc.talentPoints;

            if (pc.hasSkill(Skill.skillNames.IceBolt) == null)
                player.iceBoltLVL = 0;
            else
                player.iceBoltLVL = (uint)pc.hasSkill(Skill.skillNames.IceBolt).level;

            if (pc.hasSkill(Skill.skillNames.Boost) == null)
                player.speedBoostLVL = 0;
            else
                player.speedBoostLVL = (uint)pc.hasSkill(Skill.skillNames.Boost).level;

            if ((pc.powerUpsInventory & POWER_UP.BOMB) == POWER_UP.BOMB)
                player.invHasBomb = 1;
            else
                player.invHasBomb = 0;

            if ((pc.powerUpsInventory & POWER_UP.ENEMY_SLOWER) == POWER_UP.ENEMY_SLOWER)
                player.invHasTimeSlow = 1;
            else
                player.invHasTimeSlow = 0;
            player.movementSpeed = (uint)pc.baseSpeed;

            //data3:
            player.difficultLevel = (uint)Profile.currentProfile.config.gameplay.level;
            player.mapsCount = (uint)Profile.currentProfile.config.gameplay.maps;

            player.data123Checksum = player.exp % 37 + player.lives % 4 + player.movementSpeed % 12 + player.talentPts % 4 + player.speedBoostLVL % 3 + player.iceBoltLVL % 3 + player.invHasBomb;

            //data4:
            player.gameDuration = (uint)EngineApp.Game.self.gameManager.gameDuration.currentTime;
            //checksum: remainder of gameDuration/59
            player.data4Checksum = player.gameDuration % 59;

        }
        public string encrypt()
        {
            string buffer = "";
            const string sep = "x";
            //player:
            buffer += player.data.ToString("X") + sep;
            buffer += player.data2.ToString("X") + sep;
            buffer += player.data3.ToString("X") + sep;
            buffer += player.data4.ToString("X") + sep;
            //map(s):
            for (int i = 0; i < maps.Count; i++)
            {
                buffer += "#" + maps[i].data.ToString("X") + sep;
                buffer += maps[i].data2.ToString("X");
            }
            return buffer;
        }

        internal void decrypt(string buffer)
        {
            string hlp = buffer.Substring(0, buffer.IndexOf("x"));
            uint x = Convert.ToUInt32(hlp, 16);
            player = new playerData();
            player.data = x;

            buffer = buffer.Substring(buffer.IndexOf("x") + 1);
            hlp = buffer.Substring(0, buffer.IndexOf("x"));
            x = Convert.ToUInt32(hlp, 16);
            player.data2 = x;
            
            buffer = buffer.Substring(buffer.IndexOf("x")+1);
            hlp = buffer.Substring(0, buffer.IndexOf("x"));
            player.data3 = Convert.ToUInt16(hlp, 16);

            buffer = buffer.Substring(buffer.IndexOf("x") + 1);
            hlp = buffer.Substring(0, buffer.IndexOf("x"));
            player.data4 = Convert.ToUInt32(hlp, 16);

            //check for playerData checksums
            uint checksum;
            checksum = player.exp % 37 + player.lives % 4 + player.movementSpeed % 12 + player.talentPts % 4 + player.speedBoostLVL % 3 + player.iceBoltLVL % 3 + player.invHasBomb;
            if (checksum != player.data123Checksum)
                throw new Exception("Save data checksum corrupted(gx123)!");
            if (player.zeroCheck != 0)
                throw new Exception("Save data checksum corrupted(gx0)!");
            checksum = player.gameDuration % 59; 
            if (checksum != player.data4Checksum)
                throw new Exception("Save data checksum corrupted(gx4)!");

            //map(s):
            if (maps == null) maps = new List<mapSave>();
            int last = buffer.IndexOf("#");
            while (last > 0)
            {
                buffer = buffer.Substring(buffer.IndexOf("#") + 1);
                hlp = buffer.Substring(0, buffer.IndexOf("x"));
                mapSave m = new mapSave();
                m.data = Convert.ToUInt32(hlp, 16);
                buffer = buffer.Substring(buffer.IndexOf("x") + 1);
                last = buffer.IndexOf("#");
                if (last > 0)
                    hlp = buffer.Substring(0, last);
                else
                    hlp = buffer;
                if (hlp.Length > 0)
                    m.data2 = Convert.ToUInt32(hlp, 16);
                //check checksums:
                checksum = (m.level * 3 + m.lvlScore) % 64;
                if (checksum != m.dataChecksum)
                    throw new Exception("Save data checksum corrupted(mx"+maps.Count+"x0)!");
                checksum = m.lvlDuration % 15;
                if (checksum != m.data2Checksum1)
                    throw new Exception("Save data checksum corrupted(mx" + maps.Count + "x2x1)!");
                //TODO:Last chcecksum get values from array
                //checksum = (uint)(gm.Map.gridWidth % 11 + gm.Map.cookiesCount % 22 + gm.Map.wayNetwork.Count % 20 + gm.sortedEnemiesList.Count % 11);
                //if (checksum != m.data2Checksum1)
                //    new Exception("Save data checksum corrupted!");

                maps.Add(m);

            }
            //TODO: Maps data
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using EngineApp;

namespace CookieMonster.CookieMonster_Objects
{
    class Sound
    {
        public enum eSndType { UNKNOWN, SFX, MUSIC }
        public eSndType sndType { get; private set; }
        private static SoundManager gameSndMgr;
        private string filename; public string name { get { return filename; } }
        private int _stream; public int stream { get { return _stream; } }
        private bool looping;
        public enum eSoundState { PLAY, PAUSE, STOP }
        public eSoundState state { get; private set; }
        private double baseVolume;//volume = baseVolume * sfx/MusicVolume
        public double volume
        {
            get
            {
                float vol = 0.0f;
                DLL.Bass.BASS_ChannelGetAttribute(stream, DLL.Bass.BASS_ATTRIB_VOL, ref vol);
                return (double)vol;
            }
            set
            {
                baseVolume = value;
                double vol = baseVolume;
                if (sndType == eSndType.MUSIC)
                    vol *= Profile.currentProfile.config.options.sound.musicVol;
                if (sndType == eSndType.SFX)
                    vol *= Profile.currentProfile.config.options.sound.sfxVol;
                DLL.Bass.BASS_ChannelSetAttribute(stream, DLL.Bass.BASS_ATTRIB_VOL, (float)vol); 
            }
        }
        public Sound(eSndType type, string f, bool loop, bool autoplay)
        {
            sndType = type;
            unsafe
            {
                int error;
                filename = f;
                StringBuilder str = new StringBuilder(f);

                char[] fileChar = filename.ToCharArray();
                looping = loop;
                byte[] bytes = Encoding.ASCII.GetBytes(fileChar, 0, filename.Length - 1);
                IntPtr fPtr = Marshal.AllocHGlobal(bytes.Length);
                void* vfPtr = (void*)fPtr;
                Marshal.Copy(bytes, 0, fPtr, bytes.Length);
                if (looping)
                {
                    _stream = DLL.Bass.BASS_StreamCreateFile(false, filename, 0, 0, DLL.Bass.BASS_UNICODE | DLL.Bass.BASS_SAMPLE_LOOP);
                    gameSndMgr.addLoopingSound(this);
                }
                else
                {
                    _stream = DLL.Bass.BASS_StreamCreateFile(false, filename, 0, 0, DLL.Bass.BASS_UNICODE | DLL.Bass.BASS_STREAM_AUTOFREE);
                    gameSndMgr.addSound(this);
                }
                error = DLL.Bass.BASS_ErrorGetCode();
                if (autoplay)
                {
                    Play();
                }                
                error *= 10;
                volume = 1.0;//BUGFIX: when sound should be muted by global config it always need to be set through constructor
            }
        }
        public Sound(eSndType type, string f, bool loop, bool autoplay, double vol)
            : this(type,f, loop, autoplay)
        {   
            volume = vol;
        }
        public bool Play()
        {
            return DLL.Bass.BASS_ChannelPlay(stream, looping);
        }
        public void Stop()
        {
            state = eSoundState.STOP;
            DLL.Bass.BASS_ChannelStop(stream);
        }

        public static void setSndMgr(SoundManager sndMgr)
        {
            gameSndMgr = sndMgr;
        }
        public void Free()
        {
            if(state != eSoundState.STOP)
                Stop();
            gameSndMgr.removeFromSndList(this);
            DLL.Bass.BASS_StreamFree(stream);
            //Remove from soundManager List:

        }
        public void recalculateVolume()
        {
            volume = baseVolume;//set accesor will do all of the job
        }
        public void fadeIn(float dstVol, int msecTime)
        {
            this.volume = dstVol;//push it through global volume of music/sfx
            dstVol = (float)this.volume;
            DLL.Bass.BASS_ChannelSetAttribute(stream, DLL.Bass.BASS_ATTRIB_VOL, 0f);
            DLL.Bass.BASS_ChannelSlideAttribute(stream, DLL.Bass.BASS_ATTRIB_VOL, dstVol, msecTime);
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using EngineApp;
using CookieMonster.DLL;

namespace CookieMonster.CookieMonster_Objects
{
    class SoundManager
    {
        List<Sound> Music = new List<Sound>();
        List<Sound> loopingMusic = new List<Sound>();
        List<Sound> SFX = new List<Sound>();
        List<Sound> loopingSFX = new List<Sound>();
        private bool initReturn;
        public SoundManager()
        {
            initReturn = DLL.Bass.BASS_Init(-1, 44100, 0, 0, (object)null);
            checkBassInitialization();
        }
        public void checkBassInitialization()
        {
            if (initReturn == false)
            {
                Game.self.menuManager.showAlert("Nieudana inicjalizacja Bass.dll\n ...ponowna inicjalizacja");
                DLL.Bass.BASS_Free();
                initReturn = DLL.Bass.BASS_Init(-1, 44100, 0, 0, (object)null);
                //avoid stack overflow 2 tries should be enough
                //checkBassInitialization();
            }

        }
        public void addLoopingSound(Sound s)
        {
            if (s.sndType == Sound.eSndType.MUSIC)
                loopingMusic.Add(s);
            else if (s.sndType == Sound.eSndType.SFX)
                loopingSFX.Add(s);
        }
        public void addSound(Sound s)
        {
            if (s.sndType == Sound.eSndType.MUSIC)
                Music.Add(s);
            else if (s.sndType == Sound.eSndType.SFX)
                SFX.Add(s);
        }
        public Sound getSoundByFilename(string fname)
        {
            for (int i = 0; i < SFX.Count; i++)
                if (SFX[i].name == fname) return SFX[i];
            for (int i = 0; i < loopingMusic.Count; i++)
                if (loopingMusic[i].name == fname) return loopingMusic[i];
            for (int i = 0; i < loopingSFX.Count; i++)
                if (loopingSFX[i].name == fname) return loopingSFX[i];
            for (int i = 0; i < Music.Count; i++)
                if (Music[i].name == fname) return Music[i];
            return null;
        }
        /// <ummary>
        /// Checks for Sounds that finished playing
        /// </summary>
        public void Update()
        {
            for (int i = 0; i < SFX.Count; i++)
                if (SFX[i].state != Sound.eSoundState.STOP)
                    if (Bass.BASS_ChannelIsActive(SFX[i].stream) == Bass.BASS_ACTIVE_STOPPED)
                    {
                        SFX[i].Free();//free resources when sound stops playing
                    }

            for (          int i = 0; i < Music.Count; i++)
                if (Music[i].state != Sound.eSoundState.STOP)
                    if (Bass.BASS_ChannelIsActive(Music[i].stream) == Bass.BASS_ACTIVE_STOPPED)
                    {
                        Music[i].Stop();//free resources when sound stops playing
                    }  
        }
        public bool removeFromSndList(Sound s)
        {
            if (s.sndType == Sound.eSndType.MUSIC)
            {
                for(int i=0;i<Music.Count;i++)
                    if(Music[i].Equals(s))
                    {
                        Music.RemoveAt(i);
                        return true;
                    }
                for(int i=0;i<loopingMusic.Count;i++)
                    if(loopingMusic[i].Equals(s))
                    {
                        loopingMusic.RemoveAt(i);
                        return true;
                    }
            }
            else if(s.sndType == Sound.eSndType.SFX)
            {

                for (int i = 0; i < SFX.Count; i++)
                    if (SFX[i].Equals(s))
                    {
                        SFX.RemoveAt(i);
                        return true;
                    }
                for (int i = 0; i < loopingSFX.Count; i++)
                    if (loopingSFX[i].Equals(s))
                    {
                        loopingSFX.RemoveAt(i);
                        return true;
                    }
            }
            return false;//sound wasn't found
        }
        public void recalculateSFX()
        {
            for (int i = 0; i < SFX.Count; i++)
                SFX[i].recalculateVolume();
            for (int i = 0; i < loopingSFX.Count; i++)
                loopingSFX[i].recalculateVolume();
        }
        public void recalculateMusic()
        {
            for (int i = 0; i < loopingMusic.Count; i++)
                loopingMusic[i].recalculateVolume();
            for (int i = 0; i < Music.Count; i++)
                Music[i].recalculateVolume();
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using QuickFont;
using OpenTK;
using OpenTK.Graphics.OpenGL;
using EngineApp;
using System.Drawing;
namespace CookieMonster.CookieMonster_Objects
{
    class Text
    {
        public QFont fontFace { get; private set; }
        ProcessedText txt;
        public float x { get; private set; }
        public float y { get; private set; }
        public float orgX { get; private set; }
        public float orgY { get; private set; }
        private String _msg; 
        public String msg 
        {   get { return _msg; }
            set
            {
                _msg = value;
            }
        }
        Timer timeActive;
        Point perPreRenderMove;
        public bool active {get{ if(timeActive!=null) return timeActive.enabled; return true;}}
        public Text(QFont qf,ProcessedText pTxt,float _x,float _y,string m)
        {
            fontFace = qf; txt = pTxt;
            x  = orgX = _x; y = orgY = _y;
            _msg = m;
        }
        public void changeFont(QFont newFnt)
        {
            fontFace = newFnt;
        }
        public void changeText(string newText)
        {
            _msg = newText;
        }
        public void Print()
        {
            if (active)
            {
                if (perPreRenderMove != null)
                    Move(perPreRenderMove.X, perPreRenderMove.Y);     
                fontFace.Print(_msg, new Vector2(x, y));
            }
        }
        public void Move(int _x, int _y)
        {
            x += (float)_x; y += (float)_y;
        }
        /// <summary>
        /// Set new position absolute
        /// </summary>
        public void MoveAbs(int _x, int _y)
        {
            x = (float)_x; y = (float)_y;
        }
        public void setLifeTime(float ms)
        {
            timeActive = new Timer(Timer.eUnits.MSEC, (int)ms);
            timeActive.start();
        }
        public void setAnimationMove(Point p)
        {
            perPreRenderMove = p;
        }
    }
    class QFontConstructorData
    {
        public float size { get; private set; }
        public FontStyle style { get; private set; }
        public bool dropShadow { get; private set; }
        public OpenTK.Graphics.Color4 color { get; set; }
        public QFont font { get; private set; }

        public QFontConstructorData(float siz, FontStyle styl, bool shadow, OpenTK.Graphics.Color4 col, QFont fnt)
        {
            size = siz;
            style = styl;
            dropShadow = shadow;
            color = col;
            font = fnt;
        }
        public override string ToString()
        {
            return size.ToString() + "pt. " + style.ToString() + " " + color.ToString() + " shadow: " + dropShadow.ToString();
        }
    }
    class TextManager
    {
        const int screenMargin = 32;//in px;
        static public QFont font_default;
        static public QFont font_default_20;
        List<Text> onScreenTexts = new List<Text>();

        //default font builders:
        static QFontBuilderConfiguration defaultBuilder = new QFontBuilderConfiguration();
        static QFontBuilderConfiguration defaultBuilderDropShadow = new QFontBuilderConfiguration(true);
        static string fontDir = "../Data/Fonts/";
        static int fontsUsed = 0; //number of already loaded, different fonts through newQFont
        static List<string> fontFileNames = new List<string>();
        static List<List<QFontConstructorData>> definiedFonts = new List<List<QFontConstructorData>>();
        public TextManager()
        {
            font_default = newQFont("Tepeno Sans Regular.ttf", 14,true);
            font_default_20 = newQFont("Tepeno Sans Regular.ttf", 20,true);        

            defaultBuilder.charSet = "aabccdeefghijkllmnnopqrsstuvwxyzzzAABCCDEEFGHIJKLLMNNOPQRSSTUVWXYZZZ1234567890.:,;'\"(!?)+-*/=_{}[]@~#\\<>|^%$&";
            defaultBuilderDropShadow.charSet = "aabccdeefghijkllmnnopqrsstuvwxyzzzAABCCDEEFGHIJKLLMNNOPQRSSTUVWXYZZZ1234567890.:,;'\"(!?)+-*/=_{}[]@~#\\<>|^%$&";
        }
        public static int inspectFontFamily(string fileName)
        {
            for (int i = 0; i < fontFileNames.Count; i++)
                if (fontFileNames[i] == fileName)
                    return i;
            return -1;//no font famili founded
        }
        /// <summary>
        /// Inspect font, check if it was already created by textManager
        /// if it was found with same size etc. then returns it, elsewhere returns null
        /// </summary>
        /// <param name="filename"></param>
        /// <returns></returns>
        public static QFont inspectFont(int fntIdx, float size, FontStyle style, bool dropShadow, OpenTK.Graphics.Color4 color)
        {
              for(int j=0;j<definiedFonts[fntIdx].Count;j++)
              {
                  QFontConstructorData f = definiedFonts[fntIdx][j];
                  if (f.size == size && f.style == style
                     && f.dropShadow == dropShadow && f.color == color)
                  {//font matches!
                      return f.font;
                  }
              }            
            return null;
        }
        private static QFont internalNewQFont(string filename, float size, FontStyle style, bool dropShadow, OpenTK.Graphics.Color4 color)
        {//white is default QFont Color
            int idx = inspectFontFamily(filename);
            if (idx == -1)
            {
                fontFileNames.Add(filename);
                definiedFonts.Add(new List<QFontConstructorData>());
                fontsUsed++;
                idx = fontFileNames.Count - 1;
            }
            QFont f = inspectFont(idx, size, style, dropShadow,color);
            if (f == null) //no font founded:
            {
                if(dropShadow)
                    f = new QFont(fontDir+filename, size, style,defaultBuilderDropShadow);
                else
                    f = new QFont(fontDir+filename, size, style,defaultBuilder);
                f.Options.Colour = color;
                //add fontConstructor data
                definiedFonts[idx].Add(new QFontConstructorData(size,style,dropShadow,color,f));
                //Debug stuff:
                //new DebugMsg("New font #"+definiedFonts[idx].Count + " " + filename + " " + size.ToString()+"pt.");
            }
            return f;

        }
        public static QFont newQFont(string fileName,float size)
        {
            return internalNewQFont(fileName, size, FontStyle.Regular, false, new OpenTK.Graphics.Color4(255, 255, 255, 255));
        }
        public static QFont newQFont(string fileName, float size, bool dropShadow)
        {
            return internalNewQFont(fileName, size, FontStyle.Regular, dropShadow, new OpenTK.Graphics.Color4(255, 255, 255, 255));
        }
        public static QFont newQFont(string fileName, float size, FontStyle style, bool dropShadow)
        {
            return internalNewQFont(fileName, size, style, dropShadow, new OpenTK.Graphics.Color4(255, 255, 255, 255));
        }
        public static QFont newQFont(string fileName, float size, FontStyle style, bool dropShadow, OpenTK.Graphics.Color4 color)
        {
            return internalNewQFont(fileName, size, style, dropShadow, color);
        }
        public static QFont newQFont(string fileName, float size, bool dropShadow, OpenTK.Graphics.Color4 color)
        {
            return internalNewQFont(fileName, size, FontStyle.Regular, dropShadow, color);
        }


        public void addText(QFont qf,string txt,float x,float y)
        {
            addText(qf, txt, x, y, QFontAlignment.Left);
        }
        public void addText(QFont qf, string txt, float x, float y,QFontAlignment align)
        {
            float actWidth = qf.Measure(txt).Width;
            float width = (float)Game.self.activeViewport.width;

            width -= screenMargin;
            ProcessedText pTxt;
            if (align != QFontAlignment.Right)
            {
                pTxt = qf.ProcessText(txt, width, align);
                onScreenTexts.Add(new Text(qf, pTxt, x, y, txt));
            }
            else
            {
                pTxt = qf.ProcessText(txt, actWidth, QFontAlignment.Left);
                onScreenTexts.Add(new Text(qf, pTxt, x - actWidth, y, txt));
            }
            
        }
        public void addText(Text txt)
        {
            onScreenTexts.Add(txt);
        }

        #region Produce Text
        /// <summary>
        /// Produces text, without adding it to render list
        /// </summary>
        /// <param name="qf"></param>
        /// <param name="txt"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns>Text object -> which you can simply render usign method "Print"</returns>
        public Text produceText(QFont qf, string txt, float x, float y)
        {
            return produceText(qf, txt, x, y, QFontAlignment.Left);
        }

        /// <summary>
        /// Produces text, without adding it to render list
        /// </summary>
        /// <param name="qf"></param>
        /// <param name="txt"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="align"></param>
        /// <returns>Text object -> which you can simply render usign method "Print"</returns>
        public Text produceText(QFont qf, string txt, float x, float y, QFontAlignment align)
        {
            float width = (float)Game.self.activeViewportOrAny.width;

            width -=  screenMargin;
            ProcessedText pTxt;
            if (align != QFontAlignment.Right)
            {
                pTxt = qf.ProcessText(txt, width, align);
                return new Text(qf, pTxt, x, y, txt);
            }
            else
            {
                float actWidth = qf.Measure(txt).Width;
                pTxt = qf.ProcessText(txt, actWidth, align);
                return new Text(qf, pTxt, x - actWidth, y, txt);
            }
        }
        #endregion
        public void onRender()
        {
            QFont.Begin();
            for (int i = 0; i < onScreenTexts.Count; i++)
            {
                if (onScreenTexts[i].active == false)
                    onScreenTexts.RemoveAt(i);
                else
                    onScreenTexts[i].Print();
            }
            QFont.End();
        }
        /// <summary>
        /// search for first Text with equal string with one in arguments
        /// then simply dropping it from the list
        /// </summary>
        /// <param name="txt"></param>
        public void removeText(string txt)
        {
            for (int i = 0; i < onScreenTexts.Count; i++)
                if (onScreenTexts[i].msg == txt)
                    onScreenTexts.RemoveAt(i);
        }
        public void removeText(Text txt)
        {
            for (int i = 0; i < onScreenTexts.Count; i++)
                if (onScreenTexts[i] == txt)
                    onScreenTexts.RemoveAt(i);
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using EngineApp;
namespace CookieMonster.CookieMonster_Objects
{
    class Timer : IDisposable
    {
        static Timers_Manager timeMgr;
        /// <summary>
        /// Zero Timer is special timer that will always return current time as 0
        /// this is very handy and needed sometimes 
        /// (fe. your actually Timer just been disabled
        /// but you're setting some values based on that timmer current_time/total_time) then you can use zeroTimer
        /// </summary>
        static public Timer zeroTimer = new Timer(eUnits.MSEC, 1);
        public enum eUnits { MSEC, FPS }
        private eUnits type;
        private Int64 initTime, initTimeVar;
        private Int64 time; // in units of #type# when time hits 0 Timer will be destructed
                            // if its decreasing timer.
        public Int64 currentTime { get { if (this == zeroTimer) return 0; else return time; } set { time = value; } }
        public Int64 totalTime   { get { return initTime; } }
        /// <summary>
        /// Part of timer that is done (for multipiling and stuff) 
        /// </summary>
        /// <returns>part done in range 0.0-1.0</returns>
        public float partDone { get { return (float)currentTime / totalTime; } }
        private int iterator;

        private bool recreateOnDestroy;
        private bool autostartOnRecreate;
        private bool _enabled;
        public bool isIngameTimer{get; private set;}//if flag is set to true, stop counting when game is pause
        public bool enabled{
            get { return _enabled;}
        }

        #region Timer_Constructors
        /// <summary>
        /// Construct Timer
        /// </summary>
        /// <param name="t"></param>
        /// <param name="timeAvg"></param>
        public Timer(eUnits t, int timeAvg)
        {
            initTime = (Int64)timeAvg;
            type = t; time = initTime;
            setIterator();
        }
        /// <summary>
        /// Construct Timer
        /// </summary>
        /// <param name="t"></param>
        /// <param name="timeAvg"></param>
        public Timer(eUnits t, Int64 timeAvg)
        {
            initTime = timeAvg;
            type = t; time = initTime;
            setIterator();
        }
        /// <summary>
        /// Construct timer with random variable value by
        /// formula time = timeAvg +/- timeVar
        /// </summary>
        /// <param name="t"></param>
        /// <param name="timeAvg"></param>
        /// <param name="timeVar"></param>
        public Timer(eUnits t, int timeAvg, int timeVar) : this(t,timeAvg)
        {
            initTimeVar = (Int64)timeVar;

            int rnd = new Random().Next(timeVar * 2) - timeVar;
            time = timeAvg + rnd;
        }
        /// <summary>
        /// Construct timer with variable time and option recreation of same timer at destruction
        /// </summary>
        /// <param name="t"></param>
        /// <param name="timeAvg"></param>
        /// <param name="timeVar"></param>
        /// <param name="recreate">Recreate timer at destruction?</param>
        /// <param name="recAutostart">Auto start timer created on destruction?</param>
        
        public Timer(eUnits t, int timeAvg, int timeVar,bool recreate,bool recAutostart) : this(t,timeAvg,timeVar)
        {
            recreateOnDestroy = recreate;
            autostartOnRecreate = recAutostart;
        }
        /// <summary>
        /// Construct timer with random variable value by
        /// formula time = timeAvg +/- timeVar
        /// </summary>
        /// <param name="t"></param>
        /// <param name="timeAvg"></param>
        /// <param name="timeVar"></param>
        public Timer(eUnits t, Int64 timeAvg, Int64 timeVar) : this(t,timeAvg)
        {
            initTimeVar = timeVar;

            Int64 rnd = new Random().Next((int)timeVar * 2) - timeVar;
            time = timeAvg + rnd;
            setIterator();
        }
        #endregion

        /// <summary>
        /// function will check if timer is ingame timer
        /// (if that's true timer need to be stoped when game is paused)
        /// 
        /// </summary>
        private void isGameTimerOrNot()
        {
            if (Game.self.gameManager == null || !((Game.self.gameState & Game.game_state.Game) == Game.game_state.Game) || Game.self.gameManager.gamePaused)
                isIngameTimer = false;
            else
                isIngameTimer = true;
        }
        /// <summary>
        /// Launch the timmer (adding it to timers list in game class)
        /// </summary>
        public void start()
        {
            isGameTimerOrNot();
            if (_enabled == false)
            {
                _enabled = true;
                if (type == eUnits.FPS)
                    timeMgr.addFpsTimer(this);
                else if (type == eUnits.MSEC)
                    timeMgr.addMsecTimer(this);
            }
        }
        /// <summary>
        /// Reset elapsed time and launch the timmer (adding it to timers list in game class)
        /// </summary>
        public void restart()
        {
            this.time = initTime;
            start();
           
        }
        /// <summary>
        /// Stop the timer (releasing it from timers list in game class)
        /// if object was found on List, function returns true;
        /// </summary>
        /// <returns></returns>
        public bool stop()
        {
            _enabled = false;
            if (type == eUnits.FPS)
                return timeMgr.removeFpsTimer(this);
            else if (type == eUnits.MSEC)
                return timeMgr.removeMsecTimer(this);
            return false;
        }
        public void Update(long time_passed)
        {
            time += iterator * time_passed;
            
            if (time <= 0)
            {
                if (recreateOnDestroy)
                {
                    long rnd = new Random().Next((int)initTimeVar * 2) - initTimeVar;
                    time = initTime + rnd;
                    if (!autostartOnRecreate)
                    {
                        this.stop();
                    }
                }
                else // remove timer:
                {
                    this.stop();
                    Dispose();
                    GC.SuppressFinalize(this);
                };
            };

        }
        public static void setTimerManager(Timers_Manager tm)
        {
            if(timeMgr == null)//on instance only!
              timeMgr = tm;
        }
        public void Dispose()
        {
            if (type == eUnits.MSEC)
                timeMgr.removeMsecTimer(this);
            else if (type == eUnits.FPS)
                timeMgr.removeMsecTimer(this);
        }
        #region bool_operators
        public static bool operator ==(Timer x, long y)
        {
            return (x.time == y);
        }
        public static bool operator <=(Timer x, long y)
        {
            return (x.time <= y);
        }
        public static bool operator >=(Timer x, long y)
        {
            return (x.time >= y);
        }
        public static bool operator !=(Timer x, long y)
        {
            return (x.time != y);
        }
        public static bool operator <(Timer x, long y)
        {
            return (x.time < y);
        }
        public static bool operator >(Timer x, long y)
        {
            return (x.time > y);
        }
        public static bool operator ==(Timer x, Timer y)
        {
            if (((object)x == null) || ((object)y == null)) return ((object)x == (object)y);
            return (x.time == y.time);
        }
        public static bool operator !=(Timer x, Timer y)
        {
            if (((object)x == null) || ((object)y == null)) return ((object)x != (object)y);

            return (x.time != y.time);
        }
        public static bool operator <=(Timer x, Timer y)
        {
            return (x.time <= y.time);
        }
        public static bool operator >=(Timer x, Timer y)
        {
            return (x.time >= y.time);
        }
        public static bool operator <(Timer x, Timer y)
        {
            return (x.time < y.time);
        }
        public static bool operator >(Timer x, Timer y)
        {
            return (x.time > y.time);
        }
#endregion
        private void setIterator()
        {
            if (time >= 0) iterator = -1;
            else iterator = 1;
        }
        public override string ToString()
        {
            return currentTime.ToString() + " / " + totalTime.ToString() + " (" + ((type == eUnits.FPS) ? "fps)" : "msec)");
        } 
    }
    class Timers_Manager
    {
        private System.Diagnostics.Stopwatch msecMeasure = new System.Diagnostics.Stopwatch();
        private List<Timer> fpsTimers = new List<Timer>();
        private List<Timer> msecTimers = new List<Timer>();

        public Timers_Manager()
        {
            Timer.setTimerManager(this);
        }
        public void addFpsTimer(Timer t)
        {
            fpsTimers.Add(t);
        }
        public void addMsecTimer(Timer t)
        {
            msecTimers.Add(t);
        }
        public bool removeFpsTimer(Timer t)
        {
            return fpsTimers.Remove(t);
        }
        public bool removeMsecTimer(Timer t)
        {
            return msecTimers.Remove(t);
        }
        /// <summary>
        /// Update all timers on list, called by Game.OnUpdateFrame()
        /// </summary>
        public void Update()
        {
            msecMeasure.Stop();
            long msec_elapsed = msecMeasure.ElapsedMilliseconds;

            // update lists:
            for (int i = 0; i < msecTimers.Count; i++)
            {
                if (!msecTimers[i].isIngameTimer || (Game.self.gameManager!=null && !Game.self.gameManager.gamePaused))
                    msecTimers[i].Update(msec_elapsed);
            }
            for (int i = 0; i < fpsTimers.Count; i++)
            {
                if (!fpsTimers[i].isIngameTimer || (Game.self.gameManager != null && !Game.self.gameManager.gamePaused))
                    fpsTimers[i].Update(1); // 1 fps passed
            }

            msecMeasure.Reset();
            msecMeasure.Start();
        }


    }
}
 using System;
using System.Collections.Generic;

using System.Text;
using OpenTK;
using OpenTK.Graphics;

namespace CookieMonster
{
	static class BinkGL
	{
		static Int32 Get_desktop_color_depth()
		{
			return GraphicsContext.CurrentContext.GraphicsMode.Depth;
		}

		static IGraphicsContext Create_gl_context()
		{
			return GraphicsContext.CurrentContext;
		}
		public class RAD3D
		{
			public IntPtr window;
			public IGraphicsContext context;
			public DisplayDevice rendering_dc;
		} 


		// IntPtr with RAD3D
		static public RAD3D Open_RAD_3D()
		{
			RAD3D rad_3d;

			//
			// try to create a RAD3D structure
			//
			rad_3d = new RAD3D();
			if ( rad_3d == null )
			{
				return null;
			}
			//
			// Get a DC to use.
			//
			rad_3d.rendering_dc = DisplayDevice.Default;
			rad_3d.context = Create_gl_context();
			rad_3d.window = EngineApp.Game.self.windowHandle;

			return( rad_3d );			
		}
		public static void Close_RAD_3D( RAD3D rad_3d )
		{
			// Dont close nothing, all is based on same context that OpenTK uses 
		}
		public static void Start_RAD_3D_frame( RAD3D rad_3d )
		{
			if ( rad_3d != null)
			{// clear background:
				GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
			}
		}
		public static void End_RAD_3D_frame(RAD3D rad_3d)
		{
			if ( rad_3d != null)
			{ // Swap buffers:
				EngineApp.Game.self.SwapBuffers();
			}
		}
		public static void Resize_RAD_3D( RAD3D rad_3d,
		Int32 width,
		Int32 height)
		{
			GL.Viewport(0, 0, width, height);
			GL.MatrixMode(MatrixMode.Modelview);
			GL.LoadIdentity();
		}
		public static UInt32 Round_up_to_next_2_power(UInt32 value)
		{
			if (value > 16)
			if (value > 64)
			if (value > 128)
			if (value > 256)
			if (value > 512)
			return (1024);
			else
			return (512);
			else
			return (256);
			else
			return (128);
			else
			if (value > 32)
			return (64);
			else
			return (32);
			else
			if (value > 4)
			if (value > 8)
			return (16);
			else
			return (8);
			else
			if (value > 2)
			return (4);
			return (value);
		}

		//## Setup the specified GL texture.                                       
		//############################################################################
		static unsafe void Setup_gl_texture(UInt32 texture, //input texture?
		UInt32 pitch,
		UInt32 pixel_size,
		UInt32 texture_width,
		UInt32 texture_height,
		UInt32 gl_surface_type,
        Byte[] buffer)
		{
			// Make the texture current.
			GL.BindTexture(TextureTarget.Texture2D, texture);

			//
			// Set the texture wrap and filtering options.
			GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapS, (int)TextureWrapMode.Repeat);
			GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureWrapT, (int)TextureWrapMode.Repeat);
			GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)TextureMagFilter.Nearest);
			GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)TextureMinFilter.Nearest);
			GL.TexEnv(TextureEnvTarget.TextureEnv, TextureEnvParameter.TextureEnvMode, (int)TextureEnvMode.Modulate);            
			
			
			//
			// Set the pixel format options.
			//
			GL.PixelStore(PixelStoreParameter.PackRowLength, pitch / pixel_size);
			GL.PixelStore(PixelStoreParameter.UnpackAlignment, (pitch % pixel_size) + 1);
			//
			// Upload data into the texture.
			//
            IntPtr buf = new IntPtr((void*)buffer[0]);
			GL.TexImage2D(TextureTarget.Texture2D, 0, (PixelInternalFormat)gl_surface_type,
			(Int32)texture_width, (Int32)texture_height, 0, (PixelFormat)gl_surface_type, PixelType.UnsignedByte,ref buf);
			
		}

		public class RAD3DIMAGE
		{
			public UInt32 total_textures;
			public UInt32 pitch;
			public UInt32 width;
			public UInt32 height;
			public bool alpha_pixels;
			public UInt32 pixel_size;
			public UInt32 textures_across;
			public UInt32 textures_down;
			public UInt32 remnant_width;
			public UInt32 remnant_height;
			public UInt32 remnant_input_width;
			public UInt32 remnant_input_height;
			public UInt32 maximum_texture_size;
			public UInt32 rad_surface_type;
			public UInt32 gl_surface_type;
			public UInt32[] gl_textures;
			public Byte[] pixels;
			public Int32 download_textures;
			public UInt32 row_length;
			public UInt32 texture_count;
		}
		public static  RAD3DIMAGE Open_RAD_3D_image( RAD3D rad_3d,
		UInt32 width,
		UInt32 height,
		bool alpha_pixels,
		UInt32 maximum_texture_size)
		{
			RAD3DIMAGE rad_image;
			UInt32 remnant_width, remnant_height;
			UInt32 buffer_pitch, buffer_height;
			UInt32 pitch, pixel_size;
			UInt32 total_textures;
			UInt32[] textures;
			UInt32 x, y;

			// Calculate the pixel size and the pitch
			pixel_size = (uint)(( alpha_pixels) ? 4 : 3);
			pitch = (uint)(((width * pixel_size ) + 15 ) & ~15);

			// Calculate the remnant size (for the width and the height)
			remnant_width = Round_up_to_next_2_power( width % maximum_texture_size );
			remnant_height = Round_up_to_next_2_power( height % maximum_texture_size );

			// The buffer_pitch is the greater of the remnant size and the input pitch.
			buffer_pitch = remnant_width * pixel_size;
			if ( buffer_pitch < pitch )
			buffer_pitch = pitch;

			// The buffer_height is the greater of the remnant size and the input height.
			buffer_height = ( height > remnant_height) ? height : remnant_height;

			// Calculate the total number of textures we'll need.
			total_textures = ( ( width + ( maximum_texture_size - 1 ) ) / maximum_texture_size ) *
			( ( height + ( maximum_texture_size - 1 ) ) / maximum_texture_size );

			// Allocate enough memory for a RAD image, a list of textures and a buffer.
			rad_image = new RAD3DIMAGE();
			/* malloc( System.Runtime.InteropServices.Marshal.SizeOf( RAD3DIMAGE ) +
			( total_textures * 4 ) +
			31 + ( buffer_pitch * buffer_height) );
			*/
			if ( rad_image == null )
			{
				return( null );
			}


			// The textures come after the structure.
			rad_image.gl_textures = new UInt32[total_textures];

			// And the buffer comes after the textures (aligned to a 32-byte address).
            rad_image.pixels = new Byte[buffer_pitch * buffer_height];

			// Set all the variables in our new structure.
			rad_image.total_textures = total_textures;
			rad_image.pitch = pitch;
			rad_image.width = width;
			rad_image.height = height;
			rad_image.alpha_pixels = alpha_pixels;
			rad_image.pixel_size = pixel_size;
			rad_image.textures_across = width / maximum_texture_size;
			rad_image.textures_down = height / maximum_texture_size;
			rad_image.remnant_width = remnant_width;
			rad_image.remnant_height = remnant_height;
			rad_image.remnant_input_width = width % maximum_texture_size;
			rad_image.remnant_input_height = height % maximum_texture_size;
			rad_image.maximum_texture_size = maximum_texture_size;
			rad_image.rad_surface_type = (uint)(( alpha_pixels) ? 7 : 9);//7 9 is some enum stuff
			rad_image.gl_surface_type = (alpha_pixels) ? (uint)PixelFormat.Rgba : (uint)PixelFormat.Rgb;
			rad_image.download_textures = 0;
			rad_image.row_length = pitch / pixel_size;
			rad_image.texture_count = 0;

			// Clear the buffer.
			//memset( rad_image->pixels,0,buffer_pitch * buffer_height );

			// Call GL to create a bunch of textures (clear the last one as a flag to
			//   see if all of the textures were created).
			rad_image.gl_textures[ rad_image.total_textures - 1 ] = 0;

			GL.GenTextures((int)rad_image.total_textures, rad_image.gl_textures);

			if ( rad_image.gl_textures[ rad_image.total_textures - 1 ] == 0 )
			{
				// GL didn't allocate enough textures for us, so just fail.
				rad_image = null;
				return(null);
			}


			//
			// Loop through and init each texture (setting each of their sizes).
			//

			textures = rad_image.gl_textures;
			int i = 0;
			for (y = 0; y < rad_image.textures_down ; y++ )
			{
				for ( x = 0 ; x < rad_image.textures_across ; x++ )
				{
					//
					// Setup the texture.
					// (every one)
					
					Setup_gl_texture( textures[i++],
					rad_image.pitch,
					rad_image.pixel_size,
					rad_image.maximum_texture_size,
					rad_image.maximum_texture_size,
					rad_image.gl_surface_type,
					rad_image.pixels );
				}

				//
				// Do the rememnant texture at the end of the scanline.
				//

				if ( rad_image.remnant_width > 0 )
				{
					//
					// Setup the texture.
					//

					Setup_gl_texture(textures[i++],
					rad_image.pitch,
					rad_image.pixel_size,
					rad_image.maximum_texture_size,
					rad_image.maximum_texture_size,
					rad_image.gl_surface_type,
					rad_image.pixels);
				}
			}

			//
			// Do the remnants along the bottom edge (if any).
			//

			if ( rad_image.remnant_height > 0 )
			{
				for ( x = 0 ; x < rad_image.textures_across ; x++ )
				{
					//
					// Setup the texture.
					//

					Setup_gl_texture(textures[i++],
					rad_image.pitch,
					rad_image.pixel_size,
					rad_image.maximum_texture_size,
					rad_image.maximum_texture_size,
					rad_image.gl_surface_type,
					rad_image.pixels);
				}
				if ( rad_image.remnant_width > 0 )
				{
					//
					// Setup the texture.
					//
					Setup_gl_texture(textures[i++],
					rad_image.pitch,
					rad_image.pixel_size,
					rad_image.maximum_texture_size,
					rad_image.maximum_texture_size,
					rad_image.gl_surface_type,
					rad_image.pixels);
				}
			}

			return( rad_image );
		}
		
		public static void Close_RAD_3D_image( RAD3DIMAGE rad_image )
		{
			if ( rad_image != null)
			{
				if ( rad_image.gl_textures != null)
				{
					//
					// Ask GL to delete the textures.
					GL.DeleteTextures((int)rad_image.total_textures, rad_image.gl_textures);
					rad_image.gl_textures = null;

					// Free our memory.
					rad_image = null;
				}
			}
		}

		public static bool Lock_RAD_3D_image( RAD3DIMAGE rad_image,
                                                    ref Byte[] pixel_buffer,
		                                            ref UInt32 buffer_pitch,
		                                            ref UInt32 surface_type,
		                                            UInt32 src_x,
		                                            UInt32 src_y,
		                                            UInt32 src_w,
		                                            UInt32 src_h )
		{
			if ( rad_image == null ) return true;
			// Fill the variables that were requested.
			if ( rad_image.texture_count < 1 )
			{

				if ( pixel_buffer != null )
				{
					pixel_buffer = rad_image.pixels;
				}

				if ( buffer_pitch != null)
				{
					buffer_pitch = rad_image.pitch;
				}

                if (surface_type != null)
				{
					surface_type = rad_image.rad_surface_type;
				}

                if (src_x != null)
				{
					src_x = 0;
				}

				if ( src_y != null)
                {
					src_y = 0;
				}

				if ( src_w != null)
				{
				    src_w = rad_image.width;
				}

				if ( src_h != null)
				{
					src_h = rad_image.height;
				}

				rad_image.texture_count = 1;

				return( true );
			}
			else
			{
				rad_image.texture_count = 0;

				return( false );
			}
		}
        public static void Unlock_RAD_3D_image( RAD3DIMAGE rad_image )
		{
		  if ( rad_image == null)
		  {
			return;
		  }

		  //
		  // Set the flag to redownload the texture for the next frame.
		  //

		  rad_image.download_textures = 1;
		}
        public static void Submit_texture( Byte[] pixels,
                                    UInt32 row_length,
                                    Int32 width,
                                    Int32 height,
                                    UInt32 surface_type)
        {
            // Set the pixel format options.
            GL.PixelStore(PixelStoreParameter.UnpackRowLength, row_length);
            GL.PixelStore(PixelStoreParameter.UnpackAlignment, 8);

            
            // Use TexSubImage because it is faster on some hardware.

            GL.TexSubImage2D(TextureTarget.Texture2D, 0, 0, 0, width, height, (PixelFormat)surface_type, PixelType.UnsignedByte, pixels);
        }


        public static void Submit_vertices(float dest_x,
                                     float dest_y,
                                     float scale_x,
                                     float scale_y,
                                     UInt32 width,
                                     UInt32 height,
                                     float alpha_level)
        {
            float right, bottom;

            // Start a quad.
            GL.Begin(BeginMode.Quads);


            // Set the colors for these vertices.
            GL.Color4(1.0f, 1.0f, 1.0f, alpha_level);

            // Draw around a rectangle.
            right = dest_x + (scale_x * (float)width);
            bottom = dest_y + (scale_y * (float)height);

            GL.TexCoord2(0, 0);
            GL.Vertex3(dest_x, dest_y, 0f);

            GL.TexCoord2(1.0, 0.0);
            GL.Vertex3(right, dest_y, 0f);

            GL.TexCoord2(1.0, 1.0);
            GL.Vertex3(right, bottom, 0f);

            GL.TexCoord2(0.0, 1.0);
            GL.Vertex3(dest_x, bottom, 0f);
            // Done with the vertices.
            GL.End();
        }

        static void Submit_lines( float dest_x,
                                  float dest_y,
                                  float scale_x,
                                  float scale_y,
                                  UInt32 width,
                                  UInt32 height)
        {
            float right, bottom;

            //
            // Start a quad.
            //
            GL.Begin(BeginMode.Lines);

            GL.Color4(1.0f, 1.0f, 1.0f, 1.0f);

            //
            // Draw around a rectangle.
            //

            right = dest_x + (scale_x * (float)width);
            bottom = dest_y + (scale_y * (float)height);

            GL.Vertex3(dest_x, dest_y, 0.0F);
            GL.Vertex3(right, dest_y, 0.0F);

            GL.Vertex3(right, dest_y, 0.0F);
            GL.Vertex3(right, bottom, 0.0F);

            GL.Vertex3(right, bottom, 0.0F);
            GL.Vertex3(dest_x, bottom, 0.0F);

            GL.Vertex3(dest_x, bottom, 0.0F);
            GL.Vertex3(dest_x, dest_y, 0.0F);

            GL.Color4(1.0f, 0.0f, 0.0f, 1.0f);

            GL.Vertex3(dest_x, dest_y, 0.0F);
            GL.Vertex3(right, bottom, 0.0F);

            GL.Vertex3(right, dest_y, 0.0F);
            GL.Vertex3(dest_x, bottom, 0.0F);

            GL.End();
        }
        public static void Blit_RAD_3D_image( RAD3DIMAGE rad_image,
										 float x_offset,
										 float y_offset,
										 float x_scale,
										 float y_scale,
										 float alpha_level )
		{
		  UInt32[] textures;
		  Byte[] pixels;
		  UInt32 x, y;
		  float dest_x, dest_y;
          float adjust_x, adjust_y;
		  UInt32 x_skip, y_skip;

          if (rad_image == null)
          {
              return;
          }
		  // If alpha is disabled and there is no texture alpha, turn alpha off.
		  if ( ( alpha_level >= (1.0F-0.0001) ) && ( rad_image.alpha_pixels ) )
		  {
              GL.Disable(EnableCap.Blend);
		  }
		  else
		  {
              GL.Enable(EnableCap.Blend);
              GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);
		  }

		  // Now loop through all of our textures, submitting them.

		  pixels = rad_image.pixels;
		  textures = rad_image.gl_textures;

		  // Calculate how many bytes to move to the next texture block in X.
          // NOTE(TODO): im not sure if this correction is allRite
		  x_skip = ( rad_image.maximum_texture_size * rad_image.pixel_size );

		  //
		  // Calculate how many bytes to move to the next texture block in Y.
		  //

		  y_skip = ( rad_image.pitch *
					 rad_image.maximum_texture_size ) -
				   ( rad_image.textures_across *
					 rad_image.maximum_texture_size *
					1 /*rad_image.pixel_size*/ );

		  adjust_x = ( x_scale * (float) rad_image.maximum_texture_size );
		  adjust_y = ( y_scale * (float) rad_image.maximum_texture_size );
		  
		  dest_y = y_offset;

          int i = 0; int intMaxTexSize = (int)rad_image.maximum_texture_size;
		  for ( y = 0 ; y < rad_image.textures_down ; y++ )
		  {
			dest_x = x_offset;

			for ( x = 0 ; x < rad_image.textures_across ; x++ )
			{
			  // Select the proper texture.
                GL.BindTexture(TextureTarget.Texture2D, textures[i++] );

			  // If we got new pixels, download them.
			  if ( rad_image.download_textures > 0 )
			  {
				Submit_texture( pixels,
								rad_image.row_length,
                                intMaxTexSize,
                                intMaxTexSize,
								rad_image.gl_surface_type );
			  }

			  //
			  // Submit the vertices.
			  Submit_vertices( dest_x,
							   dest_y,
							   x_scale,
							   y_scale,
							   rad_image.maximum_texture_size,
							   rad_image.maximum_texture_size,
							   alpha_level );

			  dest_x += adjust_x;

              Array.Copy(pixels,x_skip,pixels,0,pixels.Length-x_skip);
              
			  //pixels. += x_skip;//wtf i should do now? ;/
			}


			// Handle the right side remnant (if any).

			if ( rad_image.remnant_width > 0 )
			{
			  // Select the proper texture.
                GL.BindTexture(TextureTarget.Texture2D, textures[i++]);

			  // If we got new pixels, download them.
			  if ( rad_image.download_textures > 0)
			  {
				Submit_texture( pixels,
								rad_image.row_length,
                                intMaxTexSize,
                                intMaxTexSize,
								rad_image.gl_surface_type );
			  }

			  //
			  // Submit the vertices.
			  Submit_vertices( dest_x,
							   dest_y,
							   x_scale,
							   y_scale,
							   rad_image.remnant_width,
							   rad_image.maximum_texture_size,
							   alpha_level );
			}

			dest_y += adjust_y;

            Array.Copy(pixels, y_skip, pixels, 0, pixels.Length - y_skip);
		  }

		  // Handle the bottom row remnants (if any).
		  if ( rad_image.remnant_height > 0)
		  {
			dest_x = x_offset;

			for ( x = 0 ; x < rad_image.textures_across ; x++ )
			{
                // Select the proper texture.
                GL.BindTexture(TextureTarget.Texture2D, textures[i++]);

			  // If we got new pixels, download them.
			  if ( rad_image.download_textures > 0)
			  {
				Submit_texture( pixels,
								rad_image.row_length,
								intMaxTexSize,
								(int)rad_image.remnant_input_height,
								rad_image.gl_surface_type );
			  }

			  // Submit the vertices.
			  Submit_vertices( dest_x,
							   dest_y,
							   x_scale,
							   y_scale,
							   rad_image.maximum_texture_size,
							   rad_image.remnant_height,
							   alpha_level );

			  dest_x += adjust_x;

              Array.Copy(pixels, x_skip, pixels, 0, pixels.Length - x_skip);
			}

			if ( rad_image.remnant_width > 0)
			{
                // Select the proper texture.
                GL.BindTexture(TextureTarget.Texture2D, textures[i++]);

			  // If we got new pixels, download them.
			  if ( rad_image.download_textures > 0)
			  {
				Submit_texture( pixels,
								rad_image.row_length,
								(int)rad_image.remnant_input_width,
                                (int)rad_image.remnant_input_height,
								rad_image.gl_surface_type );
			  }

			  //
			  // Submit the vertices.
			  //

			  Submit_vertices( dest_x,
							   dest_y,
							   x_scale,
							   y_scale,
							   rad_image.remnant_width,
							   rad_image.remnant_height,
							   alpha_level );
			}
		  }

		  //
		  // Clear the download texture flag after a blit.
		  //

		  rad_image.download_textures = 0;
		}
#region Bink/RadSurface consts
        public static UInt32 BINKSURFACE8P    =  0;
        public static UInt32 BINKSURFACE24    =  1;
        public static UInt32 BINKSURFACE24R   =  2;
        public static UInt32 BINKSURFACE32    =  3;
        public static UInt32 BINKSURFACE32R   =  4;
        public static UInt32 BINKSURFACE32A   =  5;
        public static UInt32 BINKSURFACE32RA  =  6;
        public static UInt32 BINKSURFACE4444  =  7;
        public static UInt32 BINKSURFACE5551  =  8;
        public static UInt32 BINKSURFACE555   =  9;
        public static UInt32 BINKSURFACE565   = 10;
        public static UInt32 BINKSURFACE655   = 11;
        public static UInt32 BINKSURFACE664   = 12;
        public static UInt32 BINKSURFACEYUY2  = 13;
        public static UInt32 BINKSURFACEUYVY  = 14;
        public static UInt32 BINKSURFACEYV12  = 15;
        public static UInt32 BINKSURFACEMASK  = 15;

        static UInt32 RAD3DSURFACE32    = 0;
        static UInt32 RAD3DSURFACE32A   = 1;
        static UInt32 RAD3DSURFACE555   = 2;
        static UInt32 RAD3DSURFACE565   = 3;
        static UInt32 RAD3DSURFACE5551  = 4;
        static UInt32 RAD3DSURFACE4444  = 5;
        static UInt32 RAD3DSURFACE32R   = 6;
        static UInt32 RAD3DSURFACE32RA  = 7;
        static UInt32 RAD3DSURFACE24    = 8;
        static UInt32 RAD3DSURFACE24R   = 9;
        static UInt32 RAD3DSURFACECOUNT = ( RAD3DSURFACE24R + 1 );
#endregion
        static UInt32[] Bink_surface_type = new UInt32[RAD3DSURFACECOUNT];

        public static void Setup_surface_array()
        {
          Bink_surface_type[ RAD3DSURFACE24 ] = BINKSURFACE24;
          Bink_surface_type[ RAD3DSURFACE24R ] = BINKSURFACE24R;
          Bink_surface_type[ RAD3DSURFACE32 ] = BINKSURFACE32;
          Bink_surface_type[ RAD3DSURFACE32R ] = BINKSURFACE32R;
          Bink_surface_type[ RAD3DSURFACE32A ] = BINKSURFACE32A;
          Bink_surface_type[ RAD3DSURFACE32RA ] = BINKSURFACE32RA;
          Bink_surface_type[ RAD3DSURFACE555 ] = BINKSURFACE555;
          Bink_surface_type[ RAD3DSURFACE565 ] = BINKSURFACE565;
          Bink_surface_type[ RAD3DSURFACE5551 ] = BINKSURFACE5551;
          Bink_surface_type[ RAD3DSURFACE4444 ] = BINKSURFACE4444;
        }
        public static UInt32 Maximum_texture_size = 512;
        public unsafe static bool Allocate_3D_images(CookieMonster_Objects.VideoPlayer src)
        {
            // Now, all is based on BinkBuffer API
            // Try of implement Bink over c# and openTK was above my skills :(
            return false;
            /*
            RAD3DIMAGE New_image;
            // Try to open a 3D image for the foreground Bink.
            New_image = Open_RAD_3D_image(src.rad3d,
                                                src.binkRef->Width,
                                                src.binkRef->Height,
                                                ((src.binkRef->OpenFlags & DLL.Bink.openFlags.BINKALPHA) == DLL.Bink.openFlags.BINKALPHA),
                                                Maximum_texture_size);
            if (New_image != null)
            {

                if (src.radImage != null)
                    Close_RAD_3D_image(src.radImage);
                src.setNewRADIMAGE3D(New_image);
                //
                // Advance the Bink to fill the textures.
                //

                Decompress_frame(src, true);
                DLL.Bink.BinkNextFrame(src.binkRef);

                return (true);
            }

            // Free the images if any were opened.
            if (src.radImage!=null)
                Close_RAD_3D_image(src.radImage);

            return (false);
             */
        }
        static uint BINKCOPYALL = 0x80000000;
        static public unsafe void ProcessFrame(CookieMonster_Objects.VideoPlayer src)
        {
            // Added (orc):
            // set dst posx/y to position that will render video in the center of screen
            int hlp = (int)(EngineApp.Game.self.Width / 2 - src.binkRef->Width / 2);
            //if (hlp < 0) hlp = 0;
            UInt32 dstx = (uint)Math.Max(hlp, 0);
            hlp = (int)(EngineApp.Game.self.Height / 2 - src.binkRef->Height / 2);
            if (hlp < 0) hlp = 0;
            UInt32 dsty = (uint)Math.Max(hlp,0);
            // Decompress the Bink frame.
            // (by binkw3.dll)
            DLL.Bink.BinkDoFrame(src.binkRef);
            // Lock the 3D image so that we can copy the decompressed frame into it.
            while (DLL.Bink.BinkWait(src.binkRef) > 0)
                System.Threading.Thread.Sleep(6);

            if (DLL.Bink.BinkBufferLock(src.binkBufRef)!= 0)
            {
                //
                // Copy the decompressed frame into the 3D image.
                DLL.Bink.BinkCopyToBuffer(src.binkRef,
                                      src.binkBufRef->Buffer,
                                      src.binkBufRef->BufferPitch,
                                      src.binkBufRef->Height,
                                      dstx,
                                      dsty,
                                      src.binkBufRef->SurfaceType | BINKCOPYALL | 0x00080000);

                DLL.Bink.BinkBufferUnlock(src.binkBufRef);
            }
            DLL.Bink.BinkBufferBlit(src.binkBufRef, src.binkRef->FrameRects, DLL.Bink.BinkGetRects(src.binkRef, src.binkBufRef->SurfaceType));
            DLL.Bink.BinkNextFrame(src.binkRef);
        }


        internal unsafe static void Show_foreground_frame(CookieMonster_Objects.VideoPlayer src)
        {

            // Now, all is based on BinkBuffer API
            // Try of implement Bink over c# and openTK was above my skills :(
            /*
           // Start_timer();
            Decompress_frame(src, false);
           //End_and_start_next_timer(Bink_microseconds);

            // Begin a 3D frame.
            Start_RAD_3D_frame(src.rad3d);//clearing and stuff

            // Draw the image on the screen.
            Blit_RAD_3D_image(src.radImage, 0, 0, 1.0F, 1.0F, 1.0F);
            
            // End a 3D frame.
            End_RAD_3D_frame(src.rad3d);

            //End_timer(Render_microseconds);

            // Keep playing the movie.
            DLL.Bink.BinkNextFrame(src.binkRef);
             */
        }
    }//BinkGL class
}
using System;
using System.Collections.Generic;

using System.Text;
using CookieMonster.DLL;
using CookieMonster;
using OpenTK.Graphics;

namespace CookieMonster.CookieMonster_Objects
{
	class VideoPlayer
	{
		public unsafe Bink.BINK*  binkRef{get; private set;}
        public unsafe Bink.BINKBUFFER* binkBufRef{get; private set;}
        private Sound videoSoundtrack;
        private string videoBikPath;
		public BinkGL.RAD3D rad3d { get; private set;}
        public BinkGL.RAD3DIMAGE radImage { get; private set; }
        private OpenTK.DisplayResolution storedResolution;
        private OpenTK.DisplayResolution filmResolution;
        public bool someVideoIsPlaying { get; private set; }
		unsafe public void playVideo(string path)
		{
            //set OpenTK rendering to black fill:
            videoBikPath = path;
            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
            EngineApp.Game.self.SwapBuffers();

            someVideoIsPlaying = true;
            binkRef = DLL.Bink.BinkOpen(path, Bink.openFlags.BINKNOSKIP|Bink.openFlags.BINKCOPYNOSCALING);
                /*all scallings+different bliting*/
            //1-works on xp x86 and win7 windowed
            
            // Very ugly-one bugfix:
            // At newer than winXp systems dll is crashing when callink BinkBufferOpen on fullscreen mode.
            // So here is some workaround:
            //check is current runing system is >winXP:
            if (Environment.OSVersion.Platform == PlatformID.Win32NT && Environment.OSVersion.Version.Major > 5)
            {
                EngineApp.Game.self.WindowState = OpenTK.WindowState.Normal; //BUGFIX: Set now to fullscreen only on winXP
            }

            binkBufRef = DLL.Bink.BinkBufferOpen(EngineApp.Game.self.windowHandle, binkRef->Width, binkRef->Height, 1);

            if (Environment.OSVersion.Platform == PlatformID.Win32NT && Environment.OSVersion.Version.Major > 5)
            {
                EngineApp.Game.self.WindowState = OpenTK.WindowState.Fullscreen; //BUGFIX: Set now to fullscreen only on winXP
                GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
                EngineApp.Game.self.SwapBuffers();
            }
            BinkGL.Start_RAD_3D_frame(rad3d);
            //Moved to renderVideoLoop
            //tryToPlaySoundTrack(path);

             //restoreResolution();
           
		}
        /// <summary>
        /// Triggered from Game.onRender
        /// </summary>
        /// <returns>True when some video was playing and frame was processed, else it will return false</returns>
        unsafe public bool renderVideoLoop()
        {
            if (someVideoIsPlaying)
            {
                if(binkRef->FrameNum<=1)
                    tryToPlaySoundTrack(videoBikPath);
                if (binkRef->FrameNum + 1 < binkRef->Frames)
                    BinkGL.ProcessFrame(this);
                else
                    stopPlayingVideo();//last frame was rendered, closing Bink
                return true;
            }
            else
                return false;
        }
        unsafe public void stopPlayingVideo()
        {
            someVideoIsPlaying = false;
            DLL.Bink.BinkBufferClose(binkBufRef);
            DLL.Bink.BinkClose(binkRef);
            if (videoBikPath == "../data/Videos/logo.bik")
                EngineApp.Game.self.afterLogoVideo();
            else if (videoBikPath == "../data/Videos/intro.bik")
            {
                EngineApp.Game.self.afterIntroVideo();                
            }
        }
        public void setNewRADIMAGE3D(BinkGL.RAD3DIMAGE new_)
        {
            radImage = new_;
        }
        private void tryToPlaySoundTrack(string path)
        {
            path = path.Substring(0, path.LastIndexOf("."));
            path = path + "_track.ogg";
            if(System.IO.File.Exists(path))
            {
                videoSoundtrack = new Sound(Sound.eSndType.UNKNOWN,path,false,true);
            }
        }
        private void setBestResolution()
        {            
            return;
            EngineApp.Game g = EngineApp.Game.self;
            storedResolution = OpenTK.DisplayDevice.Default.SelectResolution(g.Width, g.Height, OpenTK.DisplayDevice.Default.BitsPerPixel, OpenTK.DisplayDevice.Default.RefreshRate);
            double screenProportions = (double)storedResolution.Height / storedResolution.Width;
            unsafe
            {
                filmResolution = OpenTK.DisplayDevice.Default.SelectResolution((int)binkRef->Width, (int)(binkRef->Width * screenProportions), storedResolution.BitsPerPixel, storedResolution.RefreshRate);
                if (filmResolution.Width == storedResolution.Width &&
                filmResolution.Width != binkRef->Width)
                    filmResolution = OpenTK.DisplayDevice.Default.SelectResolution((int)binkRef->Width, 0, 32, 70);
                if (filmResolution.Width != binkRef->Width)
                    filmResolution = OpenTK.DisplayDevice.Default.SelectResolution((int)binkRef->Width,(int)binkRef->Height, 32, 0);

            }
            if (filmResolution.Width != storedResolution.Width)
                OpenTK.DisplayDevice.Default.ChangeResolution(filmResolution);
        }
        private void restoreResolution()
        {
            return;
            if(filmResolution.Width != storedResolution.Width)
                OpenTK.DisplayDevice.Default.ChangeResolution(storedResolution);
        }


        internal unsafe void keyDown(object sender, OpenTK.Input.KeyboardKeyEventArgs k)
        {
            if (someVideoIsPlaying)
            {
                //Skip playing bink video:
                DLL.Bink.BinkGoto(binkRef, binkRef->Frames - 1, 1);//1=BINKGOTOQUICK;
                //Skip video soundtrack:
                if(videoSoundtrack!=null)
                videoSoundtrack.Free();
            }
        }
    }
}
using System;
using System.Collections.Generic;
using System.Text;
using EngineApp;
using OpenTK;

namespace CookieMonster.CookieMonster_Objects
{
    class Viewport
    {
        static public System.IO.StreamWriter scaleLog = new System.IO.StreamWriter("scaleLog.txt",false);
        // default window sizes:
        public const int guiBase_width = 1280;
        public const int guiBase_height = 800;
        public const int guiBase_height_MENUOVERRIDE = 800;
        static int render_width = 1280;
        static int render_height = 800;
        static int screen_width;
        static int screen_height;
        bool fullscreen;
        /// <summary>
        /// This value is properly updated when resoulution is changed
        /// </summary>
        public int width 
        {
            get { return render_width;}
            set { render_width = value;}
        }
        /// <summary>
        /// This value is properly updated when resoulution is changed
        /// </summary>
        public int height
        {
            get { return render_height; }
            set { render_height = value; }
        }

        List<Obj> rendered_objects = new List<Obj>();
        List<Obj> onceRendered_objects = new List<Obj>();
        private Game _game;
        private TextManager txtMgr;
        private GameMap currentGameMap;
        public bool isFading { get { return isFadingOut | isFadingIn; } }//if viewport is fading still render it!
        private bool isFadingOut;//
        private bool isFadingIn;//
        private double fadingAlphaStep; // value that will be added/removed every frame
        public bool partialViewport; // if it's true it will render his object don't matter what
                                     // usable fe. with rendering new music track title, some gui on game screen
        /// <summary>
        /// Constructor of class
        /// </summary>
        /// <param name="w">window width</param>
        /// <param name="h">window heigh</param>
        /// <param name="f">fullscreen mode?</param>
        public Viewport(int w, int h,bool f)
        {
            _game = Game.self;
            render_height = _game.ClientSize.Height;
            render_width = _game.ClientSize.Width;
            fullscreen = f;
           // _game.setScreenMode(fullscreen);
            screen_width = DisplayDevice.Default.Width;
            screen_height = DisplayDevice.Default.Height;
            //DisplayDevice.Default.ChangeResolution(render_width, render_height, 32, 100);
            _game.Height = render_height; _game.Width = render_width;
            _game.X = 0; _game.Y = 0;
            txtMgr = _game.textMenager;
            
        }
        /// <summary>
        /// Renders all objects added to viewport
        /// </summary>
        public void Render()
        {
            if ((partialViewport==false)&&(_game.gameManager != null))
            {
                _game.gameManager.Render();
            }
            else//normal rendering without game map
                for (int i = 0; i < rendered_objects.Count; i++)
                    rendered_objects[i].Render();

            for (int i = 0; i < onceRendered_objects.Count; i++)
            {
                onceRendered_objects[i].Render();
                onceRendered_objects[i].Free();
            }
            onceRendered_objects.Clear();
            //render text's overlaying objects:(if current viewport is global, not partial
            if (partialViewport == false)
                txtMgr.onRender();
        }
        /// <summary>
        /// Removing all objects from rendered list, runing Clear for each
        /// TODO: Dispose memory used by objects!!!
        /// </summary>
        public void Clear()
        {
            for (int i = 0; i < rendered_objects.Count; i++)
                rendered_objects[i].Free();
            rendered_objects.Clear();

        }
        public void addObject(Obj o)
        {
            if (o.renderOnce==true)
                onceRendered_objects.Add(o);
            else
                rendered_objects.Add(o);
        }
        /// <summary>
        /// it will remove first file founded with this path
        /// </summary>
        /// <param name="path"></param>
        public void removeObjectByFilePath(string path)
        {
            for (int i = rendered_objects.Count - 1; i >= 0; i--)
            {
                if (rendered_objects[i].texturePath == path)
                {
                    rendered_objects.RemoveAt(i);
                    break;
                }
            }
        }
        public void setFadeOut(double step)
        {
            isFadingOut = true;
            fadingAlphaStep = step;
        }
        public void setFadeIn(double step)
        {
            isFadingIn = true;
            fadingAlphaStep = step;
            //start from 0 alpha:
            for (int i = 0; i < rendered_objects.Count; i++)
                rendered_objects[i].setAllTexsAlpha(0);
        }
        /// <summary>
        /// takes care of Fading-IN/OUT
        /// </summary>
        public void Update()
        {
            if ((isFadingIn)&&(rendered_objects.Count>0))
            {
                int newAlpha = (int)(rendered_objects[0].getCurrentTexAlpha() + fadingAlphaStep);
                if(newAlpha<255)
                    for (int i = 0; i < rendered_objects.Count; i++)
                        rendered_objects[i].setAllTexsAlpha((byte)newAlpha);
                else
                    for (int i = 0; i < rendered_objects.Count; i++)
                    {
                        rendered_objects[i].setAllTexsAlpha(255);
                        isFadingIn = false;
                    }
            }
            else if ((isFadingOut)&&(rendered_objects.Count>0))
            {      
                int newAlpha = (int)(rendered_objects[0].getCurrentTexAlpha()-fadingAlphaStep);
                if(newAlpha>0)
                    for (int i = 0; i < rendered_objects.Count; i++)
                        rendered_objects[i].setAllTexsAlpha((byte)newAlpha);
                else
                    for (int i = 0; i < rendered_objects.Count; i++)
                    {
                        isFadingOut = false;
                        Clear();//faded out, clear all objects from render queue
                    }
            }
            else
            {
                isFadingIn = isFadingOut = false; //no objects, turn it off!
            }
        }
        /// <summary>
        /// sets current game map so it will be included in rendering process
        /// </summary>
        /// <param name="map"></param>
        public void setGameMap(GameMap map)
        {
            currentGameMap = map;
        }

        /// <summary>
        /// Rescaling & repositioning of all objects in this viewport
        /// </summary>
        /// <param name="res"></param>
        public void adaptToNewResolution()
        {
            render_width = Profile.currentProfile.config.options.graphics.resolution.Width;
            render_height = Profile.currentProfile.config.options.graphics.resolution.Height;
            for (int i = 0; i < rendered_objects.Count; i++)
                rendered_objects[i].guiObjRescale();
        }
    }
}
